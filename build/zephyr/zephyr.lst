
zephyr.elf:     file format elf32-xtensa-le


Disassembly of section .iram0.vectors:

40080000 <_WindowOverflow4>:

    .org    0x0
    .global _WindowOverflow4
_WindowOverflow4:

    s32e    a0, a5, -16     /* save a0 to call[j+1]'s stack frame */
40080000:	49c500        	s32e	a0, a5, -16
    s32e    a1, a5, -12     /* save a1 to call[j+1]'s stack frame */
40080003:	49d510        	s32e	a1, a5, -12
    s32e    a2, a5,  -8     /* save a2 to call[j+1]'s stack frame */
40080006:	49e520        	s32e	a2, a5, -8
    s32e    a3, a5,  -4     /* save a3 to call[j+1]'s stack frame */
40080009:	49f530        	s32e	a3, a5, -4
    rfwo                    /* rotates back to call[i] position */
4008000c:	003400        	rfwo
	...

40080040 <_WindowUnderflow4>:

    .org    0x40
    .global _WindowUnderflow4
_WindowUnderflow4:

    l32e    a0, a5, -16     /* restore a0 from call[i+1]'s stack frame */
40080040:	09c500        	l32e	a0, a5, -16
    l32e    a1, a5, -12     /* restore a1 from call[i+1]'s stack frame */
40080043:	09d510        	l32e	a1, a5, -12
    l32e    a2, a5,  -8     /* restore a2 from call[i+1]'s stack frame */
40080046:	09e520        	l32e	a2, a5, -8
    l32e    a3, a5,  -4     /* restore a3 from call[i+1]'s stack frame */
40080049:	09f530        	l32e	a3, a5, -4
    rfwu
4008004c:	003500        	rfwu
	...

40080050 <_xt_alloca_exc>:

    .align  4
    .global _xt_alloca_exc
_xt_alloca_exc:

    rsr     a0, WINDOWBASE  /* grab WINDOWBASE before rotw changes it */
40080050:	034800        	rsr.windowbase	a0
    rotw    -1      /* WINDOWBASE goes to a4, new a0-a3 are scratch */
40080053:	4080f0        	rotw	-1
    rsr     a2, PS
40080056:	03e620        	rsr.ps	a2
    extui   a3, a2, XCHAL_PS_OWB_SHIFT, XCHAL_PS_OWB_BITS
40080059:	343820        	extui	a3, a2, 8, 4
    xor     a3, a3, a4    /* bits changed from old to current windowbase */
4008005c:	303340        	xor	a3, a3, a4
    rsr     a4, EXCSAVE_1   /* restore original a0 (now in a4) */
4008005f:	03d140        	rsr.excsave1	a4
    slli    a3, a3, XCHAL_PS_OWB_SHIFT
40080062:	113380        	slli	a3, a3, 8
    xor     a2, a2, a3      /* flip changed bits in old window base */
40080065:	302230        	xor	a2, a2, a3
    wsr     a2, PS          /* update PS.OWB to new window base */
40080068:	13e620        	wsr.ps	a2
    rsync
4008006b:	002010        	rsync

    _bbci.l a4, 31, _WindowUnderflow4
4008006e:	ce74f7        	bbci	a4, 31, 40080040 <_WindowUnderflow4>
    rotw    -1              /* original a0 goes to a8 */
40080071:	4080f0        	rotw	-1
    _bbci.l a8, 30, _WindowUnderflow8
40080074:	4878e7        	bbci	a8, 30, 400800c0 <_WindowUnderflow8>
    rotw    -1
40080077:	4080f0        	rotw	-1
    j               _WindowUnderflow12
4008007a:	003086        	j	40080140 <_WindowUnderflow12>
4008007d:	000000        	ill

40080080 <_WindowOverflow8>:

    .org    0x80
    .global _WindowOverflow8
_WindowOverflow8:

    s32e    a0, a9, -16     /* save a0 to call[j+1]'s stack frame */
40080080:	49c900        	s32e	a0, a9, -16
    l32e    a0, a1, -12     /* a0 <- call[j-1]'s sp
40080083:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1, a9, -12     /* save a1 to call[j+1]'s stack frame */
40080086:	49d910        	s32e	a1, a9, -12
    s32e    a2, a9,  -8     /* save a2 to call[j+1]'s stack frame */
40080089:	49e920        	s32e	a2, a9, -8
    s32e    a3, a9,  -4     /* save a3 to call[j+1]'s stack frame */
4008008c:	49f930        	s32e	a3, a9, -4
    s32e    a4, a0, -32     /* save a4 to call[j]'s stack frame */
4008008f:	498040        	s32e	a4, a0, -32
    s32e    a5, a0, -28     /* save a5 to call[j]'s stack frame */
40080092:	499050        	s32e	a5, a0, -28
    s32e    a6, a0, -24     /* save a6 to call[j]'s stack frame */
40080095:	49a060        	s32e	a6, a0, -24
    s32e    a7, a0, -20     /* save a7 to call[j]'s stack frame */
40080098:	49b070        	s32e	a7, a0, -20
    rfwo                    /* rotates back to call[i] position */
4008009b:	003400        	rfwo
	...

400800c0 <_WindowUnderflow8>:

    .org    0xC0
    .global _WindowUnderflow8
_WindowUnderflow8:

    l32e    a0, a9, -16     /* restore a0 from call[i+1]'s stack frame */
400800c0:	09c900        	l32e	a0, a9, -16
    l32e    a1, a9, -12     /* restore a1 from call[i+1]'s stack frame */
400800c3:	09d910        	l32e	a1, a9, -12
    l32e    a2, a9,  -8     /* restore a2 from call[i+1]'s stack frame */
400800c6:	09e920        	l32e	a2, a9, -8
    l32e    a7, a1, -12     /* a7 <- call[i-1]'s sp
400800c9:	09d170        	l32e	a7, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3, a9,  -4     /* restore a3 from call[i+1]'s stack frame */
400800cc:	09f930        	l32e	a3, a9, -4
    l32e    a4, a7, -32     /* restore a4 from call[i]'s stack frame */
400800cf:	098740        	l32e	a4, a7, -32
    l32e    a5, a7, -28     /* restore a5 from call[i]'s stack frame */
400800d2:	099750        	l32e	a5, a7, -28
    l32e    a6, a7, -24     /* restore a6 from call[i]'s stack frame */
400800d5:	09a760        	l32e	a6, a7, -24
    l32e    a7, a7, -20     /* restore a7 from call[i]'s stack frame */
400800d8:	09b770        	l32e	a7, a7, -20
    rfwu
400800db:	003500        	rfwu
	...

40080100 <_WindowOverflow12>:

    .org    0x100
    .global _WindowOverflow12
_WindowOverflow12:

    s32e    a0,  a13, -16   /* save a0 to call[j+1]'s stack frame */
40080100:	49cd00        	s32e	a0, a13, -16
    l32e    a0,  a1,  -12   /* a0 <- call[j-1]'s sp
40080103:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1,  a13, -12   /* save a1 to call[j+1]'s stack frame */
40080106:	49dd10        	s32e	a1, a13, -12
    s32e    a2,  a13,  -8   /* save a2 to call[j+1]'s stack frame */
40080109:	49ed20        	s32e	a2, a13, -8
    s32e    a3,  a13,  -4   /* save a3 to call[j+1]'s stack frame */
4008010c:	49fd30        	s32e	a3, a13, -4
    s32e    a4,  a0,  -48   /* save a4 to end of call[j]'s stack frame */
4008010f:	494040        	s32e	a4, a0, -48
    s32e    a5,  a0,  -44   /* save a5 to end of call[j]'s stack frame */
40080112:	495050        	s32e	a5, a0, -44
    s32e    a6,  a0,  -40   /* save a6 to end of call[j]'s stack frame */
40080115:	496060        	s32e	a6, a0, -40
    s32e    a7,  a0,  -36   /* save a7 to end of call[j]'s stack frame */
40080118:	497070        	s32e	a7, a0, -36
    s32e    a8,  a0,  -32   /* save a8 to end of call[j]'s stack frame */
4008011b:	498080        	s32e	a8, a0, -32
    s32e    a9,  a0,  -28   /* save a9 to end of call[j]'s stack frame */
4008011e:	499090        	s32e	a9, a0, -28
    s32e    a10, a0,  -24   /* save a10 to end of call[j]'s stack frame */
40080121:	49a0a0        	s32e	a10, a0, -24
    s32e    a11, a0,  -20   /* save a11 to end of call[j]'s stack frame */
40080124:	49b0b0        	s32e	a11, a0, -20
    rfwo                    /* rotates back to call[i] position */
40080127:	003400        	rfwo
	...

40080140 <_WindowUnderflow12>:

    .org 0x140
    .global _WindowUnderflow12
_WindowUnderflow12:

    l32e    a0,  a13, -16 /* restore a0 from call[i+1]'s stack frame */
40080140:	09cd00        	l32e	a0, a13, -16
    l32e    a1,  a13, -12 /* restore a1 from call[i+1]'s stack frame */
40080143:	09dd10        	l32e	a1, a13, -12
    l32e    a2,  a13,  -8 /* restore a2 from call[i+1]'s stack frame */
40080146:	09ed20        	l32e	a2, a13, -8
    l32e    a11, a1,  -12 /* a11 <- call[i-1]'s sp
40080149:	09d1b0        	l32e	a11, a1, -12
                           * (used to find end of call[i]'s frame) */
    l32e    a3,  a13,  -4 /* restore a3 from call[i+1]'s stack frame */
4008014c:	09fd30        	l32e	a3, a13, -4
    l32e    a4,  a11, -48 /* restore a4 from end of call[i]'s stack frame */
4008014f:	094b40        	l32e	a4, a11, -48
    l32e    a5,  a11, -44 /* restore a5 from end of call[i]'s stack frame */
40080152:	095b50        	l32e	a5, a11, -44
    l32e    a6,  a11, -40 /* restore a6 from end of call[i]'s stack frame */
40080155:	096b60        	l32e	a6, a11, -40
    l32e    a7,  a11, -36 /* restore a7 from end of call[i]'s stack frame */
40080158:	097b70        	l32e	a7, a11, -36
    l32e    a8,  a11, -32 /* restore a8 from end of call[i]'s stack frame */
4008015b:	098b80        	l32e	a8, a11, -32
    l32e    a9,  a11, -28 /* restore a9 from end of call[i]'s stack frame */
4008015e:	099b90        	l32e	a9, a11, -28
    l32e    a10, a11, -24 /* restore a10 from end of call[i]'s stack
40080161:	09aba0        	l32e	a10, a11, -24
    		       * frame */
    l32e    a11, a11, -20   /* restore a11 from end of call[i]'s stack
40080164:	09bbb0        	l32e	a11, a11, -20
    			 * frame */
    rfwu
40080167:	003500        	rfwu
	...

40080180 <_Level2Vector>:
 */

DEF_EXCINT 1, _handle_excint, xtensa_excint1_c

#if XCHAL_NMILEVEL >= 2
DEF_EXCINT 2, _handle_excint, xtensa_int2_c
40080180:	c4c112        	addi	a1, a1, -60
40080183:	7109      	s32i.n	a0, a1, 28
40080185:	9129      	s32i.n	a2, a1, 36
40080187:	a139      	s32i.n	a3, a1, 40
40080189:	03c200        	rsr.eps2	a0
4008018c:	5109      	s32i.n	a0, a1, 20
4008018e:	03b200        	rsr.epc2	a0
40080191:	6109      	s32i.n	a0, a1, 24
40080193:	000246        	j	400801a0 <_after_imms2>
	...

40080198 <_handle_excint_imm2>:
40080198:	081890        	lsx	f1, a8, a9
4008019b:	40          	.byte 0x40

4008019c <_c_handler_imm2>:
4008019c:	19cc      	bnez.n	a9, 400801a1 <_after_imms2+0x1>
4008019e:	4008      	l32i.n	a0, a0, 16

400801a0 <_after_imms2>:
400801a0:	ffff21        	l32r	a2, 4008019c <_c_handler_imm2>
400801a3:	fffd01        	l32r	a0, 40080198 <_handle_excint_imm2>
400801a6:	0000a0        	jx	a0
	...

400801c0 <_Level3Vector>:
#endif

#if XCHAL_NMILEVEL >= 3
DEF_EXCINT 3, _handle_excint, xtensa_int3_c
400801c0:	c4c112        	addi	a1, a1, -60
400801c3:	7109      	s32i.n	a0, a1, 28
400801c5:	9129      	s32i.n	a2, a1, 36
400801c7:	a139      	s32i.n	a3, a1, 40
400801c9:	03c300        	rsr.eps3	a0
400801cc:	5109      	s32i.n	a0, a1, 20
400801ce:	03b300        	rsr.epc3	a0
400801d1:	6109      	s32i.n	a0, a1, 24
400801d3:	000146        	j	400801dc <_after_imms3>
	...

400801d8 <_c_handler_imm3>:
400801d8:	081a20        	lsx	f1, a10, a2
400801db:	40          	.byte 0x40

400801dc <_after_imms3>:
400801dc:	ffff21        	l32r	a2, 400801d8 <_c_handler_imm3>
400801df:	ffee01        	l32r	a0, 40080198 <_handle_excint_imm2>
400801e2:	0000a0        	jx	a0
	...

40080200 <_Level4Vector>:
#endif

#if XCHAL_NMILEVEL >= 4
DEF_EXCINT 4, _handle_excint, xtensa_int4_c
40080200:	c4c112        	addi	a1, a1, -60
40080203:	7109      	s32i.n	a0, a1, 28
40080205:	9129      	s32i.n	a2, a1, 36
40080207:	a139      	s32i.n	a3, a1, 40
40080209:	03c400        	rsr.eps4	a0
4008020c:	5109      	s32i.n	a0, a1, 20
4008020e:	03b400        	rsr.epc4	a0
40080211:	6109      	s32i.n	a0, a1, 24
40080213:	000146        	j	4008021c <_after_imms4>
	...

40080218 <_c_handler_imm4>:
40080218:	1a9c      	beqz.n	a10, 4008022d <_after_imms4+0x11>
4008021a:	4008      	l32i.n	a0, a0, 16

4008021c <_after_imms4>:
4008021c:	ffff21        	l32r	a2, 40080218 <_c_handler_imm4>
4008021f:	ffde01        	l32r	a0, 40080198 <_handle_excint_imm2>
40080222:	0000a0        	jx	a0
	...

40080240 <_Level5Vector>:
#endif

#if XCHAL_NMILEVEL >= 5
DEF_EXCINT 5, _handle_excint, xtensa_int5_c
40080240:	c4c112        	addi	a1, a1, -60
40080243:	7109      	s32i.n	a0, a1, 28
40080245:	9129      	s32i.n	a2, a1, 36
40080247:	a139      	s32i.n	a3, a1, 40
40080249:	03c500        	rsr.eps5	a0
4008024c:	5109      	s32i.n	a0, a1, 20
4008024e:	03b500        	rsr.epc5	a0
40080251:	6109      	s32i.n	a0, a1, 24
40080253:	000146        	j	4008025c <_after_imms5>
	...

40080258 <_c_handler_imm5>:
40080258:	081b00        	lsx	f1, a11, a0
4008025b:	40          	.byte 0x40

4008025c <_after_imms5>:
4008025c:	ffff21        	l32r	a2, 40080258 <_c_handler_imm5>
4008025f:	ffce01        	l32r	a0, 40080198 <_handle_excint_imm2>
40080262:	0000a0        	jx	a0
	...

40080280 <_Level6Vector>:
#endif

#if XCHAL_NMILEVEL >= 6
DEF_EXCINT 6, _handle_excint, xtensa_int6_c
40080280:	c4c112        	addi	a1, a1, -60
40080283:	7109      	s32i.n	a0, a1, 28
40080285:	9129      	s32i.n	a2, a1, 36
40080287:	a139      	s32i.n	a3, a1, 40
40080289:	03c600        	rsr.eps6	a0
4008028c:	5109      	s32i.n	a0, a1, 20
4008028e:	03b600        	rsr.epc6	a0
40080291:	6109      	s32i.n	a0, a1, 24
40080293:	000146        	j	4008029c <_after_imms6>
	...

40080298 <_c_handler_imm6>:
40080298:	1b58      	l32i.n	a5, a11, 4
4008029a:	4008      	l32i.n	a0, a0, 16

4008029c <_after_imms6>:
4008029c:	ffff21        	l32r	a2, 40080298 <_c_handler_imm6>
4008029f:	ffbe01        	l32r	a0, 40080198 <_handle_excint_imm2>
400802a2:	0000a0        	jx	a0
	...

400802c0 <_Level7Vector>:
#endif

#if XCHAL_NMILEVEL >= 7
DEF_EXCINT 7, _handle_excint, xtensa_int7_c
400802c0:	c4c112        	addi	a1, a1, -60
400802c3:	7109      	s32i.n	a0, a1, 28
400802c5:	9129      	s32i.n	a2, a1, 36
400802c7:	a139      	s32i.n	a3, a1, 40
400802c9:	03c700        	rsr.eps7	a0
400802cc:	5109      	s32i.n	a0, a1, 20
400802ce:	03b700        	rsr.epc7	a0
400802d1:	6109      	s32i.n	a0, a1, 24
400802d3:	000146        	j	400802dc <_after_imms7>
	...

400802d8 <_c_handler_imm7>:
400802d8:	081b70        	lsx	f1, a11, a7
400802db:	40          	.byte 0x40

400802dc <_after_imms7>:
400802dc:	ffff21        	l32r	a2, 400802d8 <_c_handler_imm7>
400802df:	ffae01        	l32r	a0, 40080198 <_handle_excint_imm2>
400802e2:	0000a0        	jx	a0
	...

40080300 <_KernelExceptionVector>:
 * out of simple caution in case app code clears the UM bit by mistake.
 */
.pushsection .KernelExceptionVector.text, "ax"
.global _KernelExceptionVector
_KernelExceptionVector:
	j _Level1Vector
40080300:	016806        	j	400808a4 <_Level1Vector>
	...

40080340 <_Level1RealVector>:
	wsr.excsave1 a0
40080340:	13d100        	wsr.excsave1	a0
	rsr.exccause a0
40080343:	03e800        	rsr.exccause	a0
	bnei a0, EXCCAUSE_ALLOCA, _not_alloca
40080346:	025066        	bnei	a0, 5, 4008034c <_not_alloca>
	j _xt_alloca_exc
40080349:	ff40c6        	j	40080050 <_xt_alloca_exc>

4008034c <_not_alloca>:
	rsr.excsave1 a0
4008034c:	03d100        	rsr.excsave1	a0
	j _Level1Vector
4008034f:	015446        	j	400808a4 <_Level1Vector>
	...

400803c0 <_DoubleExceptionVector>:
.pushsection .DoubleExceptionVector.text, "ax"
.global _DoubleExceptionVector
_DoubleExceptionVector:
#if XCHAL_HAVE_DEBUG
/* Signals an unhandled double exception */
1:	break	1, 4
400803c0:	004140        	break	1, 4
#else
1:
#endif
	j	1b
400803c3:	fffe46        	j	400803c0 <_DoubleExceptionVector>
	...

Disassembly of section text:

40080550 <__start-0x2f0>:
40080550:	080000        	lsx	f0, a0, a0
40080553:	0c8040        	lsi	f4, a0, 48
40080556:	3ffb      	addi.n	a3, a15, 15
40080558:	06a8      	l32i.n	a10, a6, 0
4008055a:	3ffb      	addi.n	a3, a15, 15
4008055c:	808c      	beqz.n	a0, 40080568 <_iram_text_start+0x18>
4008055e:	483ff4        	mula.da.ll.ldinc	m3, a15, m0, a15
40080561:	3ff5f0        	f64cmph	a15, a5, a15, 3
40080564:	ff          	.byte 0xff
40080565:	bf          	.byte 0xbf
40080566:	ff          	.byte 0xff
40080567:	ff          	.byte 0xff
40080568:	040023        	lsi	f2, a0, 16
4008056b:	003000        	rfe
4008056e:	d83ff0        	lsi	f15, a15, 0x360
40080571:	fb0a      	add.n	a15, a11, a0
40080573:	3f          	.byte 0x3f
40080574:	000032        	l8ui	a3, a0, 0
40080577:	000000        	ill
4008057a:	b80000        	lsi	f0, a0, 0x2e0
4008057d:	3ffb02        	s32ri	a0, a11, 252
40080580:	02bb      	addi.n	a0, a2, 11
40080582:	3ffb      	addi.n	a3, a15, 15
40080584:	bf          	.byte 0xbf
40080585:	3ffb02        	s32ri	a0, a11, 252
40080588:	fb02e7        	bnone	a2, a14, 40080587 <_iram_text_start+0x37>
4008058b:	3f          	.byte 0x3f
4008058c:	001a00        	movsp	a0, a10
4008058f:	ffff00        	f64cmph	a15, a15, a0, 15
40080592:	ff          	.byte 0xff
40080593:	ff          	.byte 0xff
40080594:	0098      	l32i.n	a9, a0, 0
40080596:	3ffb      	addi.n	a3, a15, 15
40080598:	ee          	.byte 0xee
40080599:	3ffb02        	s32ri	a0, a11, 252
4008059c:	fb02f7        	bnone	a2, a15, 4008059b <_iram_text_start+0x4b>
4008059f:	3f          	.byte 0x3f
400805a0:	fb0300        	f64addc	a0, a3, 0, 0
400805a3:	3f          	.byte 0x3f
400805a4:	fb0306        	j	4007f1b4 <esp32_rom_gpio_matrix_out+0x752a8>
400805a7:	3f          	.byte 0x3f
400805a8:	030c      	movi.n	a3, 0
400805aa:	3ffb      	addi.n	a3, a15, 15
400805ac:	032b      	addi.n	a0, a3, 2
400805ae:	3ffb      	addi.n	a3, a15, 15
400805b0:	fb0361        	l32r	a6, 4007f1bc <esp32_rom_gpio_matrix_out+0x752b0>
400805b3:	3f          	.byte 0x3f
400805b4:	fb0397        	bnone	a3, a9, 400805b3 <_iram_text_start+0x63>
400805b7:	3f          	.byte 0x3f
400805b8:	03ad      	mov.n	a10, a3
400805ba:	3ffb      	addi.n	a3, a15, 15
400805bc:	fb03d6        	bgez	a3, 40080570 <_iram_text_start+0x20>
400805bf:	3f          	.byte 0x3f
400805c0:	fb0403        	lsi	f0, a4, 0x3ec
400805c3:	3f          	.byte 0x3f
400805c4:	042d      	mov.n	a2, a4
400805c6:	3ffb      	addi.n	a3, a15, 15
400805c8:	fb0454        	lsi	f5, a4, 0x3ec
400805cb:	3f          	.byte 0x3f
400805cc:	fb0497        	bnone	a4, a9, 400805cb <_iram_text_start+0x7b>
400805cf:	3f          	.byte 0x3f
400805d0:	ce          	.byte 0xce
400805d1:	3ffb04        	lsi	f0, a11, 252
400805d4:	04eb      	addi.n	a0, a4, 14
400805d6:	3ffb      	addi.n	a3, a15, 15
400805d8:	04fb      	addi.n	a0, a4, 15
400805da:	3ffb      	addi.n	a3, a15, 15
400805dc:	fb0507        	bnone	a5, a0, 400805db <_iram_text_start+0x8b>
400805df:	3f          	.byte 0x3f
400805e0:	000000        	ill
400805e3:	3e          	.byte 0x3e
400805e4:	fb0520        	f64addc	a2, a5, 0, 0
400805e7:	3f          	.byte 0x3f
400805e8:	0808e4        	lsi	f14, a8, 32
400805eb:	0c8040        	lsi	f4, a0, 48
400805ee:	3ffb      	addi.n	a3, a15, 15
400805f0:	06a8      	l32i.n	a10, a6, 0
400805f2:	3ffb      	addi.n	a3, a15, 15
400805f4:	080984        	lsi	f8, a9, 32
400805f7:	128040        	andbc	b8, b0, b4
400805fa:	3ffb      	addi.n	a3, a15, 15
400805fc:	0768      	l32i.n	a6, a7, 0
400805fe:	3ffb      	addi.n	a3, a15, 15
40080600:	053c      	movi.n	a5, 48
40080602:	3ffb      	addi.n	a3, a15, 15
40080604:	fb00c0        	f64addc	a12, a0, 0, 0
40080607:	3f          	.byte 0x3f
40080608:	0c8c      	beqz.n	a12, 4008060c <_iram_text_start+0xbc>
4008060a:	4008      	l32i.n	a0, a0, 16
4008060c:	ff          	.byte 0xff
4008060d:	7f          	.byte 0x7f
4008060e:	ff0000        	f64cmph	a0, a0, a0, 15
40080611:	ff          	.byte 0xff
40080612:	000003        	lsi	f0, a0, 0
40080615:	400092        	l8ui	a9, a0, 64
40080618:	054d      	mov.n	a4, a5
4008061a:	3ffb      	addi.n	a3, a15, 15
4008061c:	fb0a70        	f64addc	a7, a10, 0, 0
4008061f:	3f          	.byte 0x3f
40080620:	081260        	lsx	f1, a2, a6
40080623:	017840        	slli	a7, a8, 28
40080626:	3ffb      	addi.n	a3, a15, 15
40080628:	f48070        	extui	a8, a7, 0, 16
4008062b:	3f          	.byte 0x3f
4008062c:	fb0170        	f64addc	a7, a1, 0, 0
4008062f:	3f          	.byte 0x3f
40080630:	c4b400        	extui	a11, a0, 4, 13
40080633:	600004        	lsi	f0, a0, 0x180
40080636:	043ff6        	bgeui	a15, 3, 4008063e <_iram_text_start+0xee>
40080639:	3ff660        	f64cmph	a15, a6, a6, 3
4008063c:	ff          	.byte 0xff
4008063d:	ff          	.byte 0xff
4008063e:	ff          	.byte 0xff
4008063f:	8000e7        	bnone	a0, a14, 400805c3 <_iram_text_start+0x73>
40080642:	bf3ff4        	lsi	f15, a15, 0x2fc
40080645:	fbfa      	add.n	a15, a11, a15
40080647:	ff          	.byte 0xff
40080648:	807c      	movi.n	a0, -8
4008064a:	ff3ff4        	lsi	f15, a15, 0x3fc
4008064d:	ffffc7        	bbsi	a15, 28, 40080650 <_iram_text_start+0x100>
40080650:	002000        	isync
40080653:	055800        	extui	a5, a0, 24, 1
40080656:	3ffb      	addi.n	a3, a15, 15
40080658:	003c      	movi.n	a0, 48
4008065a:	003ff0        	lsi	f15, a15, 0
4008065d:	080000        	lsx	f0, a0, a0
40080660:	6008      	l32i.n	a0, a0, 24
40080662:	783ff6        	bgeui	a15, 3, 400806de <_iram_text_start+0x18e>
40080665:	400092        	l8ui	a9, a0, 64
40080668:	0041a4        	lsi	f10, a1, 0
4008066b:	058340        	extui	a8, a4, 19, 1
4008066e:	3ffb      	addi.n	a3, a15, 15
40080670:	f49000        	extui	a9, a0, 0, 16
40080673:	3f          	.byte 0x3f
40080674:	000800        	lsi	f0, a8, 0
40080677:	700000        	lsi	f0, a0, 0x1c0
4008067a:	760000        	lsi	f0, a0, 0x1d8
4008067d:	3ffb05        	call0	400c0630 <_iram_text_end+0x3c6f6>
40080680:	f44000        	extui	a4, a0, 0, 16
40080683:	3f          	.byte 0x3f
40080684:	fb0a74        	lsi	f7, a10, 0x3ec
40080687:	3f          	.byte 0x3f
40080688:	7619f1        	l32r	a15, 4005deec <esp32_rom_gpio_matrix_out+0x53fe0>
4008068b:	5dc005        	call0	400de28c <_iram_text_end+0x5a352>
4008068e:	000000        	ill
40080691:	000080        	ret
40080694:	bb0b      	addi.n	a11, a11, -1
40080696:	bf0002        	l8ui	a0, a0, 191
40080699:	005d      	mov.n	a5, a0
4008069b:	188b00        	lsxp	f8, a11, a0
4008069e:	4008      	l32i.n	a0, a0, 16
400806a0:	081000        	lsx	f1, a0, a0
400806a3:	002040        	lsi	f4, a0, 0
400806a6:	000005        	call0	400806a8 <_iram_text_start+0x158>
400806a9:	000800        	lsi	f0, a8, 0
400806ac:	100000        	and	a0, a0, a0
400806af:	000000        	ill
400806b2:	500020        	lsi	f2, a0, 0x140
400806b5:	400804        	lsi	f0, a8, 0x100
400806b8:	400000        	ssr	a0
400806bb:	000000        	ill
400806be:	000080        	ret
400806c1:	200000        	or	a0, a0, a0
400806c4:	408800        	lsi	f0, a8, 0x100
400806c7:	000000        	ill
400806ca:	000100        	lsi	f0, a1, 0
400806cd:	020000        	andb	b0, b0, b0
400806d0:	000000        	ill
400806d3:	000010        	lsi	f1, a0, 0
400806d6:	004000        	break	0, 0
400806d9:	030000        	rsr.lbeg	a0
400806dc:	010000        	slli	a0, a0, 32
400806df:	000000        	ill
400806e2:	000400        	lsi	f0, a4, 0
400806e5:	800000        	add	a0, a0, a0
400806e8:	004000        	break	0, 0
400806eb:	100000        	and	a0, a0, a0
400806ee:	000000        	ill
400806f1:	000200        	lsi	f0, a2, 0
400806f4:	040000        	extui	a0, a0, 0, 1
400806f7:	300000        	xor	a0, a0, a0
400806fa:	d40000        	extui	a0, a0, 0, 14
400806fd:	3ffb00        	f64cmph	a15, a11, a0, 3
40080700:	060000        	lsi	f0, a0, 24
40080703:	102200        	and	a2, a2, a0
40080706:	0ffd      	mov.n	a15, a15
40080708:	7f          	.byte 0x7f
40080709:	fc1c      	movi.n	a12, 31
4008070b:	ff          	.byte 0xff
4008070c:	fb0050        	f64addc	a5, a0, 0, 0
4008070f:	3f          	.byte 0x3f
40080710:	fb0040        	f64addc	a4, a0, 0, 0
40080713:	3f          	.byte 0x3f
40080714:	057c      	movi.n	a5, -16
40080716:	3ffb      	addi.n	a3, a15, 15
40080718:	0c7c      	movi.n	a12, -16
4008071a:	3ffb      	addi.n	a3, a15, 15
4008071c:	681c      	movi.n	a8, 22
4008071e:	2c4000        	lsi	f0, a0, 176
40080721:	3ff530        	f64cmph	a15, a5, a3, 3
40080724:	f53024        	lsi	f2, a0, 0x3d4
40080727:	3f          	.byte 0x3f
40080728:	3018      	l32i.n	a1, a0, 12
4008072a:	ff3ff5        	call12	4007fb28 <esp32_rom_gpio_matrix_out+0x75c1c>
4008072d:	cf          	.byte 0xcf
4008072e:	ff          	.byte 0xff
4008072f:	ff          	.byte 0xff
40080730:	301c      	movi.n	a0, 19
40080732:	b56001        	l32r	a0, 4006dcb4 <esp32_rom_gpio_matrix_out+0x63da8>
40080735:	3ffb05        	call0	400c06e8 <_iram_text_end+0x3c7ae>
40080738:	fb02e7        	bnone	a2, a14, 40080737 <_iram_text_start+0x1e7>
4008073b:	3f          	.byte 0x3f
4008073c:	000a16        	beqz	a10, 40080740 <_iram_text_start+0x1f0>
4008073f:	9f0c00        	f64cmph	a0, a12, a0, 9
40080742:	dc4000        	lsi	f0, a0, 0x370
40080745:	9e          	.byte 0x9e
40080746:	104000        	and	a4, a0, a0
40080749:	3ff530        	f64cmph	a15, a5, a3, 3
4008074c:	f53004        	lsi	f0, a0, 0x3d4
4008074f:	3f          	.byte 0x3f
40080750:	ff          	.byte 0xff
40080751:	fffff7        	bbsi	a15, 31, 40080754 <_iram_text_start+0x204>
40080754:	fb01b4        	lsi	f11, a1, 0x3ec
40080757:	3f          	.byte 0x3f
40080758:	f53000        	extui	a3, a0, 16, 16
4008075b:	3f          	.byte 0x3f
4008075c:	3038      	l32i.n	a3, a0, 12
4008075e:	403ff5        	call12	400c0b5c <_iram_text_end+0x3cc22>
40080761:	3ff530        	f64cmph	a15, a5, a3, 3
40080764:	f53044        	lsi	f4, a0, 0x3d4
40080767:	3f          	.byte 0x3f
40080768:	3048      	l32i.n	a4, a0, 12
4008076a:	4c3ff5        	call12	400ccb68 <_iram_text_end+0x48c2e>
4008076d:	3ff530        	f64cmph	a15, a5, a3, 3
40080770:	f53030        	extui	a3, a3, 16, 16
40080773:	3f          	.byte 0x3f
40080774:	f53034        	lsi	f3, a0, 0x3d4
40080777:	3f          	.byte 0x3f
40080778:	300c      	movi.n	a0, 3
4008077a:	403ff5        	call12	400c0b78 <_iram_text_end+0x3cc3e>
4008077d:	030d      	mov.n	a0, a3
4008077f:	302800        	xor	a2, a8, a0
40080782:	e83ff5        	call12	40068b80 <esp32_rom_gpio_matrix_out+0x5ec74>
40080785:	000003        	lsi	f0, a0, 0
40080788:	f53020        	extui	a3, a2, 16, 16
4008078b:	3f          	.byte 0x3f
4008078c:	0f4240        	f64cmph	a4, a2, a4, 0
4008078f:	86a000        	lsi	f0, a0, 0x218
40080792:	800001        	l32r	a0, 40060794 <esp32_rom_gpio_matrix_out+0x56888>
40080795:	061a      	add.n	a0, a6, a1
40080797:	e14000        	lsi	f0, a0, 0x384
4008079a:	400033        	lsi	f3, a0, 0x100
4008079d:	4c4b      	addi.n	a4, a12, 4
4008079f:	300800        	xor	a0, a8, a0
400807a2:	583ff5        	call12	400d8ba0 <_iram_text_end+0x54c66>
400807a5:	3ff530        	f64cmph	a15, a5, a3, 3
400807a8:	001800        	movsp	a0, a8
400807ab:	140100        	extui	a0, a0, 1, 2
400807ae:	010000        	slli	a0, a0, 32
400807b1:	080000        	lsx	f0, a0, a0
400807b4:	800101        	l32r	a0, 400607b8 <esp32_rom_gpio_matrix_out+0x568ac>
400807b7:	02a400        	andb	b10, b4, b0
400807ba:	3ffb      	addi.n	a3, a15, 15
400807bc:	fb0000        	f64addc	a0, a0, 0, 0
400807bf:	3f          	.byte 0x3f
400807c0:	fb0080        	f64addc	a8, a0, 0, 0
400807c3:	3f          	.byte 0x3f
400807c4:	0c7d      	mov.n	a7, a12
400807c6:	3ffb      	addi.n	a3, a15, 15
400807c8:	04cd      	mov.n	a12, a4
400807ca:	3ffb      	addi.n	a3, a15, 15
400807cc:	05bc      	beqz.n	a5, 40080800 <_iram_text_start+0x2b0>
400807ce:	3ffb      	addi.n	a3, a15, 15
400807d0:	05d8      	l32i.n	a13, a5, 0
400807d2:	3ffb      	addi.n	a3, a15, 15
400807d4:	09a8      	l32i.n	a10, a9, 0
400807d6:	3ffb      	addi.n	a3, a15, 15
400807d8:	2808      	l32i.n	a0, a8, 8
400807da:	4008      	l32i.n	a0, a0, 16
400807dc:	fb2080        	f64addc	a8, a0, 1, 0
400807df:	3f          	.byte 0x3f
400807e0:	ff          	.byte 0xff
400807e1:	3ffb05        	call0	400c0794 <_iram_text_end+0x3c85a>
400807e4:	36dc      	bnez.n	a6, 400807fb <_iram_text_start+0x2ab>
400807e6:	4008      	l32i.n	a0, a0, 16
400807e8:	fb1880        	f64addc	a8, a8, 0, 1
400807eb:	3f          	.byte 0x3f
400807ec:	0828      	l32i.n	a2, a8, 0
400807ee:	3ffb      	addi.n	a3, a15, 15
400807f0:	fb3080        	f64addc	a8, a0, 1, 1
400807f3:	3f          	.byte 0x3f
400807f4:	fb1c80        	f64addc	a8, a12, 0, 1
400807f7:	3f          	.byte 0x3f
400807f8:	08e8      	l32i.n	a14, a8, 0
400807fa:	3ffb      	addi.n	a3, a15, 15
400807fc:	fb3880        	f64addc	a8, a8, 1, 1
400807ff:	3f          	.byte 0x3f
40080800:	0b08      	l32i.n	a0, a11, 0
40080802:	3ffb      	addi.n	a3, a15, 15
40080804:	7e          	.byte 0x7e
40080805:	fb0c      	movi.n	a11, 15
40080807:	3f          	.byte 0x3f
40080808:	fb0ad4        	lsi	f13, a10, 0x3ec
4008080b:	3f          	.byte 0x3f
4008080c:	fb0ad0        	f64addc	a13, a10, 0, 0
4008080f:	3f          	.byte 0x3f
40080810:	fb0b14        	lsi	f1, a11, 0x3ec
40080813:	3f          	.byte 0x3f
40080814:	7e          	.byte 0x7e
40080815:	fb0c      	movi.n	a11, 15
40080817:	3f          	.byte 0x3f
40080818:	082cb4        	lsi	f11, a12, 32
4008081b:	000a40        	lsi	f4, a10, 0
4008081e:	7e0000        	f64rnd	a0, a0, a0, 3
40080821:	fb0c      	movi.n	a11, 15
40080823:	3f          	.byte 0x3f
40080824:	fb0084        	lsi	f8, a0, 0x3ec
40080827:	3f          	.byte 0x3f
40080828:	0b1c      	movi.n	a11, 16
4008082a:	3ffb      	addi.n	a3, a15, 15
4008082c:	fb0144        	lsi	f4, a1, 0x3ec
4008082f:	3f          	.byte 0x3f
40080830:	ff          	.byte 0xff
40080831:	ff          	.byte 0xff
40080832:	ff          	.byte 0xff
40080833:	7f          	.byte 0x7f
40080834:	0a68      	l32i.n	a6, a10, 0
40080836:	3ffb      	addi.n	a3, a15, 15
40080838:	fb0084        	lsi	f8, a0, 0x3ec
4008083b:	3f          	.byte 0x3f
4008083c:	0098      	l32i.n	a9, a0, 0
4008083e:	3ffb      	addi.n	a3, a15, 15

40080840 <__start>:
 * This is written in C rather than assembly since, during the port bring up,
 * Zephyr is being booted by the Espressif bootloader.  With it, the C stack
 * is already set up.
 */
void __attribute__((section(".iram1"))) __start(void)
{
40080840:	004136        	entry	a1, 32
	extern uint32_t _init_start;
	extern uint32_t _bss_start;
	extern uint32_t _bss_end;

	/* Move the exception vector table to IRAM. */
	__asm__ __volatile__ (
40080843:	ff4381        	l32r	a8, 40080550 <_iram_text_start>
40080846:	13e780        	wsr.vecbase	a8
		:
		: "r"(&_init_start));

	/* Zero out BSS.  Clobber _bss_start to avoid memset() elision. */
	(void)memset(&_bss_start, 0,
		     (&_bss_end - &_bss_start) * sizeof(_bss_start));
40080849:	ff43a1        	l32r	a10, 40080558 <_iram_text_start+0x8>
	(void)memset(&_bss_start, 0,
4008084c:	ff42c1        	l32r	a12, 40080554 <_iram_text_start+0x4>
4008084f:	00a0b2        	movi	a11, 0
40080852:	c0cca0        	sub	a12, a12, a10
40080855:	02f525        	call8	400837a8 <memset>
		: "memory");

	/* The watchdog timer is enabled in the bootloader.  We're done booting,
	 * so disable it.
	 */
	*wdt_rtc_reg &= ~RTC_CNTL_WDT_FLASHBOOT_MOD_EN;
40080858:	ff4191        	l32r	a9, 4008055c <_iram_text_start+0xc>
4008085b:	ffaba2        	movi	a10, 0xfffffbff
4008085e:	0020c0        	memw
40080861:	002982        	l32i	a8, a9, 0
40080864:	1088a0        	and	a8, a8, a10
40080867:	0020c0        	memw
4008086a:	0989      	s32i.n	a8, a9, 0
	*wdt_timg_reg &= ~TIMG_WDT_FLASHBOOT_MOD_EN;
4008086c:	ff3d91        	l32r	a9, 40080560 <_iram_text_start+0x10>
4008086f:	ff3da1        	l32r	a10, 40080564 <_iram_text_start+0x14>
40080872:	0020c0        	memw
40080875:	0988      	l32i.n	a8, a9, 0
40080877:	1088a0        	and	a8, a8, a10
4008087a:	0020c0        	memw
4008087d:	0989      	s32i.n	a8, a9, 0

	/* Disable normal interrupts. */
	__asm__ __volatile__ (
4008087f:	ff3a81        	l32r	a8, 40080568 <_iram_text_start+0x18>
40080882:	13e680        	wsr.ps	a8
		"wsr %0, PS"
		:
		: "r"(PS_INTLEVEL(XCHAL_EXCM_LEVEL) | PS_UM | PS_WOE));

	/* Disable CPU1 while we figure out how to have SMP in Zephyr. */
	*app_cpu_config_reg &= ~DPORT_APPCPU_CLKGATE_EN;
40080885:	ff3991        	l32r	a9, 4008056c <_iram_text_start+0x1c>
40080888:	ea7c      	movi.n	a10, -2
4008088a:	0020c0        	memw
4008088d:	0988      	l32i.n	a8, a9, 0
4008088f:	1088a0        	and	a8, a8, a10
40080892:	0020c0        	memw
40080895:	006982        	s32i	a8, a9, 0

	/* Initialize the architecture CPU pointer.  Some of the
	 * initialization code wants a valid _current before
	 * arch_kernel_init() is invoked.
	 */
	__asm__ volatile("wsr.MISC0 %0; rsync" : : "r"(&_kernel.cpus[0]));
40080898:	ff3681        	l32r	a8, 40080570 <_iram_text_start+0x20>
4008089b:	13f480        	wsr.misc0	a8
4008089e:	002010        	rsync


	/* Start Zephyr */
	z_cstart();
400808a1:	01f9e5        	call8	40082840 <z_cstart>

400808a4 <_Level1Vector>:
DEF_EXCINT 1, _handle_excint, xtensa_excint1_c
400808a4:	c4c112        	addi	a1, a1, -60
400808a7:	7109      	s32i.n	a0, a1, 28
400808a9:	9129      	s32i.n	a2, a1, 36
400808ab:	a139      	s32i.n	a3, a1, 40
400808ad:	03e600        	rsr.ps	a0
400808b0:	026c      	movi.n	a2, -32
400808b2:	100020        	and	a0, a0, a2
400808b5:	5109      	s32i.n	a0, a1, 20
400808b7:	03b100        	rsr.epc1	a0
400808ba:	6109      	s32i.n	a0, a1, 24
400808bc:	000206        	j	400808c8 <_after_imms1>
	...

400808c0 <_handle_excint_imm1>:
400808c0:	081890        	lsx	f1, a8, a9
400808c3:	40          	.byte 0x40

400808c4 <_c_handler_imm1>:
400808c4:	081ba4        	lsi	f10, a11, 32
400808c7:	40          	.byte 0x40

400808c8 <_after_imms1>:
400808c8:	ffff21        	l32r	a2, 400808c4 <_c_handler_imm1>
400808cb:	fffd01        	l32r	a0, 400808c0 <_handle_excint_imm1>
400808ce:	0000a0        	jx	a0
400808d1:	000000        	ill

400808d4 <k_msleep$constprop$9>:
 * @param ms Number of milliseconds to sleep.
 *
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
400808d4:	004136        	entry	a1, 32
		parm0.val = timeout;
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
400808d7:	ff28b1        	l32r	a11, 40080578 <_iram_text_start+0x28>
400808da:	ff26a1        	l32r	a10, 40080574 <_iram_text_start+0x24>
400808dd:	028a65        	call8	40083184 <z_impl_k_sleep>
{
	return k_sleep(Z_TIMEOUT_MS(ms));
}
400808e0:	0a2d      	mov.n	a2, a10
400808e2:	f01d      	retw.n

400808e4 <blink1>:
const float LM75A_DEGREES_RESOLUTION = 0.125;
const int LM75A_REG_ADDR_TEMP = 0;


void blink1(void *id, void *unused1, void *unused2)
{
400808e4:	004136        	entry	a1, 32
	
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);

	int my_id = POINTER_TO_INT(id);
	printk("Beginning execution; thread data is %d\n", my_id);
400808e7:	ff27a1        	l32r	a10, 40080584 <_iram_text_start+0x34>
400808ea:	20b220        	or	a11, a2, a2
400808ed:	006ee5        	call8	40080fdc <printk>
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
400808f0:	ff26a1        	l32r	a10, 40080588 <_iram_text_start+0x38>
400808f3:	01e9a5        	call8	4008278c <z_impl_device_get_binding>
400808f6:	202aa0        	or	a2, a10, a10
	const struct device *dev;
	bool led_on = true;
	int ret;
	
	dev = device_get_binding("GPIO_0");
	if(dev == NULL){
400808f9:	083a16        	beqz	a10, 40080980 <blink1+0x9c>
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
400808fc:	3a48      	l32i.n	a4, a10, 12
	return api->pin_configure(port, pin, flags);
400808fe:	2a38      	l32i.n	a3, a10, 8
40080900:	ff23c1        	l32r	a12, 4008058c <_iram_text_start+0x3c>
40080903:	0338      	l32i.n	a3, a3, 0
40080905:	2b0c      	movi.n	a11, 2
40080907:	0003e0        	callx8	a3
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
4008090a:	eacc      	bnez.n	a10, 4008091c <blink1+0x38>
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
4008090c:	0438      	l32i.n	a3, a4, 0
4008090e:	b57c      	movi.n	a5, -5
40080910:	103350        	and	a3, a3, a5
40080913:	0439      	s32i.n	a3, a4, 0
{
40080915:	130c      	movi.n	a3, 1
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
		value = (value != 0) ? 0 : 1;
40080917:	035d      	mov.n	a5, a3
40080919:	0001c6        	j	40080924 <blink1+0x40>
		return;
	}
	
	ret= gpio_pin_configure(dev, LED_PIN, GPIO_OUTPUT_ACTIVE);
	if(ret<0){
4008091c:	060a96        	bltz	a10, 40080980 <blink1+0x9c>
4008091f:	fffc86        	j	40080915 <blink1+0x31>
40080922:	410000        	srli	a0, a0, 0
		parm0.val = timeout;
		return (int) arch_syscall_invoke3(*(uintptr_t *)&mutex, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
40080925:	ff1c      	movi.n	a15, 31
40080927:	ff1ac1        	l32r	a12, 40080590 <_iram_text_start+0x40>
4008092a:	ff19d1        	l32r	a13, 40080590 <_iram_text_start+0x40>
4008092d:	20a440        	or	a10, a4, a4
40080930:	01ffa5        	call8	4008292c <z_impl_k_mutex_lock>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
40080933:	032282        	l32i	a8, a2, 12
40080936:	002892        	l32i	a9, a8, 0
40080939:	038d      	mov.n	a8, a3
4008093b:	056927        	bbci	a9, 2, 40080944 <blink1+0x60>
		value = (value != 0) ? 0 : 1;
4008093e:	308350        	xor	a8, a3, a5
40080941:	748080        	extui	a8, a8, 0, 8
	if (value != 0)	{
40080944:	588c      	beqz.n	a8, 4008094d <blink1+0x69>
	return api->port_set_bits_raw(port, pins);
40080946:	2288      	l32i.n	a8, a2, 8
40080948:	3888      	l32i.n	a8, a8, 12
4008094a:	000146        	j	40080953 <blink1+0x6f>
	return api->port_clear_bits_raw(port, pins);
4008094d:	022282        	l32i	a8, a2, 8
40080950:	042882        	l32i	a8, a8, 16
40080953:	04a0b2        	movi	a11, 4
40080956:	02ad      	mov.n	a10, a2
40080958:	0008e0        	callx8	a8
	}
	
	while (1){
	    k_mutex_lock(&cliblock, K_FOREVER);
		gpio_pin_set(dev, LED_PIN,  (int)led_on);
		printk("LED1 on\n");
4008095b:	ff0fa1        	l32r	a10, 40080598 <_iram_text_start+0x48>
4008095e:	0067e5        	call8	40080fdc <printk>
		printk("LED2 %s\n", (led_on ? "on" : "off"));
40080961:	ff06b1        	l32r	a11, 4008057c <_iram_text_start+0x2c>
40080964:	13cc      	bnez.n	a3, 40080969 <blink1+0x85>
40080966:	ff06b1        	l32r	a11, 40080580 <_iram_text_start+0x30>
40080969:	ff0ca1        	l32r	a10, 4008059c <_iram_text_start+0x4c>
		led_on = !led_on;
4008096c:	303350        	xor	a3, a3, a5
		printk("LED2 %s\n", (led_on ? "on" : "off"));
4008096f:	0066e5        	call8	40080fdc <printk>
		led_on = !led_on;
40080972:	743030        	extui	a3, a3, 0, 8
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
40080975:	04ad      	mov.n	a10, a4
40080977:	0207e5        	call8	400829f4 <z_impl_k_mutex_unlock>
4008097a:	ffe986        	j	40080924 <blink1+0x40>
4008097d:	000000        	ill

		//k_msleep(SLEEP_TIME);
		k_mutex_unlock(&cliblock);
	}

}
40080980:	f01d      	retw.n
	...

40080984 <temperatura>:

void temperatura(void *id, void *unused1, void *unused2)
{
40080984:	008136        	entry	a1, 64
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);

	int my_id = POINTER_TO_INT(id);
	printk("Beginning execution; thread data is %d\n", my_id);
40080987:	feffa1        	l32r	a10, 40080584 <_iram_text_start+0x34>
4008098a:	02bd      	mov.n	a11, a2
	//uint8_t cmp_data[16];
	uint8_t data[16];
	//int i, 
	int ret;
	uint16_t temp = 0x00;
    uint8_t pointer = 0x00;
4008098c:	00a042        	movi	a4, 0
	printk("Beginning execution; thread data is %d\n", my_id);
4008098f:	0064e5        	call8	40080fdc <printk>
    uint8_t pointer = 0x00;
40080992:	104142        	s8i	a4, a1, 16
40080995:	ff02a1        	l32r	a10, 400805a0 <_iram_text_start+0x50>
40080998:	01df25        	call8	4008278c <z_impl_device_get_binding>
4008099b:	0a2d      	mov.n	a2, a10
4008099d:	ff01a1        	l32r	a10, 400805a4 <_iram_text_start+0x54>
400809a0:	01dea5        	call8	4008278c <z_impl_device_get_binding>
400809a3:	0a6d      	mov.n	a6, a10

	i2c_dev = device_get_binding(I2C_DEV);
	i2c_dev1 = device_get_binding(I2C_DEV1);
	if (!i2c_dev1) {
400809a5:	7acc      	bnez.n	a10, 400809b0 <temperatura+0x2c>
		printk("I2C: Device driver not found.\n");
400809a7:	ff00a1        	l32r	a10, 400805a8 <_iram_text_start+0x58>
400809aa:	006325        	call8	40080fdc <printk>
        k_mutex_unlock(&cliblock);
    }
    	
	

}
400809ad:	f01d      	retw.n
400809af:	ffa100        	f64cmph	a10, a1, a0, 15
	printk("----------->> -------------------- <<---------------\n");
400809b2:	fe          	.byte 0xfe
400809b3:	0062a5        	call8	40080fdc <printk>
    printk("---------->>   *** I2C LM75A ***   <<--------------\n\n");
400809b6:	fefea1        	l32r	a10, 400805b0 <_iram_text_start+0x60>
400809b9:	006225        	call8	40080fdc <printk>
	printk("I2C LM75A - Pruebas.\n");
400809bc:	fefea1        	l32r	a10, 400805b4 <_iram_text_start+0x64>
400809bf:	0061e5        	call8	40080fdc <printk>
	return z_impl_k_mutex_lock(mutex, timeout);
400809c2:	fef431        	l32r	a3, 40080594 <_iram_text_start+0x44>
400809c5:	fef2c1        	l32r	a12, 40080590 <_iram_text_start+0x40>
400809c8:	fef2d1        	l32r	a13, 40080590 <_iram_text_start+0x40>
400809cb:	03ad      	mov.n	a10, a3
400809cd:	01f5e5        	call8	4008292c <z_impl_k_mutex_lock>
	pointer = 0x03; //Tos register pointer - 5000h por defecto
400809d0:	350c      	movi.n	a5, 3
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
400809d2:	8d4c      	movi.n	a13, 72
400809d4:	1c0c      	movi.n	a12, 1
400809d6:	10c1b2        	addi	a11, a1, 16
400809d9:	02ad      	mov.n	a10, a2
	pointer = 0x03; //Tos register pointer - 5000h por defecto
400809db:	104152        	s8i	a5, a1, 16
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
400809de:	02d765        	call8	40083754 <i2c_write>
	k_msleep(5);
400809e1:	ffef25        	call8	400808d4 <k_msleep$constprop$9>
	ret = i2c_read(i2c_dev, &data[0], 2, LM75A_DEFAULT_ADDRESS);
400809e4:	8d4c      	movi.n	a13, 72
400809e6:	2c0c      	movi.n	a12, 2
400809e8:	01bd      	mov.n	a11, a1
400809ea:	02ad      	mov.n	a10, a2
400809ec:	02d465        	call8	40083734 <i2c_read>
	k_msleep(5);
400809ef:	ffee65        	call8	400808d4 <k_msleep$constprop$9>
	printk("----->> SetPoint - Tos Register: %x|%x\n\n", data[0], data[1]);
400809f2:	fef171        	l32r	a7, 400805b8 <_iram_text_start+0x68>
400809f5:	0101c2        	l8ui	a12, a1, 1
400809f8:	0001b2        	l8ui	a11, a1, 0
400809fb:	07ad      	mov.n	a10, a7
400809fd:	005de5        	call8	40080fdc <printk>
	pointer = 0x02; //Thyst register pointer - 4B00h por defecto
40080a00:	290c      	movi.n	a9, 2
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080a02:	8d4c      	movi.n	a13, 72
40080a04:	1c0c      	movi.n	a12, 1
40080a06:	10c1b2        	addi	a11, a1, 16
40080a09:	02ad      	mov.n	a10, a2
	pointer = 0x02; //Thyst register pointer - 4B00h por defecto
40080a0b:	104192        	s8i	a9, a1, 16
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080a0e:	02d465        	call8	40083754 <i2c_write>
	k_msleep(5);
40080a11:	ffec25        	call8	400808d4 <k_msleep$constprop$9>
	ret = i2c_read(i2c_dev, &data[0], 2, LM75A_DEFAULT_ADDRESS);
40080a14:	8d4c      	movi.n	a13, 72
40080a16:	2c0c      	movi.n	a12, 2
40080a18:	01bd      	mov.n	a11, a1
40080a1a:	02ad      	mov.n	a10, a2
40080a1c:	02d165        	call8	40083734 <i2c_read>
	k_msleep(5);
40080a1f:	ffeb65        	call8	400808d4 <k_msleep$constprop$9>
	printk("----->> Hysteresis - Thyst Register: %x|%x\n\n", data[0], data[1]);
40080a22:	0101c2        	l8ui	a12, a1, 1
40080a25:	0001b2        	l8ui	a11, a1, 0
40080a28:	fee5a1        	l32r	a10, 400805bc <_iram_text_start+0x6c>
40080a2b:	005b25        	call8	40080fdc <printk>
	pointer = 0x01; //Configuration register pointer - 00h por defecto
40080a2e:	190c      	movi.n	a9, 1
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080a30:	8d4c      	movi.n	a13, 72
40080a32:	1c0c      	movi.n	a12, 1
40080a34:	10c1b2        	addi	a11, a1, 16
40080a37:	02ad      	mov.n	a10, a2
	pointer = 0x01; //Configuration register pointer - 00h por defecto
40080a39:	104192        	s8i	a9, a1, 16
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080a3c:	02d165        	call8	40083754 <i2c_write>
	k_msleep(5);
40080a3f:	ffe965        	call8	400808d4 <k_msleep$constprop$9>
	ret = i2c_read(i2c_dev, &data[0], 1, LM75A_DEFAULT_ADDRESS);
40080a42:	8d4c      	movi.n	a13, 72
40080a44:	1c0c      	movi.n	a12, 1
40080a46:	01bd      	mov.n	a11, a1
40080a48:	02ad      	mov.n	a10, a2
40080a4a:	02cea5        	call8	40083734 <i2c_read>
	k_msleep(5);
40080a4d:	ffe865        	call8	400808d4 <k_msleep$constprop$9>
	printk("----->>  Configuration - Register %x|%x\n\n", data[0], data[1]);
40080a50:	0101c2        	l8ui	a12, a1, 1
40080a53:	0001b2        	l8ui	a11, a1, 0
40080a56:	fedaa1        	l32r	a10, 400805c0 <_iram_text_start+0x70>
40080a59:	005825        	call8	40080fdc <printk>
	printk("----->>  Writing - Tos Register %x|%x\n", data[0], data[1]);
40080a5c:	0101c2        	l8ui	a12, a1, 1
40080a5f:	0001b2        	l8ui	a11, a1, 0
40080a62:	fed8a1        	l32r	a10, 400805c4 <_iram_text_start+0x74>
40080a65:	005765        	call8	40080fdc <printk>
	i2c_write(i2c_dev, &data[0], 3, LM75A_DEFAULT_ADDRESS);
40080a68:	8d4c      	movi.n	a13, 72
40080a6a:	3c0c      	movi.n	a12, 3
40080a6c:	01bd      	mov.n	a11, a1
40080a6e:	02ad      	mov.n	a10, a2
	data[1] = temp >> 8;//MSByte
40080a70:	014142        	s8i	a4, a1, 1
	data[2] = (uint16_t)temp & 0x0F;//LSByte
40080a73:	024142        	s8i	a4, a1, 2
	pointer = 0x03;
40080a76:	104152        	s8i	a5, a1, 16
	data[0] = pointer;
40080a79:	004152        	s8i	a5, a1, 0
	i2c_write(i2c_dev, &data[0], 3, LM75A_DEFAULT_ADDRESS);
40080a7c:	02cd65        	call8	40083754 <i2c_write>
	printk("----->>  Tos Register wrote temp: <%x>, MSByte <%x>, LSByte <%x>\n\n", temp, data[1], data[2]);
40080a7f:	0201d2        	l8ui	a13, a1, 2
40080a82:	0101c2        	l8ui	a12, a1, 1
40080a85:	fed0a1        	l32r	a10, 400805c8 <_iram_text_start+0x78>
40080a88:	0b3c      	movi.n	a11, 48
40080a8a:	005525        	call8	40080fdc <printk>
	k_msleep(5);
40080a8d:	ffe465        	call8	400808d4 <k_msleep$constprop$9>
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080a90:	8d4c      	movi.n	a13, 72
40080a92:	1c0c      	movi.n	a12, 1
40080a94:	10c1b2        	addi	a11, a1, 16
40080a97:	02ad      	mov.n	a10, a2
	pointer = 0x03; //Tos register pointer - 5000h por defecto
40080a99:	104152        	s8i	a5, a1, 16
	i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080a9c:	02cb65        	call8	40083754 <i2c_write>
	k_msleep(5);
40080a9f:	ffe365        	call8	400808d4 <k_msleep$constprop$9>
	ret = i2c_read(i2c_dev, &data[0], 2, LM75A_DEFAULT_ADDRESS);
40080aa2:	8d4c      	movi.n	a13, 72
40080aa4:	2c0c      	movi.n	a12, 2
40080aa6:	01bd      	mov.n	a11, a1
40080aa8:	02ad      	mov.n	a10, a2
40080aaa:	02c8a5        	call8	40083734 <i2c_read>
	k_msleep(5);
40080aad:	ffe265        	call8	400808d4 <k_msleep$constprop$9>
	printk("----->> SetPoint - Tos Register: %x|%x\n\n", data[0], data[1]);
40080ab0:	0101c2        	l8ui	a12, a1, 1
40080ab3:	0001b2        	l8ui	a11, a1, 0
40080ab6:	07ad      	mov.n	a10, a7
40080ab8:	005225        	call8	40080fdc <printk>
    i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080abb:	8d4c      	movi.n	a13, 72
40080abd:	1c0c      	movi.n	a12, 1
40080abf:	10c1b2        	addi	a11, a1, 16
40080ac2:	20a220        	or	a10, a2, a2
	pointer = 0x00; // Temp register pointer
40080ac5:	104142        	s8i	a4, a1, 16
    i2c_write(i2c_dev, &pointer, 1, LM75A_DEFAULT_ADDRESS);
40080ac8:	02c8a5        	call8	40083754 <i2c_write>
    printk("----------->> -------------------- <<---------------\n");
40080acb:	feb8a1        	l32r	a10, 400805ac <_iram_text_start+0x5c>
	pointer = 0xF7; //Tos register pointer - 5000h por defecto
40080ace:	747c      	movi.n	a4, -9
    printk("----------->> -------------------- <<---------------\n");
40080ad0:	0050a5        	call8	40080fdc <printk>
    printk("---------->>   *** I2C BMP280 ***   <<--------------\n\n");
40080ad3:	febea1        	l32r	a10, 400805cc <_iram_text_start+0x7c>
40080ad6:	005065        	call8	40080fdc <printk>
	i2c_write(i2c_dev1, &pointer, 1, BMP280_DEFAULT_ADDRESS);
40080ad9:	76a0d2        	movi	a13, 118
40080adc:	1c0c      	movi.n	a12, 1
40080ade:	10c1b2        	addi	a11, a1, 16
40080ae1:	06ad      	mov.n	a10, a6
	pointer = 0xF7; //Tos register pointer - 5000h por defecto
40080ae3:	104142        	s8i	a4, a1, 16
	i2c_write(i2c_dev1, &pointer, 1, BMP280_DEFAULT_ADDRESS);
40080ae6:	02c6e5        	call8	40083754 <i2c_write>
	k_msleep(5);
40080ae9:	ffdea5        	call8	400808d4 <k_msleep$constprop$9>
	ret = i2c_read(i2c_dev1, &data[0], 4, BMP280_DEFAULT_ADDRESS);
40080aec:	4c0c      	movi.n	a12, 4
40080aee:	01bd      	mov.n	a11, a1
40080af0:	76a0d2        	movi	a13, 118
40080af3:	06ad      	mov.n	a10, a6
40080af5:	02c3e5        	call8	40083734 <i2c_read>
	k_msleep(5);
40080af8:	ffdda5        	call8	400808d4 <k_msleep$constprop$9>
	printk("----->> presion %x temp %x\n\n", data[0], data[3]); // data[0] = 0xF7 reg info -  data[3] = 0xFA red info.
40080afb:	0301c2        	l8ui	a12, a1, 3
40080afe:	0001b2        	l8ui	a11, a1, 0
40080b01:	feb3a1        	l32r	a10, 400805d0 <_iram_text_start+0x80>
40080b04:	004d65        	call8	40080fdc <printk>
	return z_impl_k_mutex_unlock(mutex);
40080b07:	03ad      	mov.n	a10, a3
40080b09:	01eea5        	call8	400829f4 <z_impl_k_mutex_unlock>
	return z_impl_k_mutex_lock(mutex, timeout);
40080b0c:	fea1c1        	l32r	a12, 40080590 <_iram_text_start+0x40>
40080b0f:	fea0d1        	l32r	a13, 40080590 <_iram_text_start+0x40>
40080b12:	03ad      	mov.n	a10, a3
40080b14:	01e165        	call8	4008292c <z_impl_k_mutex_lock>
        ret = i2c_read(i2c_dev, &data[0], 2, LM75A_DEFAULT_ADDRESS);
40080b17:	8d4c      	movi.n	a13, 72
40080b19:	2c0c      	movi.n	a12, 2
40080b1b:	20b110        	or	a11, a1, a1
40080b1e:	20a220        	or	a10, a2, a2
40080b21:	02c125        	call8	40083734 <i2c_read>
        if(~ret) {
40080b24:	050a26        	beqi	a10, -1, 40080b2d <temperatura+0x1a9>
            printk("Succesful read\n");
40080b27:	feaba1        	l32r	a10, 400805d4 <_iram_text_start+0x84>
40080b2a:	000086        	j	40080b30 <temperatura+0x1ac>
            printk("Error read\n");
40080b2d:	feaaa1        	l32r	a10, 400805d8 <_iram_text_start+0x88>
40080b30:	004aa5        	call8	40080fdc <printk>
        printk("data[0]: %X data[1] %X \n", data[0], data[1]);
40080b33:	0001b2        	l8ui	a11, a1, 0
40080b36:	0101c2        	l8ui	a12, a1, 1
40080b39:	fea8a1        	l32r	a10, 400805dc <_iram_text_start+0x8c>
        temp = data[0] << 8 | (data[1] & 0x80 );
40080b3c:	80a052        	movi	a5, 128
        printk("data[0]: %X data[1] %X \n", data[0], data[1]);
40080b3f:	0049e5        	call8	40080fdc <printk>
        temp = data[0] << 8 | (data[1] & 0x80 );
40080b42:	000182        	l8ui	a8, a1, 0
        printk("Temperatura en Celsius: %d\n", temp); //float not supported by printk
40080b45:	fea7a1        	l32r	a10, 400805e4 <_iram_text_start+0x94>
        temp = data[0] << 8 | (data[1] & 0x80 );
40080b48:	114880        	slli	a4, a8, 8
40080b4b:	010182        	l8ui	a8, a1, 1
40080b4e:	108850        	and	a8, a8, a5
40080b51:	208840        	or	a8, a8, a4
        temp = temp * LM75A_DEGREES_RESOLUTION;
40080b54:	418580        	srli	a8, a8, 5
40080b57:	fea241        	l32r	a4, 400805e0 <_iram_text_start+0x90>
40080b5a:	ca0800        	float.s	f0, a8, 0
40080b5d:	fa1450        	wfr	f1, a4
40080b60:	2a0010        	mul.s	f0, f0, f1
40080b63:	eab000        	utrunc.s	a11, f0, 0
        printk("Temperatura en Celsius: %d\n", temp); //float not supported by printk
40080b66:	f4b0b0        	extui	a11, a11, 0, 16
40080b69:	004725        	call8	40080fdc <printk>
	compiler_barrier();
40080b6c:	ffe5c6        	j	40080b07 <temperatura+0x183>
	...

40080b70 <main>:
	k_object_access_grant(&cliblock, &threads[0]);
	k_object_access_grant(&cliblock, &threads[1]);
}

void main(void)
{
40080b70:	008136        	entry	a1, 64
	//display_demo_description();

	#if CONFIG_TIMESLICING
	k_sched_time_slice_set(1000, 0); //antes 5000
40080b73:	00a0b2        	movi	a11, 0
40080b76:	e8a3a2        	movi	a10, 0x3e8
40080b79:	01f725        	call8	40082aec <k_sched_time_slice_set>
	return z_impl_k_mutex_init(mutex);
40080b7c:	fe86a1        	l32r	a10, 40080594 <_iram_text_start+0x44>
40080b7f:	02e765        	call8	400839f4 <z_impl_k_mutex_init>
	k_thread_create(&threads[0], &stacks[0][0], STACK_SIZE,
40080b82:	fe8341        	l32r	a4, 40080590 <_iram_text_start+0x40>
40080b85:	fe8251        	l32r	a5, 40080590 <_iram_text_start+0x40>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40080b88:	fe9a31        	l32r	a3, 400805f0 <_iram_text_start+0xa0>
40080b8b:	00a022        	movi	a2, 0
40080b8e:	460c      	movi.n	a6, 4
40080b90:	fe96d1        	l32r	a13, 400805e8 <_iram_text_start+0x98>
40080b93:	fe96b1        	l32r	a11, 400805ec <_iram_text_start+0x9c>
40080b96:	4149      	s32i.n	a4, a1, 16
40080b98:	5159      	s32i.n	a5, a1, 20
40080b9a:	2169      	s32i.n	a6, a1, 8
40080b9c:	1129      	s32i.n	a2, a1, 4
40080b9e:	0129      	s32i.n	a2, a1, 0
40080ba0:	02fd      	mov.n	a15, a2
40080ba2:	02ed      	mov.n	a14, a2
40080ba4:	00a6c2        	movi	a12, 0x600
40080ba7:	20a330        	or	a10, a3, a3
40080baa:	027065        	call8	400832b0 <z_impl_k_thread_create>
	z_impl_k_thread_start(thread);
40080bad:	03ad      	mov.n	a10, a3
40080baf:	0269e5        	call8	4008324c <z_impl_k_thread_start>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40080bb2:	fe9231        	l32r	a3, 400805fc <_iram_text_start+0xac>
40080bb5:	fe8fd1        	l32r	a13, 400805f4 <_iram_text_start+0xa4>
40080bb8:	fe90b1        	l32r	a11, 400805f8 <_iram_text_start+0xa8>
40080bbb:	4149      	s32i.n	a4, a1, 16
40080bbd:	5159      	s32i.n	a5, a1, 20
40080bbf:	2169      	s32i.n	a6, a1, 8
40080bc1:	1129      	s32i.n	a2, a1, 4
40080bc3:	0129      	s32i.n	a2, a1, 0
40080bc5:	02fd      	mov.n	a15, a2
40080bc7:	1e0c      	movi.n	a14, 1
40080bc9:	00a6c2        	movi	a12, 0x600
40080bcc:	03ad      	mov.n	a10, a3
40080bce:	026e25        	call8	400832b0 <z_impl_k_thread_create>
	z_impl_k_thread_start(thread);
40080bd1:	03ad      	mov.n	a10, a3
40080bd3:	0267a5        	call8	4008324c <z_impl_k_thread_start>
	 * opportunity to dump some output before coverage data gets emitted
	 */
	k_sleep(K_MSEC(5000));
#endif

}
40080bd6:	f01d      	retw.n

40080bd8 <print_digits>:
}
#endif /* CONFIG_PRINTK */

static void print_digits(out_func_t out, void *ctx, printk_val_t num, int base,
			 bool pad_before, char pad_char, int min_width)
{
40080bd8:	00a136        	entry	a1, 80
40080bdb:	049d      	mov.n	a9, a4
40080bdd:	744070        	extui	a4, a7, 0, 8
40080be0:	058d      	mov.n	a8, a5
40080be2:	8149      	s32i.n	a4, a1, 32
40080be4:	500142        	l8ui	a4, a1, 80
	char buf[DIGITS_BUFLEN];
	int i;

	/* Print it backwards into the end of the buffer, low digits first */
	for (i = DIGITS_BUFLEN - 1; num != 0; i--) {
40080be7:	471c      	movi.n	a7, 20
		buf[i] = "0123456789abcdef"[num % base];
40080be9:	315f60        	srai	a5, a6, 31
	for (i = DIGITS_BUFLEN - 1; num != 0; i--) {
40080bec:	000e86        	j	40080c2a <print_digits+0x52>
40080bef:	000000        	ill
		buf[i] = "0123456789abcdef"[num % base];
40080bf2:	80f170        	add	a15, a1, a7
40080bf5:	20c660        	or	a12, a6, a6
40080bf8:	05dd      	mov.n	a13, a5
40080bfa:	09ad      	mov.n	a10, a9
40080bfc:	08bd      	mov.n	a11, a8
40080bfe:	b189      	s32i.n	a8, a1, 44
40080c00:	a199      	s32i.n	a9, a1, 40
40080c02:	0961f2        	s32i	a15, a1, 36
40080c05:	030c25        	call8	40083cc8 <__umoddi3>
40080c08:	fe7eb1        	l32r	a11, 40080600 <_iram_text_start+0xb0>
40080c0b:	91f8      	l32i.n	a15, a1, 36
40080c0d:	abaa      	add.n	a10, a11, a10
40080c0f:	000aa2        	l8ui	a10, a10, 0
		num /= base;
40080c12:	06cd      	mov.n	a12, a6
		buf[i] = "0123456789abcdef"[num % base];
40080c14:	004fa2        	s8i	a10, a15, 0
		num /= base;
40080c17:	a198      	l32i.n	a9, a1, 40
40080c19:	b188      	l32i.n	a8, a1, 44
40080c1b:	09ad      	mov.n	a10, a9
40080c1d:	08bd      	mov.n	a11, a8
40080c1f:	05dd      	mov.n	a13, a5
40080c21:	02e365        	call8	40083a58 <__udivdi3>
40080c24:	0a9d      	mov.n	a9, a10
40080c26:	0b8d      	mov.n	a8, a11
	for (i = DIGITS_BUFLEN - 1; num != 0; i--) {
40080c28:	770b      	addi.n	a7, a7, -1
40080c2a:	20a980        	or	a10, a9, a8
40080c2d:	fc1a56        	bnez	a10, 40080bf2 <print_digits+0x1a>
	}

	if (i == DIGITS_BUFLEN - 1) {
40080c30:	451c      	movi.n	a5, 20
40080c32:	079757        	bne	a7, a5, 40080c3d <print_digits+0x65>
		buf[i] = '0';
40080c35:	053c      	movi.n	a5, 48
40080c37:	144152        	s8i	a5, a1, 20
40080c3a:	000046        	j	40080c3f <print_digits+0x67>
	} else {
		i++;
40080c3d:	771b      	addi.n	a7, a7, 1
	}

	int pad = MAX(min_width - (DIGITS_BUFLEN - i), 0);
40080c3f:	152182        	l32i	a8, a1, 84
40080c42:	591c      	movi.n	a9, 21
40080c44:	878a      	add.n	a8, a7, a8
40080c46:	050c      	movi.n	a5, 0
40080c48:	1c1897        	beq	a8, a9, 40080c68 <print_digits+0x90>
40080c4b:	ebc852        	addi	a5, a8, -21
40080c4e:	000206        	j	40080c5a <print_digits+0x82>

	for (/**/; pad > 0 && pad_before; pad--) {
		out(pad_char, ctx);
40080c51:	03bd      	mov.n	a11, a3
40080c53:	04ad      	mov.n	a10, a4
40080c55:	0002e0        	callx8	a2
	for (/**/; pad > 0 && pad_before; pad--) {
40080c58:	550b      	addi.n	a5, a5, -1
40080c5a:	318f50        	srai	a8, a5, 31
40080c5d:	c08850        	sub	a8, a8, a5
40080c60:	0048d6        	bgez	a8, 40080c68 <print_digits+0x90>
40080c63:	8168      	l32i.n	a6, a1, 32
40080c65:	fe8656        	bnez	a6, 40080c51 <print_digits+0x79>
	}
	for (/**/; i < DIGITS_BUFLEN; i++) {
40080c68:	561c      	movi.n	a6, 21
		out(buf[i], ctx);
40080c6a:	817a      	add.n	a8, a1, a7
40080c6c:	0008a2        	l8ui	a10, a8, 0
40080c6f:	20b330        	or	a11, a3, a3
	for (/**/; i < DIGITS_BUFLEN; i++) {
40080c72:	01c772        	addi	a7, a7, 1
		out(buf[i], ctx);
40080c75:	0002e0        	callx8	a2
	for (/**/; i < DIGITS_BUFLEN; i++) {
40080c78:	ee9767        	bne	a7, a6, 40080c6a <print_digits+0x92>
40080c7b:	000206        	j	40080c87 <print_digits+0xaf>
	}
	for (/**/; pad > 0; pad--) {
		out(pad_char, ctx);
40080c7e:	03bd      	mov.n	a11, a3
40080c80:	04ad      	mov.n	a10, a4
40080c82:	0002e0        	callx8	a2
	for (/**/; pad > 0; pad--) {
40080c85:	550b      	addi.n	a5, a5, -1
40080c87:	f315e6        	bgei	a5, 1, 40080c7e <print_digits+0xa6>
	}
}
40080c8a:	f01d      	retw.n

40080c8c <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
40080c8c:	004136        	entry	a1, 32
	struct out_context *ctx = ctx_p;

	ctx->count++;
40080c8f:	0388      	l32i.n	a8, a3, 0
	return _char_out(c);
40080c91:	02ad      	mov.n	a10, a2
	ctx->count++;
40080c93:	881b      	addi.n	a8, a8, 1
40080c95:	0389      	s32i.n	a8, a3, 0
	return _char_out(c);
40080c97:	fe5b31        	l32r	a3, 40080604 <_iram_text_start+0xb4>
40080c9a:	002332        	l32i	a3, a3, 0
40080c9d:	0003e0        	callx8	a3
}
40080ca0:	0a2d      	mov.n	a2, a10
40080ca2:	f01d      	retw.n

40080ca4 <__printk_hook_install>:
{
40080ca4:	004136        	entry	a1, 32
	_char_out = fn;
40080ca7:	fe5781        	l32r	a8, 40080604 <_iram_text_start+0xb4>
40080caa:	0829      	s32i.n	a2, a8, 0
}
40080cac:	f01d      	retw.n
	...

40080cb0 <z_vprintk>:
{
40080cb0:	00a136        	entry	a1, 80
40080cb3:	9149      	s32i.n	a4, a1, 36
	char length_mod = 0;
40080cb5:	040c      	movi.n	a4, 0
{
40080cb7:	4159      	s32i.n	a5, a1, 16
40080cb9:	5169      	s32i.n	a6, a1, 20
40080cbb:	6179      	s32i.n	a7, a1, 24
40080cbd:	7159      	s32i.n	a5, a1, 28
40080cbf:	8169      	s32i.n	a6, a1, 32
40080cc1:	076d      	mov.n	a6, a7
	int min_width = -1;
40080cc3:	f57c      	movi.n	a5, -1
	enum pad_type padding = PAD_NONE;
40080cc5:	047d      	mov.n	a7, a4
	int might_format = 0; /* 1 if encountered a '%' */
40080cc7:	048d      	mov.n	a8, a4
	while (*fmt) {
40080cc9:	00ba46        	j	40080fb6 <z_vprintk+0x306>
		if (!might_format) {
40080ccc:	08dc      	bnez.n	a8, 40080ce0 <z_vprintk+0x30>
			if (*fmt != '%') {
40080cce:	592c      	movi.n	a9, 37
40080cd0:	029a97        	bne	a10, a9, 40080cd6 <z_vprintk+0x26>
40080cd3:	00ad86        	j	40080f8d <z_vprintk+0x2dd>
				out((int)*fmt, ctx);
40080cd6:	03bd      	mov.n	a11, a3
40080cd8:	a189      	s32i.n	a8, a1, 40
40080cda:	0002e0        	callx8	a2
40080cdd:	008046        	j	40080ee2 <z_vprintk+0x232>
			switch (*fmt) {
40080ce0:	64a092        	movi	a9, 100
40080ce3:	029a97        	bne	a10, a9, 40080ce9 <z_vprintk+0x39>
40080ce6:	003186        	j	40080db0 <z_vprintk+0x100>
40080ce9:	3739a7        	bltu	a9, a10, 40080d24 <z_vprintk+0x74>
40080cec:	993c      	movi.n	a9, 57
40080cee:	1c39a7        	bltu	a9, a10, 40080d0e <z_vprintk+0x5e>
40080cf1:	193c      	movi.n	a9, 49
40080cf3:	7bba97        	bgeu	a10, a9, 40080d72 <z_vprintk+0xc2>
40080cf6:	d92c      	movi.n	a9, 45
40080cf8:	029a97        	bne	a10, a9, 40080cfe <z_vprintk+0x4e>
40080cfb:	00a646        	j	40080f98 <z_vprintk+0x2e8>
40080cfe:	093c      	movi.n	a9, 48
40080d00:	681a97        	beq	a10, a9, 40080d6c <z_vprintk+0xbc>
40080d03:	582c      	movi.n	a8, 37
40080d05:	021a87        	beq	a10, a8, 40080d0b <z_vprintk+0x5b>
40080d08:	009a86        	j	40080f76 <z_vprintk+0x2c6>
40080d0b:	009886        	j	40080f71 <z_vprintk+0x2c1>
40080d0e:	885c      	movi.n	a8, 88
40080d10:	029a87        	bne	a10, a8, 40080d16 <z_vprintk+0x66>
40080d13:	005286        	j	40080e61 <z_vprintk+0x1b1>
40080d16:	63a082        	movi	a8, 99
40080d19:	029a87        	bne	a10, a8, 40080d1f <z_vprintk+0x6f>
40080d1c:	008b06        	j	40080f4c <z_vprintk+0x29c>
40080d1f:	0094c6        	j	40080f76 <z_vprintk+0x2c6>
40080d22:	920000        	lsi	f0, a0, 0x248
40080d25:	9770a0        	lsi	f10, a0, 0x25c
40080d28:	029a      	add.n	a0, a2, a9
40080d2a:	004806        	j	40080e4e <z_vprintk+0x19e>
40080d2d:	1339a7        	bltu	a9, a10, 40080d44 <z_vprintk+0x94>
40080d30:	69a092        	movi	a9, 105
40080d33:	791a97        	beq	a10, a9, 40080db0 <z_vprintk+0x100>
40080d36:	6ca092        	movi	a9, 108
40080d39:	541a97        	beq	a10, a9, 40080d91 <z_vprintk+0xe1>
40080d3c:	68a092        	movi	a9, 104
40080d3f:	000886        	j	40080d65 <z_vprintk+0xb5>
40080d42:	920000        	lsi	f0, a0, 0x248
40080d45:	9775a0        	lsi	f10, a5, 0x25c
40080d48:	651a      	add.n	a6, a5, a1
40080d4a:	0b39a7        	bltu	a9, a10, 40080d59 <z_vprintk+0xa9>
40080d4d:	73a082        	movi	a8, 115
40080d50:	029a87        	bne	a10, a8, 40080d56 <z_vprintk+0xa6>
40080d53:	006446        	j	40080ee8 <z_vprintk+0x238>
40080d56:	008706        	j	40080f76 <z_vprintk+0x2c6>
40080d59:	78a092        	movi	a9, 120
40080d5c:	029a97        	bne	a10, a9, 40080d62 <z_vprintk+0xb2>
40080d5f:	003f86        	j	40080e61 <z_vprintk+0x1b1>
40080d62:	7aa092        	movi	a9, 122
40080d65:	281a97        	beq	a10, a9, 40080d91 <z_vprintk+0xe1>
40080d68:	008286        	j	40080f76 <z_vprintk+0x2c6>
40080d6b:	25d600        	extui	a13, a0, 22, 3
				if (min_width < 0 && padding == PAD_NONE) {
40080d6e:	a71600        	lsi	f0, a6, 0x29c
40080d71:	65d622        	addmi	a2, a6, 0x6500
				if (min_width < 0) {
40080d74:	ca5200        	float.s	f5, a2, 0
					min_width = *fmt - '0';
40080d77:	0346d0        	lsi	f13, a6, 12
40080d7a:	e00000        	subx4	a0, a0, a0
					min_width = 10 * min_width + *fmt - '0';
40080d7d:	5a1195        	call4	400dae98 <_iram_text_end+0x56f5e>
40080d80:	f059      	s32i.n	a5, a0, 60
40080d82:	521155        	call4	400d2e98 <_iram_text_end+0x4ef5e>
40080d85:	5ad0c5        	call0	400dba94 <_iram_text_end+0x57b5a>
40080d88:	565a      	add.n	a5, a6, a5
				if (padding == PAD_NONE) {
40080d8a:	0c2237        	blt	a2, a3, 40080d9a <z_vprintk+0xea>
					padding = PAD_SPACE_BEFORE;
40080d8d:	878627        	bany	a6, a2, 40080d18 <z_vprintk+0x68>
40080d90:	a09200        	addx4	a9, a2, a0
				if (*fmt == 'h' && length_mod == 'h') {
40080d93:	9768      	l32i.n	a6, a7, 36
40080d95:	059a      	add.n	a0, a5, a9
40080d97:	0d94a7        	bne	a4, a10, 40080da8 <z_vprintk+0xf8>
40080d9a:	008146        	j	40080fa3 <z_vprintk+0x2f3>
				} else if (*fmt == 'l' && length_mod == 'l') {
40080d9d:	94c492        	addi	a9, a4, -108
40080da0:	49cc      	bnez.n	a9, 40080da8 <z_vprintk+0xf8>
40080da2:	94ca92        	addi	a9, a10, -108
40080da5:	1ff916        	beqz	a9, 40080fa8 <z_vprintk+0x2f8>
				} else if (length_mod == 0) {
40080da8:	202416        	beqz	a4, 40080fae <z_vprintk+0x2fe>
					out((int)'%', ctx);
40080dab:	0071c6        	j	40080f76 <z_vprintk+0x2c6>
40080dae:	920000        	lsi	f0, a0, 0x248
				if (length_mod == 'z') {
40080db1:	1c7aa0        	lsi	f10, a10, 112
40080db4:	9788      	l32i.n	a8, a7, 36
40080db6:	060394        	lsi	f9, a3, 24
					d = va_arg(ap, ssize_t);
40080db9:	000c      	movi.n	a0, 0
40080dbb:	a09200        	addx4	a9, a2, a0
				} else if (length_mod == 'l') {
40080dbe:	976c      	movi.n	a7, -23
40080dc0:	860294        	lsi	f9, a2, 0x218
					d = va_arg(ap, long);
40080dc3:	0009      	s32i.n	a0, a0, 0
				} else if (length_mod == 'L') {
40080dc5:	c94c      	movi.n	a9, 76
40080dc7:	219497        	bne	a4, a9, 40080dec <z_vprintk+0x13c>
					long long lld = va_arg(ap, long long);
40080dca:	897c      	movi.n	a9, -8
40080dcc:	c67b      	addi.n	a12, a6, 7
40080dce:	10cc90        	and	a12, a12, a9
40080dd1:	9c8b      	addi.n	a9, a12, 8
40080dd3:	81b8      	l32i.n	a11, a1, 32
40080dd5:	07a897        	bge	a8, a9, 40080de0 <z_vprintk+0x130>
40080dd8:	0228c7        	blt	a8, a12, 40080dde <z_vprintk+0x12e>
40080ddb:	28a092        	movi	a9, 40
40080dde:	71b8      	l32i.n	a11, a1, 28
40080de0:	8b9a      	add.n	a8, a11, a9
40080de2:	f8c882        	addi	a8, a8, -8
					d = (printk_val_t) lld;
40080de5:	08c8      	l32i.n	a12, a8, 0
40080de7:	1868      	l32i.n	a6, a8, 4
40080de9:	0005c6        	j	40080e04 <z_vprintk+0x154>
					d = va_arg(ap, int);
40080dec:	964b      	addi.n	a9, a6, 4
40080dee:	81b8      	l32i.n	a11, a1, 32
40080df0:	06a897        	bge	a8, a9, 40080dfa <z_vprintk+0x14a>
40080df3:	012867        	blt	a8, a6, 40080df8 <z_vprintk+0x148>
40080df6:	492c      	movi.n	a9, 36
40080df8:	71b8      	l32i.n	a11, a1, 28
40080dfa:	bb9a      	add.n	a11, a11, a9
40080dfc:	fccbb2        	addi	a11, a11, -4
40080dff:	0bc8      	l32i.n	a12, a11, 0
40080e01:	316fc0        	srai	a6, a12, 31
				if (*fmt != 'u' && negative(d)) {
40080e04:	75a082        	movi	a8, 117
40080e07:	251a87        	beq	a10, a8, 40080e30 <z_vprintk+0x180>
40080e0a:	0226d6        	bgez	a6, 40080e30 <z_vprintk+0x180>
					out((int)'-', ctx);
40080e0d:	03bd      	mov.n	a11, a3
40080e0f:	da2c      	movi.n	a10, 45
40080e11:	0b6192        	s32i	a9, a1, 44
40080e14:	0a61c2        	s32i	a12, a1, 40
40080e17:	0002e0        	callx8	a2
					d = -d;
40080e1a:	a1c8      	l32i.n	a12, a1, 40
40080e1c:	180c      	movi.n	a8, 1
40080e1e:	60c0c0        	neg	a12, a12
40080e21:	0a0c      	movi.n	a10, 0
40080e23:	838ac0        	moveqz	a8, a10, a12
40080e26:	60d060        	neg	a13, a6
					min_width--;
40080e29:	b198      	l32i.n	a9, a1, 44
					d = -d;
40080e2b:	c06d80        	sub	a6, a13, a8
					min_width--;
40080e2e:	550b      	addi.n	a5, a5, -1
	print_digits(out, ctx, num, 10, padding != PAD_SPACE_AFTER,
40080e30:	fdc7a2        	addi	a10, a7, -3
40080e33:	080c      	movi.n	a8, 0
40080e35:	1f0c      	movi.n	a15, 1
40080e37:	0e3c      	movi.n	a14, 48
40080e39:	83f8a0        	moveqz	a15, a8, a10
40080e3c:	0b2c      	movi.n	a11, 32
40080e3e:	a70b      	addi.n	a10, a7, -1
40080e40:	83bea0        	moveqz	a11, a14, a10
40080e43:	1159      	s32i.n	a5, a1, 4
40080e45:	01b9      	s32i.n	a11, a1, 0
40080e47:	ae0c      	movi.n	a14, 10
40080e49:	06dd      	mov.n	a13, a6
40080e4b:	002106        	j	40080ed3 <z_vprintk+0x223>
				out('0', ctx);
40080e4e:	03bd      	mov.n	a11, a3
40080e50:	0a3c      	movi.n	a10, 48
40080e52:	0002e0        	callx8	a2
				out('x', ctx);
40080e55:	03bd      	mov.n	a11, a3
40080e57:	78a0a2        	movi	a10, 120
40080e5a:	0002e0        	callx8	a2
				min_width = sizeof(void *) * 2;
40080e5d:	850c      	movi.n	a5, 8
				padding = PAD_ZERO_BEFORE;
40080e5f:	170c      	movi.n	a7, 1
				if (*fmt == 'p') {
40080e61:	9198      	l32i.n	a9, a1, 36
40080e63:	881c      	movi.n	a8, 24
40080e65:	0009a2        	l8ui	a10, a9, 0
40080e68:	70a092        	movi	a9, 112
40080e6b:	029a97        	bne	a10, a9, 40080e71 <z_vprintk+0x1c1>
					x = (uintptr_t)va_arg(ap, void *);
40080e6e:	000b86        	j	40080ea0 <z_vprintk+0x1f0>
				} else if (length_mod == 'l') {
40080e71:	6ca092        	movi	a9, 108
40080e74:	029497        	bne	a4, a9, 40080e7a <z_vprintk+0x1ca>
					x = va_arg(ap, unsigned long);
40080e77:	000946        	j	40080ea0 <z_vprintk+0x1f0>
				} else if (length_mod == 'L') {
40080e7a:	c94c      	movi.n	a9, 76
40080e7c:	209497        	bne	a4, a9, 40080ea0 <z_vprintk+0x1f0>
					x = va_arg(ap, unsigned long long);
40080e7f:	897c      	movi.n	a9, -8
40080e81:	c67b      	addi.n	a12, a6, 7
40080e83:	10cc90        	and	a12, a12, a9
40080e86:	9c8b      	addi.n	a9, a12, 8
40080e88:	81a8      	l32i.n	a10, a1, 32
40080e8a:	06a897        	bge	a8, a9, 40080e94 <z_vprintk+0x1e4>
40080e8d:	0128c7        	blt	a8, a12, 40080e92 <z_vprintk+0x1e2>
40080e90:	892c      	movi.n	a9, 40
40080e92:	71a8      	l32i.n	a10, a1, 28
40080e94:	8a9a      	add.n	a8, a10, a9
40080e96:	f8c882        	addi	a8, a8, -8
40080e99:	08c8      	l32i.n	a12, a8, 0
40080e9b:	18d8      	l32i.n	a13, a8, 4
40080e9d:	000646        	j	40080eba <z_vprintk+0x20a>
					x = va_arg(ap, unsigned int);
40080ea0:	964b      	addi.n	a9, a6, 4
40080ea2:	81a8      	l32i.n	a10, a1, 32
40080ea4:	06a897        	bge	a8, a9, 40080eae <z_vprintk+0x1fe>
40080ea7:	012867        	blt	a8, a6, 40080eac <z_vprintk+0x1fc>
40080eaa:	492c      	movi.n	a9, 36
40080eac:	71a8      	l32i.n	a10, a1, 28
40080eae:	80aa90        	add	a10, a10, a9
40080eb1:	fccaa2        	addi	a10, a10, -4
40080eb4:	002ac2        	l32i	a12, a10, 0
40080eb7:	00a0d2        	movi	a13, 0
	print_digits(out, ctx, num, 16, padding != PAD_SPACE_AFTER,
40080eba:	fdc7a2        	addi	a10, a7, -3
40080ebd:	080c      	movi.n	a8, 0
40080ebf:	1f0c      	movi.n	a15, 1
40080ec1:	0e3c      	movi.n	a14, 48
40080ec3:	83f8a0        	moveqz	a15, a8, a10
40080ec6:	0b2c      	movi.n	a11, 32
40080ec8:	a70b      	addi.n	a10, a7, -1
40080eca:	83bea0        	moveqz	a11, a14, a10
40080ecd:	1159      	s32i.n	a5, a1, 4
40080ecf:	01b9      	s32i.n	a11, a1, 0
40080ed1:	0e1c      	movi.n	a14, 16
40080ed3:	03bd      	mov.n	a11, a3
40080ed5:	02ad      	mov.n	a10, a2
40080ed7:	b199      	s32i.n	a9, a1, 44
40080ed9:	a189      	s32i.n	a8, a1, 40
40080edb:	ffcfe5        	call8	40080bd8 <print_digits>
40080ede:	b198      	l32i.n	a9, a1, 44
40080ee0:	096d      	mov.n	a6, a9
			might_format = 0;
40080ee2:	a188      	l32i.n	a8, a1, 40
40080ee4:	003206        	j	40080fb0 <z_vprintk+0x300>
40080ee7:	964b00        	lsi	f0, a11, 0x258
				char *s = va_arg(ap, char *);
40080eea:	881c      	movi.n	a8, 24
40080eec:	0ca897        	bge	a8, a9, 40080efc <z_vprintk+0x24c>
40080eef:	012867        	blt	a8, a6, 40080ef4 <z_vprintk+0x244>
40080ef2:	492c      	movi.n	a9, 36
40080ef4:	096d      	mov.n	a6, a9
40080ef6:	7188      	l32i.n	a8, a1, 28
40080ef8:	000106        	j	40080f00 <z_vprintk+0x250>
40080efb:	818800        	src	a8, a8, a0
40080efe:	096d      	mov.n	a6, a9
40080f00:	889a      	add.n	a8, a8, a9
40080f02:	fcc882        	addi	a8, a8, -4
40080f05:	08d8      	l32i.n	a13, a8, 0
40080f07:	0d9d      	mov.n	a9, a13
				while (*s) {
40080f09:	0003c6        	j	40080f1c <z_vprintk+0x26c>
					out((int)(*s++), ctx);
40080f0c:	991b      	addi.n	a9, a9, 1
40080f0e:	03bd      	mov.n	a11, a3
40080f10:	b199      	s32i.n	a9, a1, 44
40080f12:	0a61d2        	s32i	a13, a1, 40
40080f15:	0002e0        	callx8	a2
40080f18:	a1d8      	l32i.n	a13, a1, 40
40080f1a:	b198      	l32i.n	a9, a1, 44
				while (*s) {
40080f1c:	0009a2        	l8ui	a10, a9, 0
40080f1f:	fe9a56        	bnez	a10, 40080f0c <z_vprintk+0x25c>
			might_format = 0;
40080f22:	0a8d      	mov.n	a8, a10
				if (padding == PAD_SPACE_AFTER) {
40080f24:	023726        	beqi	a7, 3, 40080f2a <z_vprintk+0x27a>
40080f27:	002146        	j	40080fb0 <z_vprintk+0x300>
					int remaining = min_width - (s - start);
40080f2a:	c099d0        	sub	a9, a9, a13
40080f2d:	c09590        	sub	a9, a5, a9
						out(' ', ctx);
40080f30:	082c      	movi.n	a8, 32
					while (remaining-- > 0) {
40080f32:	000406        	j	40080f46 <z_vprintk+0x296>
						out(' ', ctx);
40080f35:	08ad      	mov.n	a10, a8
40080f37:	03bd      	mov.n	a11, a3
40080f39:	a189      	s32i.n	a8, a1, 40
40080f3b:	b199      	s32i.n	a9, a1, 44
40080f3d:	0002e0        	callx8	a2
40080f40:	b198      	l32i.n	a9, a1, 44
40080f42:	a188      	l32i.n	a8, a1, 40
40080f44:	990b      	addi.n	a9, a9, -1
					while (remaining-- > 0) {
40080f46:	eb19e6        	bgei	a9, 1, 40080f35 <z_vprintk+0x285>
40080f49:	000ec6        	j	40080f88 <z_vprintk+0x2d8>
				int c = va_arg(ap, int);
40080f4c:	964b      	addi.n	a9, a6, 4
40080f4e:	8a1c      	movi.n	a10, 24
40080f50:	8188      	l32i.n	a8, a1, 32
40080f52:	06aa97        	bge	a10, a9, 40080f5c <z_vprintk+0x2ac>
40080f55:	012a67        	blt	a10, a6, 40080f5a <z_vprintk+0x2aa>
40080f58:	492c      	movi.n	a9, 36
40080f5a:	7188      	l32i.n	a8, a1, 28
40080f5c:	889a      	add.n	a8, a8, a9
40080f5e:	fcc882        	addi	a8, a8, -4
				out(c, ctx);
40080f61:	08a8      	l32i.n	a10, a8, 0
40080f63:	03bd      	mov.n	a11, a3
40080f65:	b199      	s32i.n	a9, a1, 44
40080f67:	0002e0        	callx8	a2
				break;
40080f6a:	b198      	l32i.n	a9, a1, 44
40080f6c:	096d      	mov.n	a6, a9
40080f6e:	000586        	j	40080f88 <z_vprintk+0x2d8>
				out((int)'%', ctx);
40080f71:	03bd      	mov.n	a11, a3
40080f73:	000386        	j	40080f85 <z_vprintk+0x2d5>
				out((int)'%', ctx);
40080f76:	03bd      	mov.n	a11, a3
40080f78:	25a0a2        	movi	a10, 37
40080f7b:	0002e0        	callx8	a2
				out((int)*fmt, ctx);
40080f7e:	9188      	l32i.n	a8, a1, 36
40080f80:	03bd      	mov.n	a11, a3
40080f82:	0008a2        	l8ui	a10, a8, 0
40080f85:	0002e0        	callx8	a2
			might_format = 0;
40080f88:	080c      	movi.n	a8, 0
				break;
40080f8a:	000886        	j	40080fb0 <z_vprintk+0x300>
				length_mod = 0;
40080f8d:	084d      	mov.n	a4, a8
				padding = PAD_NONE;
40080f8f:	087d      	mov.n	a7, a8
				min_width = -1;
40080f91:	f57c      	movi.n	a5, -1
				might_format = 1;
40080f93:	180c      	movi.n	a8, 1
40080f95:	0005c6        	j	40080fb0 <z_vprintk+0x300>
				padding = PAD_SPACE_AFTER;
40080f98:	370c      	movi.n	a7, 3
40080f9a:	000486        	j	40080fb0 <z_vprintk+0x300>
					padding = PAD_ZERO_BEFORE;
40080f9d:	170c      	movi.n	a7, 1
40080f9f:	000346        	j	40080fb0 <z_vprintk+0x300>
40080fa2:	844c00        	extui	a4, a0, 12, 9
					length_mod = 'H';
40080fa5:	0001c6        	j	40080fb0 <z_vprintk+0x300>
					length_mod = 'L';
40080fa8:	c44c      	movi.n	a4, 76
40080faa:	000086        	j	40080fb0 <z_vprintk+0x300>
40080fad:	0a4d00        	add.s	f4, f13, f0
		++fmt;
40080fb0:	9198      	l32i.n	a9, a1, 36
40080fb2:	991b      	addi.n	a9, a9, 1
40080fb4:	9199      	s32i.n	a9, a1, 36
	while (*fmt) {
40080fb6:	9198      	l32i.n	a9, a1, 36
40080fb8:	0009a2        	l8ui	a10, a9, 0
40080fbb:	d0da56        	bnez	a10, 40080ccc <z_vprintk+0x1c>
}
40080fbe:	f01d      	retw.n

40080fc0 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
40080fc0:	008136        	entry	a1, 64
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	z_vprintk(char_out, &ctx, fmt, ap);
40080fc3:	fd91a1        	l32r	a10, 40080608 <_iram_text_start+0xb8>
	struct out_context ctx = { 0 };
40080fc6:	00a082        	movi	a8, 0
	z_vprintk(char_out, &ctx, fmt, ap);
40080fc9:	20d330        	or	a13, a3, a3
40080fcc:	20e440        	or	a14, a4, a4
40080fcf:	05fd      	mov.n	a15, a5
40080fd1:	02cd      	mov.n	a12, a2
40080fd3:	01bd      	mov.n	a11, a1
	struct out_context ctx = { 0 };
40080fd5:	0189      	s32i.n	a8, a1, 0
	z_vprintk(char_out, &ctx, fmt, ap);
40080fd7:	ffcda5        	call8	40080cb0 <z_vprintk>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
40080fda:	f01d      	retw.n

40080fdc <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
40080fdc:	00a136        	entry	a1, 80
	va_list ap;

	va_start(ap, fmt);
40080fdf:	10c1c2        	addi	a12, a1, 16
40080fe2:	30c1b2        	addi	a11, a1, 48
40080fe5:	4d0c      	movi.n	a13, 4

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
40080fe7:	02ad      	mov.n	a10, a2
	va_start(ap, fmt);
40080fe9:	5139      	s32i.n	a3, a1, 20
40080feb:	6149      	s32i.n	a4, a1, 24
40080fed:	7159      	s32i.n	a5, a1, 28
40080fef:	8169      	s32i.n	a6, a1, 32
40080ff1:	9179      	s32i.n	a7, a1, 36
40080ff3:	11c9      	s32i.n	a12, a1, 4
40080ff5:	01b9      	s32i.n	a11, a1, 0
40080ff7:	21d9      	s32i.n	a13, a1, 8
		vprintk(fmt, ap);
40080ff9:	fffc65        	call8	40080fc0 <vprintk>
	}
	va_end(ap);
}
40080ffc:	f01d      	retw.n
	...

40081000 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
40081000:	004136        	entry	a1, 32
	entry(p1, p2, p3);
40081003:	20c550        	or	a12, a5, a5
40081006:	20b440        	or	a11, a4, a4
40081009:	03ad      	mov.n	a10, a3
4008100b:	0002e0        	callx8	a2
	return z_impl_k_current_get();
4008100e:	021ba5        	call8	400831c8 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
40081011:	0236e5        	call8	40083380 <z_impl_k_thread_abort>

40081014 <chunk_field>:
	return (chunk_unit_t *)h;
}

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
40081014:	004136        	entry	a1, 32
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
40081017:	1133d0        	slli	a3, a3, 3
4008101a:	323a      	add.n	a3, a2, a3

	if (big_heap(h)) {
4008101c:	fd7c81        	l32r	a8, 4008060c <_iram_text_start+0xbc>
4008101f:	2228      	l32i.n	a2, a2, 8
40081021:	0bb827        	bgeu	a8, a2, 40081030 <chunk_field+0x1c>
		return ((uint32_t *)cmem)[f];
40081024:	1144e0        	slli	a4, a4, 2
40081027:	334a      	add.n	a3, a3, a4
40081029:	0328      	l32i.n	a2, a3, 0
4008102b:	000246        	j	40081038 <chunk_field+0x24>
4008102e:	f00000        	subx8	a0, a0, a0
	} else {
		return ((uint16_t *)cmem)[f];
40081031:	4a1144        	mula.da.lh.ldinc	m1, a1, m0, a4
40081034:	132233        	lsi	f3, a2, 76
40081037:	f01d00        	subx8	a1, a13, a0
	...

4008103c <chunk_set>:
	}
}

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
4008103c:	004136        	entry	a1, 32
	CHECK(c <= h->len);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
4008103f:	1133d0        	slli	a3, a3, 3
40081042:	323a      	add.n	a3, a2, a3

	if (big_heap(h)) {
40081044:	fd7281        	l32r	a8, 4008060c <_iram_text_start+0xbc>
40081047:	2228      	l32i.n	a2, a2, 8
40081049:	0bb827        	bgeu	a8, a2, 40081058 <chunk_set+0x1c>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
4008104c:	1144e0        	slli	a4, a4, 2
4008104f:	334a      	add.n	a3, a3, a4
40081051:	0359      	s32i.n	a5, a3, 0
40081053:	000246        	j	40081060 <chunk_set+0x24>
40081056:	f00000        	subx8	a0, a0, a0
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
40081059:	4a1144        	mula.da.lh.ldinc	m1, a1, m0, a4
4008105c:	535233        	lsi	f3, a2, 0x14c
4008105f:	f01d00        	subx8	a1, a13, a0
	...

40081064 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
40081064:	004136        	entry	a1, 32
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
40081067:	1c0c      	movi.n	a12, 1
40081069:	03bd      	mov.n	a11, a3
4008106b:	02ad      	mov.n	a10, a2
4008106d:	fffa65        	call8	40081014 <chunk_field>
}
40081070:	4121a0        	srli	a2, a10, 1
40081073:	f01d      	retw.n
40081075:	000000        	ill

40081078 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
40081078:	004136        	entry	a1, 32
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
4008107b:	1133d0        	slli	a3, a3, 3
4008107e:	323a      	add.n	a3, a2, a3

	if (big_heap(h)) {
40081080:	fd6381        	l32r	a8, 4008060c <_iram_text_start+0xbc>
40081083:	2228      	l32i.n	a2, a2, 8
40081085:	17b827        	bgeu	a8, a2, 400810a0 <set_chunk_used+0x28>
		if (used) {
40081088:	1388      	l32i.n	a8, a3, 4
4008108a:	648c      	beqz.n	a4, 40081094 <set_chunk_used+0x1c>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1;
4008108c:	120c      	movi.n	a2, 1
4008108e:	208820        	or	a8, a8, a2
40081091:	000106        	j	40081099 <set_chunk_used+0x21>
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1;
40081094:	e27c      	movi.n	a2, -2
40081096:	108820        	and	a8, a8, a2
40081099:	1389      	s32i.n	a8, a3, 4
4008109b:	000586        	j	400810b5 <set_chunk_used+0x3d>
4008109e:	820000        	mull	a0, a0, a0
		}
	} else {
		if (used) {
400810a1:	8c0113        	lsi	f1, a1, 0x230
400810a4:	120c64        	lsi	f6, a12, 72
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1;
400810a7:	208820        	or	a8, a8, a2
400810aa:	000106        	j	400810b2 <set_chunk_used+0x3a>
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1;
400810ad:	e27c      	movi.n	a2, -2
400810af:	108820        	and	a8, a8, a2
400810b2:	015382        	s16i	a8, a3, 2
		}
	}
}
400810b5:	f01d      	retw.n
	...

400810b8 <set_chunk_size>:
 * Note: no need to preserve the used bit here as the chunk is never in use
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, size_t size)
{
400810b8:	004136        	entry	a1, 32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
400810bb:	11d4f0        	slli	a13, a4, 1
400810be:	01a0c2        	movi	a12, 1
400810c1:	20b330        	or	a11, a3, a3
400810c4:	20a220        	or	a10, a2, a2
400810c7:	fff765        	call8	4008103c <chunk_set>
}
400810ca:	f01d      	retw.n

400810cc <bucket_idx>:
{
	return bytes_to_chunksz(h, 1);
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
400810cc:	004136        	entry	a1, 32
	return big_heap(h) ? 8 : 4;
400810cf:	fd4f91        	l32r	a9, 4008060c <_iram_text_start+0xbc>
400810d2:	2228      	l32i.n	a2, a2, 8
400810d4:	880c      	movi.n	a8, 8
400810d6:	023927        	bltu	a9, a2, 400810dc <bucket_idx+0x10>
400810d9:	04a082        	movi	a8, 4
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
400810dc:	888b      	addi.n	a8, a8, 8
400810de:	412380        	srli	a2, a8, 3
	size_t usable_sz = sz - min_chunk_size(h) + 1;
400810e1:	331b      	addi.n	a3, a3, 1
400810e3:	c03320        	sub	a3, a3, a2
	return 31 - __builtin_clz(usable_sz);
400810e6:	40f330        	nsau	a3, a3
}
400810e9:	f21c      	movi.n	a2, 31
400810eb:	c02230        	sub	a2, a2, a3
400810ee:	f01d      	retw.n

400810f0 <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
400810f0:	004136        	entry	a1, 32
	return sizeof(void *) > 4 || chunks > 0x7fff;
400810f3:	03bd      	mov.n	a11, a3
400810f5:	02ad      	mov.n	a10, a2
400810f7:	fff6e5        	call8	40081064 <chunk_size>
	return big_heap(h) && chunk_size(h, c) == 1;
400810fa:	fd4451        	l32r	a5, 4008060c <_iram_text_start+0xbc>
400810fd:	2248      	l32i.n	a4, a2, 8
400810ff:	05b547        	bgeu	a5, a4, 40081108 <free_list_add+0x18>
	if (!solo_free_header(h, c)) {
40081102:	021a66        	bnei	a10, 1, 40081108 <free_list_add+0x18>
40081105:	001bc6        	j	40081178 <free_list_add+0x88>
		int bidx = bucket_idx(h, chunk_size(h, c));
40081108:	0abd      	mov.n	a11, a10
4008110a:	02ad      	mov.n	a10, a2
4008110c:	fffbe5        	call8	400810cc <bucket_idx>
	if (b->next == 0) {
4008110f:	118ae0        	slli	a8, a10, 2
40081112:	828a      	add.n	a8, a2, a8
40081114:	4848      	l32i.n	a4, a8, 16
40081116:	44ec      	bnez.n	a4, 4008113e <free_list_add+0x4e>
		h->avail_buckets |= (1 << bidx);
40081118:	140c      	movi.n	a4, 1
4008111a:	401a00        	ssl	a10
4008111d:	a14400        	sll	a4, a4
40081120:	32a8      	l32i.n	a10, a2, 12
	chunk_set(h, c, FREE_PREV, prev);
40081122:	03dd      	mov.n	a13, a3
40081124:	20aa40        	or	a10, a10, a4
40081127:	32a9      	s32i.n	a10, a2, 12
40081129:	2c0c      	movi.n	a12, 2
4008112b:	03bd      	mov.n	a11, a3
		b->next = c;
4008112d:	4839      	s32i.n	a3, a8, 16
4008112f:	02ad      	mov.n	a10, a2
40081131:	fff0a5        	call8	4008103c <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
40081134:	03dd      	mov.n	a13, a3
40081136:	3c0c      	movi.n	a12, 3
40081138:	03bd      	mov.n	a11, a3
4008113a:	000d46        	j	40081173 <free_list_add+0x83>
4008113d:	a0c200        	addx4	a12, a2, a0
	return chunk_field(h, c, FREE_PREV);
40081140:	b44002        	s8i	a0, a0, 180
40081143:	a22020        	muluh	a2, a0, a2
40081146:	ece520        	lsi	f2, a5, 0x3b0
40081149:	ff          	.byte 0xff
	chunk_set(h, c, FREE_PREV, prev);
4008114a:	0add      	mov.n	a13, a10
	return chunk_field(h, c, FREE_PREV);
4008114c:	0a5d      	mov.n	a5, a10
	chunk_set(h, c, FREE_PREV, prev);
4008114e:	2c0c      	movi.n	a12, 2
40081150:	03bd      	mov.n	a11, a3
40081152:	02ad      	mov.n	a10, a2
40081154:	ffee65        	call8	4008103c <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
40081157:	04dd      	mov.n	a13, a4
40081159:	3c0c      	movi.n	a12, 3
4008115b:	03bd      	mov.n	a11, a3
4008115d:	02ad      	mov.n	a10, a2
4008115f:	ffede5        	call8	4008103c <chunk_set>
40081162:	03dd      	mov.n	a13, a3
40081164:	3c0c      	movi.n	a12, 3
40081166:	05bd      	mov.n	a11, a5
40081168:	02ad      	mov.n	a10, a2
4008116a:	ffed25        	call8	4008103c <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
4008116d:	03dd      	mov.n	a13, a3
4008116f:	2c0c      	movi.n	a12, 2
40081171:	04bd      	mov.n	a11, a4
40081173:	02ad      	mov.n	a10, a2
40081175:	ffec65        	call8	4008103c <chunk_set>
		free_list_add_bidx(h, c, bidx);
	}
}
40081178:	f01d      	retw.n
	...

4008117c <sys_heap_init>:
	set_chunk_used(h, c, true);
	return mem;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
4008117c:	004136        	entry	a1, 32
	return big_heap_bytes(size) ? 8 : 4;
4008117f:	fd2451        	l32r	a5, 40080610 <_iram_text_start+0xc0>
40081182:	890c      	movi.n	a9, 8
40081184:	013547        	bltu	a5, a4, 40081189 <sys_heap_init+0xd>
40081187:	490c      	movi.n	a9, 4
	/* Must fit in a 32 bit count of HUNK_UNIT */
	__ASSERT(bytes / CHUNK_UNIT <= 0xffffffffU, "heap size is too big");

	/* Reserve the final marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
40081189:	c04490        	sub	a4, a4, a9

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
4008118c:	887c      	movi.n	a8, -8
4008118e:	537b      	addi.n	a5, a3, 7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40081190:	334a      	add.n	a3, a3, a4
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
40081192:	105580        	and	a5, a5, a8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40081195:	103380        	and	a3, a3, a8
	CHECK(end > addr);
	__ASSERT(buf_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->chunk0_hdr_area = 0;
40081198:	fcf891        	l32r	a9, 40080578 <_iram_text_start+0x28>
4008119b:	fcf781        	l32r	a8, 40080578 <_iram_text_start+0x28>
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
4008119e:	c03350        	sub	a3, a3, a5
	heap->heap = h;
400811a1:	0259      	s32i.n	a5, a2, 0
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
400811a3:	413330        	srli	a3, a3, 3
	h->len = buf_sz;
	h->avail_buckets = 0;
400811a6:	040c      	movi.n	a4, 0
	h->chunk0_hdr_area = 0;
400811a8:	0589      	s32i.n	a8, a5, 0
400811aa:	1599      	s32i.n	a9, a5, 4

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
400811ac:	03bd      	mov.n	a11, a3
	h->len = buf_sz;
400811ae:	2539      	s32i.n	a3, a5, 8
	h->avail_buckets = 0;
400811b0:	3549      	s32i.n	a4, a5, 12
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
400811b2:	20a550        	or	a10, a5, a5
400811b5:	fff165        	call8	400810cc <bucket_idx>
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
400811b8:	112ae0        	slli	a2, a10, 2
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
400811bb:	1bc222        	addi	a2, a2, 27
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
400811be:	ba1b      	addi.n	a11, a10, 1
400811c0:	412320        	srli	a2, a2, 3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
400811c3:	10c592        	addi	a9, a5, 16
400811c6:	048d      	mov.n	a8, a4
400811c8:	000186        	j	400811d2 <sys_heap_init+0x56>
400811cb:	094900        	l32e	a0, a9, -48
400811ce:	881b      	addi.n	a8, a8, 1
400811d0:	994b      	addi.n	a9, a9, 4
400811d2:	f628b7        	blt	a8, a11, 400811cc <sys_heap_init+0x50>
		h->buckets[i].next = 0;
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
400811d5:	02cd      	mov.n	a12, a2
400811d7:	05ad      	mov.n	a10, a5
400811d9:	0b0c      	movi.n	a11, 0
400811db:	ffede5        	call8	400810b8 <set_chunk_size>
	set_chunk_used(h, 0, true);
400811de:	05ad      	mov.n	a10, a5
400811e0:	1c0c      	movi.n	a12, 1
400811e2:	0b0c      	movi.n	a11, 0
400811e4:	ffe925        	call8	40081078 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
400811e7:	c04320        	sub	a4, a3, a2
400811ea:	04cd      	mov.n	a12, a4
400811ec:	02bd      	mov.n	a11, a2
400811ee:	05ad      	mov.n	a10, a5
400811f0:	ffec65        	call8	400810b8 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
400811f3:	02dd      	mov.n	a13, a2
400811f5:	02bd      	mov.n	a11, a2
400811f7:	05ad      	mov.n	a10, a5
400811f9:	0c0c      	movi.n	a12, 0
400811fb:	ffe425        	call8	4008103c <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
400811fe:	03bd      	mov.n	a11, a3
40081200:	05ad      	mov.n	a10, a5
40081202:	0c0c      	movi.n	a12, 0
40081204:	ffeb25        	call8	400810b8 <set_chunk_size>
40081207:	04dd      	mov.n	a13, a4
40081209:	03bd      	mov.n	a11, a3
4008120b:	05ad      	mov.n	a10, a5
4008120d:	0c0c      	movi.n	a12, 0
4008120f:	ffe2e5        	call8	4008103c <chunk_set>
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
40081212:	03bd      	mov.n	a11, a3
40081214:	05ad      	mov.n	a10, a5
40081216:	1c0c      	movi.n	a12, 1
40081218:	ffe5e5        	call8	40081078 <set_chunk_used>

	free_list_add(h, chunk0_size);
4008121b:	02bd      	mov.n	a11, a2
4008121d:	05ad      	mov.n	a10, a5
4008121f:	ffed25        	call8	400810f0 <free_list_add>
}
40081222:	f01d      	retw.n

40081224 <arch_printk_char_out>:
	CODE_UNREACHABLE;
}

/* Boot-time static default printk handler, possibly to be overridden later. */
int arch_printk_char_out(int c)
{
40081224:	004136        	entry	a1, 32
	if (c == '\n') {
40081227:	079266        	bnei	a2, 10, 40081232 <arch_printk_char_out+0xe>
		esp32_rom_uart_tx_one_char('\r');
4008122a:	da0c      	movi.n	a10, 13
4008122c:	fcfa81        	l32r	a8, 40080614 <_iram_text_start+0xc4>
4008122f:	0008e0        	callx8	a8
	}
	esp32_rom_uart_tx_one_char(c);
40081232:	74a020        	extui	a10, a2, 0, 8
40081235:	fcf781        	l32r	a8, 40080614 <_iram_text_start+0xc4>
40081238:	0008e0        	callx8	a8
	return 0;
}
4008123b:	020c      	movi.n	a2, 0
4008123d:	f01d      	retw.n
	...

40081240 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
40081240:	004136        	entry	a1, 32
40081243:	fcf5a1        	l32r	a10, 40080618 <_iram_text_start+0xc8>
40081246:	015465        	call8	4008278c <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
40081249:	fcf421        	l32r	a2, 4008061c <_iram_text_start+0xcc>
4008124c:	0062a2        	s32i	a10, a2, 0
	__stdout_hook_install(console_out);
4008124f:	fcf421        	l32r	a2, 40080620 <_iram_text_start+0xd0>
40081252:	02ad      	mov.n	a10, a2
40081254:	00a9a5        	call8	40081cf0 <__stdout_hook_install>
	__printk_hook_install(console_out);
40081257:	02ad      	mov.n	a10, a2
40081259:	ffa4a5        	call8	40080ca4 <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
4008125c:	020c      	movi.n	a2, 0
4008125e:	f01d      	retw.n

40081260 <console_out>:
{
40081260:	004136        	entry	a1, 32
	if ('\n' == c) {
40081263:	fcee31        	l32r	a3, 4008061c <_iram_text_start+0xcc>
40081266:	0a9266        	bnei	a2, 10, 40081274 <console_out+0x14>
40081269:	03a8      	l32i.n	a10, a3, 0
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
4008126b:	2a88      	l32i.n	a8, a10, 8
4008126d:	db0c      	movi.n	a11, 13
4008126f:	1888      	l32i.n	a8, a8, 4
40081271:	0008e0        	callx8	a8
	uart_poll_out(uart_console_dev, c);
40081274:	03a8      	l32i.n	a10, a3, 0
40081276:	2a38      	l32i.n	a3, a10, 8
40081278:	74b020        	extui	a11, a2, 0, 8
4008127b:	1338      	l32i.n	a3, a3, 4
4008127d:	0003e0        	callx8	a3
}
40081280:	f01d      	retw.n
	...

40081284 <clock_control_esp32_on>:
	REG_WRITE(APB_CTRL_PLL_TICK_CONF_REG, PLL_APB_CLK_FREQ - 1);
}

static int clock_control_esp32_on(const struct device *dev,
				  clock_control_subsys_t sys)
{
40081284:	004136        	entry	a1, 32
	uint32_t bank = GET_REG_BANK(sys);
	uint32_t offset =  GET_REG_OFFSET(sys);

	__ASSERT_NO_MSG(bank >= CLOCK_REGS_BANK_COUNT);

	esp32_set_mask32(BIT(offset), clock_control_regs[bank].clk);
40081287:	180c      	movi.n	a8, 1
	uint32_t bank = GET_REG_BANK(sys);
40081289:	419530        	srli	a9, a3, 5
	esp32_set_mask32(BIT(offset), clock_control_regs[bank].clk);
4008128c:	401300        	ssl	a3
4008128f:	a13800        	sll	a3, a8
40081292:	fce481        	l32r	a8, 40080624 <_iram_text_start+0xd4>
40081295:	1199d0        	slli	a9, a9, 3
40081298:	889a      	add.n	a8, a8, a9
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
4008129a:	08a8      	l32i.n	a10, a8, 0
	esp32_clear_mask32(BIT(offset), clock_control_regs[bank].rst);
	return 0;
}
4008129c:	020c      	movi.n	a2, 0
4008129e:	0020c0        	memw
400812a1:	0a98      	l32i.n	a9, a10, 0
#include <stdbool.h>
#include <arch/xtensa/arch.h>

static inline void esp32_set_mask32(uint32_t v, uint32_t mem_addr)
{
	sys_write32(sys_read32(mem_addr) | v, mem_addr);
400812a3:	209390        	or	a9, a3, a9
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
400812a6:	0020c0        	memw
400812a9:	0a99      	s32i.n	a9, a10, 0
	return *(volatile uint32_t *)addr;
400812ab:	1898      	l32i.n	a9, a8, 4
}

static inline void esp32_clear_mask32(uint32_t v, uint32_t mem_addr)
{
	sys_write32(sys_read32(mem_addr) & ~v, mem_addr);
400812ad:	f87c      	movi.n	a8, -1
400812af:	0020c0        	memw
400812b2:	09a8      	l32i.n	a10, a9, 0
400812b4:	308830        	xor	a8, a8, a3
400812b7:	1088a0        	and	a8, a8, a10
	*(volatile uint32_t *)addr = data;
400812ba:	0020c0        	memw
400812bd:	0989      	s32i.n	a8, a9, 0
400812bf:	f01d      	retw.n
400812c1:	000000        	ill

400812c4 <clock_control_esp32_get_status>:
	return 0;
}

static enum clock_control_status clock_control_esp32_get_status(const struct device *dev,
								clock_control_subsys_t sys)
{
400812c4:	004136        	entry	a1, 32
	ARG_UNUSED(dev);
	uint32_t bank = GET_REG_BANK(sys);
400812c7:	418530        	srli	a8, a3, 5
	uint32_t offset =  GET_REG_OFFSET(sys);

	if (DPORT_GET_PERI_REG_MASK(clock_control_regs[bank].clk, BIT(offset))) {
400812ca:	1198d0        	slli	a9, a8, 3
400812cd:	fcd581        	l32r	a8, 40080624 <_iram_text_start+0xd4>
400812d0:	889a      	add.n	a8, a8, a9
 * @return Value
 */
static inline uint32_t IRAM_ATTR DPORT_READ_PERI_REG(uint32_t reg)
{
#if defined(BOOTLOADER_BUILD) || defined(CONFIG_FREERTOS_UNICORE) || !defined(ESP_PLATFORM)
    return _DPORT_REG_READ(reg);
400812d2:	0828      	l32i.n	a2, a8, 0
		return CLOCK_CONTROL_STATUS_ON;
	}
	return CLOCK_CONTROL_STATUS_OFF;
}
400812d4:	180c      	movi.n	a8, 1
400812d6:	0020c0        	memw
400812d9:	0228      	l32i.n	a2, a2, 0
	if (DPORT_GET_PERI_REG_MASK(clock_control_regs[bank].clk, BIT(offset))) {
400812db:	400300        	ssr	a3
400812de:	912020        	srl	a2, a2
400812e1:	043020        	extui	a3, a2, 0, 1
}
400812e4:	220c      	movi.n	a2, 2
400812e6:	832830        	moveqz	a2, a8, a3
400812e9:	f01d      	retw.n
	...

400812ec <clock_control_esp32_get_rate>:

static int clock_control_esp32_get_rate(const struct device *dev,
					clock_control_subsys_t sub_system,
					uint32_t *rate)
{
400812ec:	004136        	entry	a1, 32
	ARG_UNUSED(sub_system);

	uint32_t xtal_freq_sel = DEV_CFG(dev)->xtal_freq_sel;
	uint32_t soc_clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_SOC_CLK_SEL);
400812ef:	fcce81        	l32r	a8, 40080628 <_iram_text_start+0xd8>
400812f2:	0020c0        	memw
400812f5:	0888      	l32i.n	a8, a8, 0
400812f7:	158b80        	extui	a8, a8, 27, 2

	switch (soc_clk_sel) {
400812fa:	688c      	beqz.n	a8, 40081304 <clock_control_esp32_get_rate+0x18>
400812fc:	020c      	movi.n	a2, 0
400812fe:	171826        	beqi	a8, 1, 40081319 <clock_control_esp32_get_rate+0x2d>
40081301:	000706        	j	40081321 <clock_control_esp32_get_rate+0x35>
	uint32_t xtal_freq_sel = DEV_CFG(dev)->xtal_freq_sel;
40081304:	1228      	l32i.n	a2, a2, 4
	case RTC_CNTL_SOC_CLK_SEL_XTL:
		*rate = xtal_freq[xtal_freq_sel];
40081306:	2228      	l32i.n	a2, a2, 8
40081308:	1192e0        	slli	a9, a2, 2
4008130b:	fcc821        	l32r	a2, 4008062c <_iram_text_start+0xdc>
4008130e:	229a      	add.n	a2, a2, a9
40081310:	0228      	l32i.n	a2, a2, 0
40081312:	0429      	s32i.n	a2, a4, 0
		return 0;
40081314:	082d      	mov.n	a2, a8
40081316:	000306        	j	40081326 <clock_control_esp32_get_rate+0x3a>
	case RTC_CNTL_SOC_CLK_SEL_PLL:
		*rate = MHZ(80);
40081319:	fcc581        	l32r	a8, 40080630 <_iram_text_start+0xe0>
4008131c:	0489      	s32i.n	a8, a4, 0
		return 0;
4008131e:	000106        	j	40081326 <clock_control_esp32_get_rate+0x3a>
	default:
		*rate = 0;
40081321:	0429      	s32i.n	a2, a4, 0
		return -ENOTSUP;
40081323:	ddaf22        	movi	a2, -35
	}
}
40081326:	f01d      	retw.n

40081328 <clock_control_esp32_init>:

static int clock_control_esp32_init(const struct device *dev)
{
40081328:	004136        	entry	a1, 32
	struct esp32_clock_config *cfg = DEV_CFG(dev);
4008132b:	1238      	l32i.n	a3, a2, 4

	/* Wait for UART first before changing freq to avoid garbage on console */
	esp32_rom_uart_tx_wait_idle(0);
4008132d:	0a0c      	movi.n	a10, 0
4008132f:	fccd81        	l32r	a8, 40080664 <_iram_text_start+0x114>
40081332:	0008e0        	callx8	a8

	switch (cfg->clk_src_sel) {
40081335:	0368      	l32i.n	a6, a3, 0
40081337:	968c      	beqz.n	a6, 40081344 <clock_control_esp32_init+0x1c>
		break;
	case ESP32_CLK_SRC_PLL:
		cpuclk_pll_configure(cfg->xtal_freq_sel, cfg->cpu_freq);
		break;
	default:
		return -EINVAL;
40081339:	a26c      	movi.n	a2, -22
	switch (cfg->clk_src_sel) {
4008133b:	021626        	beqi	a6, 1, 40081341 <clock_control_esp32_init+0x19>
4008133e:	006ec6        	j	400814fd <clock_control_esp32_init+0x1d5>
40081341:	001186        	j	4008138b <clock_control_esp32_init+0x63>
		REG_SET_FIELD(APB_CTRL_SYSCLK_CONF_REG, APB_CTRL_PRE_DIV_CNT, cfg->xtal_div);
40081344:	fcbc51        	l32r	a5, 40080634 <_iram_text_start+0xe4>
40081347:	3328      	l32i.n	a2, a3, 12
40081349:	0020c0        	memw
4008134c:	0548      	l32i.n	a4, a5, 0
4008134e:	00ac62        	movi	a6, 0xfffffc00
40081351:	104460        	and	a4, a4, a6
40081354:	942020        	extui	a2, a2, 0, 10
40081357:	202240        	or	a2, a2, a4
4008135a:	0020c0        	memw
4008135d:	0529      	s32i.n	a2, a5, 0
		REG_WRITE(APB_CTRL_XTAL_TICK_CONF_REG, xtal_freq[cfg->xtal_freq_sel] - 1);
4008135f:	2328      	l32i.n	a2, a3, 8
		REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_SOC_CLK_SEL, RTC_CNTL_SOC_CLK_SEL_XTL);
40081361:	fcb651        	l32r	a5, 4008063c <_iram_text_start+0xec>
		REG_WRITE(APB_CTRL_XTAL_TICK_CONF_REG, xtal_freq[cfg->xtal_freq_sel] - 1);
40081364:	1142e0        	slli	a4, a2, 2
40081367:	fcb121        	l32r	a2, 4008062c <_iram_text_start+0xdc>
4008136a:	224a      	add.n	a2, a2, a4
4008136c:	0228      	l32i.n	a2, a2, 0
4008136e:	fcb241        	l32r	a4, 40080638 <_iram_text_start+0xe8>
40081371:	220b      	addi.n	a2, a2, -1
40081373:	0020c0        	memw
40081376:	0429      	s32i.n	a2, a4, 0
		REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_SOC_CLK_SEL, RTC_CNTL_SOC_CLK_SEL_XTL);
40081378:	fcac41        	l32r	a4, 40080628 <_iram_text_start+0xd8>
4008137b:	0020c0        	memw
4008137e:	0428      	l32i.n	a2, a4, 0
40081380:	102250        	and	a2, a2, a5
40081383:	0020c0        	memw
40081386:	0429      	s32i.n	a2, a4, 0
		break;
40081388:	0051c6        	j	400814d3 <clock_control_esp32_init+0x1ab>
		cpuclk_pll_configure(cfg->xtal_freq_sel, cfg->cpu_freq);
4008138b:	1328      	l32i.n	a2, a3, 4
	switch (cpu_freq) {
4008138d:	a0a042        	movi	a4, 160
		cpuclk_pll_configure(cfg->xtal_freq_sel, cfg->cpu_freq);
40081390:	2378      	l32i.n	a7, a3, 8
	switch (cpu_freq) {
40081392:	0c1247        	beq	a2, a4, 400813a2 <clock_control_esp32_init+0x7a>
40081395:	f0a052        	movi	a5, 240
		cpu_period_sel = DPORT_CPUPERIOD_SEL_240;
40081398:	240c      	movi.n	a4, 2
	switch (cpu_freq) {
4008139a:	081257        	beq	a2, a5, 400813a6 <clock_control_esp32_init+0x7e>
	uint32_t cpu_period_sel = DPORT_CPUPERIOD_SEL_80;
4008139d:	040c      	movi.n	a4, 0
4008139f:	000046        	j	400813a4 <clock_control_esp32_init+0x7c>
		cpu_period_sel = DPORT_CPUPERIOD_SEL_160;
400813a2:	064d      	mov.n	a4, a6
		pll_freq = RTC_PLL_FREQ_320M;
400813a4:	060c      	movi.n	a6, 0
	CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG,
400813a6:	fca651        	l32r	a5, 40080640 <_iram_text_start+0xf0>
400813a9:	fca681        	l32r	a8, 40080644 <_iram_text_start+0xf4>
400813ac:	0020c0        	memw
400813af:	0528      	l32i.n	a2, a5, 0
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_IR_CAL_DELAY, BBPLL_IR_CAL_DELAY_VAL);
400813b1:	8d1c      	movi.n	a13, 24
	CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG,
400813b3:	102280        	and	a2, a2, a8
400813b6:	0020c0        	memw
400813b9:	0529      	s32i.n	a2, a5, 0
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_IR_CAL_DELAY, BBPLL_IR_CAL_DELAY_VAL);
400813bb:	0c0c      	movi.n	a12, 0
400813bd:	04a0b2        	movi	a11, 4
400813c0:	66a0a2        	movi	a10, 102
400813c3:	fca981        	l32r	a8, 40080668 <_iram_text_start+0x118>
400813c6:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_IR_CAL_EXT_CAP, BBPLL_IR_CAL_EXT_CAP_VAL);
400813c9:	0d2c      	movi.n	a13, 32
400813cb:	1c0c      	movi.n	a12, 1
400813cd:	04a0b2        	movi	a11, 4
400813d0:	66a0a2        	movi	a10, 102
400813d3:	fca581        	l32r	a8, 40080668 <_iram_text_start+0x118>
400813d6:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_OC_ENB_FCAL, BBPLL_OC_ENB_FCAL_VAL);
400813d9:	4c0c      	movi.n	a12, 4
400813db:	0cbd      	mov.n	a11, a12
400813dd:	9aa0d2        	movi	a13, 154
400813e0:	66a0a2        	movi	a10, 102
400813e3:	fca181        	l32r	a8, 40080668 <_iram_text_start+0x118>
400813e6:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_OC_ENB_VCON, BBPLL_OC_ENB_VCON_VAL);
400813e9:	0d0c      	movi.n	a13, 0
400813eb:	ac0c      	movi.n	a12, 10
400813ed:	4b0c      	movi.n	a11, 4
400813ef:	66a0a2        	movi	a10, 102
400813f2:	fc9d81        	l32r	a8, 40080668 <_iram_text_start+0x118>
400813f5:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_BBADC_CAL_7_0, BBPLL_BBADC_CAL_7_0_VAL);
400813f8:	0d0c      	movi.n	a13, 0
400813fa:	cc0c      	movi.n	a12, 12
400813fc:	4b0c      	movi.n	a11, 4
400813fe:	66a0a2        	movi	a10, 102
40081401:	fc9981        	l32r	a8, 40080668 <_iram_text_start+0x118>
40081404:	0008e0        	callx8	a8
	REG_SET_FIELD(RTC_CNTL_REG, RTC_CNTL_DIG_DBIAS_WAK, dbias_wak);
40081407:	fc9021        	l32r	a2, 40080648 <_iram_text_start+0xf8>
4008140a:	fc9081        	l32r	a8, 4008064c <_iram_text_start+0xfc>
4008140d:	0020c0        	memw
40081410:	0258      	l32i.n	a5, a2, 0
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_ENDIV5, cfg->endiv5);
40081412:	bc0c      	movi.n	a12, 11
	REG_SET_FIELD(RTC_CNTL_REG, RTC_CNTL_DIG_DBIAS_WAK, dbias_wak);
40081414:	105580        	and	a5, a5, a8
40081417:	fc8e81        	l32r	a8, 40080650 <_iram_text_start+0x100>
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_ENDIV5, cfg->endiv5);
4008141a:	4b0c      	movi.n	a11, 4
	REG_SET_FIELD(RTC_CNTL_REG, RTC_CNTL_DIG_DBIAS_WAK, dbias_wak);
4008141c:	205580        	or	a5, a5, a8
4008141f:	0020c0        	memw
40081422:	0259      	s32i.n	a5, a2, 0
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_ENDIV5, cfg->endiv5);
40081424:	fc8c51        	l32r	a5, 40080654 <_iram_text_start+0x104>
40081427:	1126c0        	slli	a2, a6, 4
4008142a:	c06260        	sub	a6, a2, a6
4008142d:	256a      	add.n	a2, a5, a6
4008142f:	0102d2        	l8ui	a13, a2, 1
40081432:	66a0a2        	movi	a10, 102
40081435:	fc8c81        	l32r	a8, 40080668 <_iram_text_start+0x118>
40081438:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_BBADC_DSMP, cfg->bbadc_dsmp);
4008143b:	0202d2        	l8ui	a13, a2, 2
	uint8_t i2c_bbpll_lref = (bb_cfg->lref << 7) | (bb_cfg->div10_8 << 4) | (bb_cfg->div_ref);
4008143e:	1127f0        	slli	a2, a7, 1
40081441:	227a      	add.n	a2, a2, a7
40081443:	1122f0        	slli	a2, a2, 1
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_BBADC_DSMP, cfg->bbadc_dsmp);
40081446:	9c0c      	movi.n	a12, 9
40081448:	4b0c      	movi.n	a11, 4
4008144a:	66a0a2        	movi	a10, 102
	uint8_t i2c_bbpll_lref = (bb_cfg->lref << 7) | (bb_cfg->div10_8 << 4) | (bb_cfg->div_ref);
4008144d:	226a      	add.n	a2, a2, a6
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_BBADC_DSMP, cfg->bbadc_dsmp);
4008144f:	fc8681        	l32r	a8, 40080668 <_iram_text_start+0x118>
40081452:	0008e0        	callx8	a8
	uint8_t i2c_bbpll_lref = (bb_cfg->lref << 7) | (bb_cfg->div10_8 << 4) | (bb_cfg->div_ref);
40081455:	252a      	add.n	a2, a5, a2
40081457:	0602d2        	l8ui	a13, a2, 6
4008145a:	050252        	l8ui	a5, a2, 5
4008145d:	11dd90        	slli	a13, a13, 7
40081460:	1155c0        	slli	a5, a5, 4
40081463:	20dd50        	or	a13, a13, a5
40081466:	030252        	l8ui	a5, a2, 3
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_OC_LREF, i2c_bbpll_lref);
40081469:	2c0c      	movi.n	a12, 2
	uint8_t i2c_bbpll_lref = (bb_cfg->lref << 7) | (bb_cfg->div10_8 << 4) | (bb_cfg->div_ref);
4008146b:	20dd50        	or	a13, a13, a5
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_OC_LREF, i2c_bbpll_lref);
4008146e:	74d0d0        	extui	a13, a13, 0, 8
40081471:	4b0c      	movi.n	a11, 4
40081473:	66a0a2        	movi	a10, 102
40081476:	fc7c81        	l32r	a8, 40080668 <_iram_text_start+0x118>
40081479:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_OC_DIV_7_0, bb_cfg->div7_0);
4008147c:	0402d2        	l8ui	a13, a2, 4
4008147f:	3c0c      	movi.n	a12, 3
40081481:	4b0c      	movi.n	a11, 4
40081483:	66a0a2        	movi	a10, 102
40081486:	fc7881        	l32r	a8, 40080668 <_iram_text_start+0x118>
40081489:	0008e0        	callx8	a8
	I2C_WRITEREG_RTC(I2C_BBPLL, I2C_BBPLL_OC_DCUR, ((bb_cfg->bw << 6) | bb_cfg->dcur));
4008148c:	0802d2        	l8ui	a13, a2, 8
4008148f:	070222        	l8ui	a2, a2, 7
40081492:	11dda0        	slli	a13, a13, 6
40081495:	20dd20        	or	a13, a13, a2
40081498:	74d0d0        	extui	a13, a13, 0, 8
4008149b:	5c0c      	movi.n	a12, 5
4008149d:	4b0c      	movi.n	a11, 4
4008149f:	66a0a2        	movi	a10, 102
400814a2:	fc7181        	l32r	a8, 40080668 <_iram_text_start+0x118>
400814a5:	0008e0        	callx8	a8
	DPORT_REG_WRITE(DPORT_CPU_PER_CONF_REG, cpu_period_sel);
400814a8:	fc6c21        	l32r	a2, 40080658 <_iram_text_start+0x108>
	REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_SOC_CLK_SEL, RTC_CNTL_SOC_CLK_SEL_PLL);
400814ab:	fc6451        	l32r	a5, 4008063c <_iram_text_start+0xec>
	DPORT_REG_WRITE(DPORT_CPU_PER_CONF_REG, cpu_period_sel);
400814ae:	0020c0        	memw
400814b1:	0249      	s32i.n	a4, a2, 0
	REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_SOC_CLK_SEL, RTC_CNTL_SOC_CLK_SEL_PLL);
400814b3:	fc5d41        	l32r	a4, 40080628 <_iram_text_start+0xd8>
400814b6:	0020c0        	memw
400814b9:	0428      	l32i.n	a2, a4, 0
400814bb:	102250        	and	a2, a2, a5
400814be:	fc6751        	l32r	a5, 4008065c <_iram_text_start+0x10c>
400814c1:	202250        	or	a2, a2, a5
400814c4:	0020c0        	memw
400814c7:	0429      	s32i.n	a2, a4, 0
	REG_WRITE(APB_CTRL_PLL_TICK_CONF_REG, PLL_APB_CLK_FREQ - 1);
400814c9:	fc6521        	l32r	a2, 40080660 <_iram_text_start+0x110>
400814cc:	f44c      	movi.n	a4, 79
400814ce:	0020c0        	memw
400814d1:	0249      	s32i.n	a4, a2, 0

	/* Re-calculate the CCOUNT register value to make time calculation correct.
	 * This should be updated on each frequency change
	 * New CCOUNT = Current CCOUNT * (new freq / old freq)
	 */
	XTHAL_SET_CCOUNT((uint64_t)XTHAL_GET_CCOUNT() * cfg->cpu_freq / xtal_freq[cfg->xtal_freq_sel]);
400814d3:	03ea40        	rsr.ccount	a4
400814d6:	13a8      	l32i.n	a10, a3, 4
400814d8:	2338      	l32i.n	a3, a3, 8
400814da:	312f40        	srai	a2, a4, 31
400814dd:	1153e0        	slli	a5, a3, 2
400814e0:	fc5331        	l32r	a3, 4008062c <_iram_text_start+0xdc>
400814e3:	8222a0        	mull	a2, a2, a10
400814e6:	a2ba40        	muluh	a11, a10, a4
400814e9:	335a      	add.n	a3, a3, a5
400814eb:	03c8      	l32i.n	a12, a3, 0
400814ed:	82aa40        	mull	a10, a10, a4
400814f0:	0d0c      	movi.n	a13, 0
400814f2:	80b2b0        	add	a11, a2, a11
400814f5:	025625        	call8	40083a58 <__udivdi3>
400814f8:	13eaa0        	wsr.ccount	a10
	return 0;
400814fb:	020c      	movi.n	a2, 0
}
400814fd:	f01d      	retw.n
	...

40081500 <clock_control_esp32_off>:
{
40081500:	004136        	entry	a1, 32
	uint32_t bank = GET_REG_BANK(sys);
40081503:	419530        	srli	a9, a3, 5
	esp32_clear_mask32(BIT(offset), clock_control_regs[bank].clk);
40081506:	180c      	movi.n	a8, 1
40081508:	401300        	ssl	a3
4008150b:	a13800        	sll	a3, a8
4008150e:	1189d0        	slli	a8, a9, 3
40081511:	fc4491        	l32r	a9, 40080624 <_iram_text_start+0xd4>
}
40081514:	020c      	movi.n	a2, 0
	esp32_clear_mask32(BIT(offset), clock_control_regs[bank].clk);
40081516:	998a      	add.n	a9, a9, a8
	return *(volatile uint32_t *)addr;
40081518:	09a8      	l32i.n	a10, a9, 0
4008151a:	f87c      	movi.n	a8, -1
4008151c:	0020c0        	memw
4008151f:	0ab8      	l32i.n	a11, a10, 0
40081521:	308830        	xor	a8, a8, a3
40081524:	1088b0        	and	a8, a8, a11
	*(volatile uint32_t *)addr = data;
40081527:	0020c0        	memw
4008152a:	0a89      	s32i.n	a8, a10, 0
	return *(volatile uint32_t *)addr;
4008152c:	1988      	l32i.n	a8, a9, 4
4008152e:	0020c0        	memw
40081531:	0898      	l32i.n	a9, a8, 0
	sys_write32(sys_read32(mem_addr) | v, mem_addr);
40081533:	203390        	or	a3, a3, a9
	*(volatile uint32_t *)addr = data;
40081536:	0020c0        	memw
40081539:	0839      	s32i.n	a3, a8, 0
}
4008153b:	f01d      	retw.n
4008153d:	000000        	ill

40081540 <set_reg>:

	return (uint32_t *)(DT_INST_REG_ADDR(0) + off);
}

static int set_reg(uint32_t pin, uint32_t clr_mask, uint32_t set_mask)
{
40081540:	004136        	entry	a1, 32
	if (pin >= ARRAY_SIZE(pin_mux_off)) {
40081543:	782c      	movi.n	a8, 39
	volatile uint32_t *reg = reg_for_pin(pin);
	uint32_t v;

	if (!reg) {
		return -EINVAL;
40081545:	aa6c      	movi.n	a10, -22
	if (pin >= ARRAY_SIZE(pin_mux_off)) {
40081547:	253827        	bltu	a8, a2, 40081570 <set_reg+0x30>
	off = pin_mux_off[pin];
4008154a:	fc4891        	l32r	a9, 4008066c <_iram_text_start+0x11c>
4008154d:	992a      	add.n	a9, a9, a2
4008154f:	000992        	l8ui	a9, a9, 0
	if (!off) {
40081552:	a99c      	beqz.n	a9, 40081570 <set_reg+0x30>
	return (uint32_t *)(DT_INST_REG_ADDR(0) + off);
40081554:	fc4721        	l32r	a2, 40080670 <_iram_text_start+0x120>
	}

	v = *reg;
	v &= ~clr_mask;
40081557:	f87c      	movi.n	a8, -1
	return (uint32_t *)(DT_INST_REG_ADDR(0) + off);
40081559:	992a      	add.n	a9, a9, a2
	v = *reg;
4008155b:	0020c0        	memw
4008155e:	0928      	l32i.n	a2, a9, 0
	v &= ~clr_mask;
40081560:	308830        	xor	a8, a8, a3
40081563:	108820        	and	a8, a8, a2
	v |= set_mask;
40081566:	208840        	or	a8, a8, a4
	*reg = v;
40081569:	0020c0        	memw
4008156c:	0989      	s32i.n	a8, a9, 0

	return 0;
4008156e:	0a0c      	movi.n	a10, 0
}
40081570:	0a2d      	mov.n	a2, a10
40081572:	f01d      	retw.n

40081574 <pinmux_set>:

static int pinmux_set(const struct device *dev, uint32_t pin, uint32_t func)
{
40081574:	004136        	entry	a1, 32
40081577:	20a330        	or	a10, a3, a3
	 * value due to a deficiency in the pinmux API.  This setting is
	 * part of the GPIO API.
	 */

	if (func > 6) {
		return -EINVAL;
4008157a:	eaaf22        	movi	a2, -22
	if (func > 6) {
4008157d:	1174f6        	bgeui	a4, 7, 40081592 <pinmux_set+0x1e>
	}

	return set_reg(pin, MCU_SEL_M, func<<MCU_SEL_S | 2<<FUN_DRV_S);
40081580:	fc3dc1        	l32r	a12, 40080674 <_iram_text_start+0x124>
40081583:	114440        	slli	a4, a4, 12
40081586:	fc3cb1        	l32r	a11, 40080678 <_iram_text_start+0x128>
40081589:	20c4c0        	or	a12, a4, a12
4008158c:	fffb25        	call8	40081540 <set_reg>
4008158f:	202aa0        	or	a2, a10, a10
}
40081592:	f01d      	retw.n

40081594 <pinmux_input>:
	return -EINVAL;
}

#define CFG(id)   ((GPIO_ ## id ## _REG) & 0xff)
static int pinmux_input(const struct device *dev, uint32_t pin, uint8_t func)
{
40081594:	004136        	entry	a1, 32
	static const uint8_t offs[2][3] = {
		{ CFG(ENABLE1_W1TC), CFG(ENABLE1_W1TS), 32 },
		{ CFG(ENABLE_W1TC), CFG(ENABLE_W1TS), 0 },
	};
	const uint8_t *line = offs[pin < 32];
40081597:	f81c      	movi.n	a8, 31
{
40081599:	744040        	extui	a4, a4, 0, 8
	const uint8_t *line = offs[pin < 32];
4008159c:	00a052        	movi	a5, 0
4008159f:	013837        	bltu	a8, a3, 400815a4 <pinmux_input+0x10>
400815a2:	350c      	movi.n	a5, 3
400815a4:	fc3681        	l32r	a8, 4008067c <_iram_text_start+0x12c>
	/* Since PINMUX_INPUT_ENABLED == 1 and PINMUX_OUTPUT_ENABLED == 0,
	 * we can not set a gpio port as input and output at the same time,
	 * So we always set the gpio as input. Thus, the gpio can be used on
	 * I2C drivers for example.
	 */
	r = set_reg(pin, 0, FUN_IE);
400815a7:	00a2c2        	movi	a12, 0x200
400815aa:	0b0c      	movi.n	a11, 0
400815ac:	03ad      	mov.n	a10, a3
	const uint8_t *line = offs[pin < 32];
400815ae:	805580        	add	a5, a5, a8
	r = set_reg(pin, 0, FUN_IE);
400815b1:	fff8e5        	call8	40081540 <set_reg>
	if (func == PINMUX_INPUT_ENABLED) {
400815b4:	051466        	bnei	a4, 1, 400815bd <pinmux_input+0x29>
		reg = (uint32_t *)(DR_REG_GPIO_BASE + line[0]);
400815b7:	000582        	l8ui	a8, a5, 0
400815ba:	000286        	j	400815c8 <pinmux_input+0x34>
	} else if (func == PINMUX_OUTPUT_ENABLED) {
400815bd:	74ec      	bnez.n	a4, 400815e8 <pinmux_input+0x54>
		if (pin >= 34U && pin <= 39U) {
400815bf:	dec342        	addi	a4, a3, -34
400815c2:	2264b6        	bltui	a4, 6, 400815e8 <pinmux_input+0x54>
			/* These pins are input only */
			return -EINVAL;
		}
		reg = (uint32_t *)(DR_REG_GPIO_BASE + line[1]);
400815c5:	010582        	l8ui	a8, a5, 1
400815c8:	fc2e41        	l32r	a4, 40080680 <_iram_text_start+0x130>
400815cb:	884a      	add.n	a8, a8, a4
	} else {
		return -EINVAL;
	}

	if (r < 0) {
400815cd:	019a96        	bltz	a10, 400815ea <pinmux_input+0x56>
		return r;
	}

	*reg = BIT(pin - line[2]);
400815d0:	020542        	l8ui	a4, a5, 2
400815d3:	150c      	movi.n	a5, 1
400815d5:	c03340        	sub	a3, a3, a4
400815d8:	401300        	ssl	a3
400815db:	a13500        	sll	a3, a5
400815de:	0020c0        	memw
400815e1:	0839      	s32i.n	a3, a8, 0

	ARG_UNUSED(dev);
	return 0;
400815e3:	0a0c      	movi.n	a10, 0
400815e5:	000046        	j	400815ea <pinmux_input+0x56>
		return -EINVAL;
400815e8:	aa6c      	movi.n	a10, -22
}
400815ea:	0a2d      	mov.n	a2, a10
400815ec:	f01d      	retw.n
	...

400815f0 <pinmux_initialize>:
	.pullup = pinmux_pullup,
	.input = pinmux_input
};

static int pinmux_initialize(const struct device *device)
{
400815f0:	004136        	entry	a1, 32
	uint32_t pin;

	for (pin = 0U; pin < ARRAY_SIZE(pin_mux_off); pin++) {
400815f3:	020c      	movi.n	a2, 0
		pinmux_set(NULL, pin, 0);
400815f5:	203220        	or	a3, a2, a2
400815f8:	20b220        	or	a11, a2, a2
400815fb:	20c330        	or	a12, a3, a3
400815fe:	20a330        	or	a10, a3, a3
40081601:	fff725        	call8	40081574 <pinmux_set>
	for (pin = 0U; pin < ARRAY_SIZE(pin_mux_off); pin++) {
40081604:	221b      	addi.n	a2, a2, 1
40081606:	882c      	movi.n	a8, 40
40081608:	ec9287        	bne	a2, a8, 400815f8 <pinmux_initialize+0x8>
	}

	ARG_UNUSED(device);
	return 0;
}
4008160b:	020c      	movi.n	a2, 0
4008160d:	f01d      	retw.n
	...

40081610 <pinmux_pullup>:
{
40081610:	004136        	entry	a1, 32
40081613:	744040        	extui	a4, a4, 0, 8
40081616:	03ad      	mov.n	a10, a3
	switch (func) {
40081618:	848c      	beqz.n	a4, 40081624 <pinmux_pullup+0x14>
4008161a:	0f1426        	beqi	a4, 1, 4008162d <pinmux_pullup+0x1d>
	return -EINVAL;
4008161d:	aa6c      	movi.n	a10, -22
4008161f:	0004c6        	j	40081636 <pinmux_pullup+0x26>
40081622:	c20000        	quou	a0, a0, a0
		return set_reg(pin, FUN_PU, FUN_PD);
40081625:	b280a0        	mulsh	a8, a0, a10
40081628:	4600a1        	l32r	a10, 40052e28 <esp32_rom_gpio_matrix_out+0x48f1c>
4008162b:	c20001        	l32r	a0, 40071e2c <esp32_rom_gpio_matrix_out+0x67f20>
		return set_reg(pin, FUN_PD, FUN_PU);
4008162e:	b200a1        	l32r	a10, 4006de30 <esp32_rom_gpio_matrix_out+0x63f24>
40081631:	e580a0        	extui	a8, a10, 16, 15
40081634:	2dfff0        	lsi	f15, a15, 180
}
40081637:	1d0a      	add.n	a1, a13, a0
40081639:	0000f0        	callx12	a0

4008163c <pinmux_get>:
{
4008163c:	004136        	entry	a1, 32
	if (pin >= ARRAY_SIZE(pin_mux_off)) {
4008163f:	782c      	movi.n	a8, 39
		return -EINVAL;
40081641:	a26c      	movi.n	a2, -22
	if (pin >= ARRAY_SIZE(pin_mux_off)) {
40081643:	1d3837        	bltu	a8, a3, 40081664 <pinmux_get+0x28>
	off = pin_mux_off[pin];
40081646:	fc0921        	l32r	a2, 4008066c <_iram_text_start+0x11c>
40081649:	223a      	add.n	a2, a2, a3
4008164b:	000282        	l8ui	a8, a2, 0
		return -EINVAL;
4008164e:	a26c      	movi.n	a2, -22
	if (!off) {
40081650:	089c      	beqz.n	a8, 40081664 <pinmux_get+0x28>
	return (uint32_t *)(DT_INST_REG_ADDR(0) + off);
40081652:	fc0721        	l32r	a2, 40080670 <_iram_text_start+0x120>
40081655:	882a      	add.n	a8, a8, a2
	*func = (*reg & MCU_SEL_M) >> MCU_SEL_S;
40081657:	0020c0        	memw
4008165a:	0828      	l32i.n	a2, a8, 0
4008165c:	242c20        	extui	a2, a2, 12, 3
4008165f:	0429      	s32i.n	a2, a4, 0
	return 0;
40081661:	00a022        	movi	a2, 0
}
40081664:	f01d      	retw.n
	...

40081668 <ccompare_isr>:
	__asm__ volatile ("rsr.CCOUNT %0" : "=r"(val));
	return val;
}

static void ccompare_isr(const void *arg)
{
40081668:	004136        	entry	a1, 32
	z_xt_ints_off(1 << irq);
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4008166b:	0063c0        	rsil	a12, 3
	__asm__ volatile ("rsr.CCOUNT %0" : "=r"(val));
4008166e:	03eaa0        	rsr.ccount	a10
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t curr = ccount();
	uint32_t dticks = (curr - last_count) / CYC_PER_TICK;
40081671:	fc0491        	l32r	a9, 40080684 <_iram_text_start+0x134>
40081674:	fc0581        	l32r	a8, 40080688 <_iram_text_start+0x138>
40081677:	0029b2        	l32i	a11, a9, 0
4008167a:	c0aab0        	sub	a10, a10, a11
4008167d:	a2aa80        	muluh	a10, a10, a8

	last_count += dticks * CYC_PER_TICK;
40081680:	fc0381        	l32r	a8, 4008068c <_iram_text_start+0x13c>
	uint32_t dticks = (curr - last_count) / CYC_PER_TICK;
40081683:	41a9a0        	srli	a10, a10, 9
	last_count += dticks * CYC_PER_TICK;
40081686:	828a80        	mull	a8, a10, a8
40081689:	8088b0        	add	a8, a8, a11
4008168c:	006982        	s32i	a8, a9, 0
	return key;
}

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	XTOS_RESTORE_INTLEVEL(key);
4008168f:	13e6c0        	wsr.ps	a12
40081692:	002010        	rsync
		}
		set_ccompare(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
40081695:	01f5a5        	call8	400835f0 <z_clock_announce>
}
40081698:	f01d      	retw.n
	...

4008169c <z_clock_driver_init>:

int z_clock_driver_init(const struct device *device)
{
4008169c:	004136        	entry	a1, 32
	__asm__ volatile ("rsr.CCOUNT %0" : "=r"(val));
4008169f:	03ea80        	rsr.ccount	a8
	ARG_UNUSED(device);

	IRQ_CONNECT(TIMER_IRQ, 0, ccompare_isr, 0, 0);
	set_ccompare(ccount() + CYC_PER_TICK);
400816a2:	fbfa91        	l32r	a9, 4008068c <_iram_text_start+0x13c>
400816a5:	889a      	add.n	a8, a8, a9
	__asm__ volatile ("wsr.CCOMPARE" STRINGIFY(CONFIG_XTENSA_TIMER_ID) " %0"
400816a7:	13f180        	wsr.ccompare1	a8
 */
static inline void z_xt_ints_on(unsigned int mask)
{
	int val;

	__asm__ volatile("rsr.intenable %0" : "=r"(val));
400816aa:	03e480        	rsr.intenable	a8
	val |= mask;
400816ad:	fbf891        	l32r	a9, 40080690 <_iram_text_start+0x140>
400816b0:	208890        	or	a8, a8, a9
	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(val));
400816b3:	13e480        	wsr.intenable	a8
400816b6:	002010        	rsync
	irq_enable(TIMER_IRQ);
	return 0;
}
400816b9:	020c      	movi.n	a2, 0
400816bb:	f01d      	retw.n
400816bd:	000000        	ill

400816c0 <z_clock_set_timeout>:

void z_clock_set_timeout(int32_t ticks, bool idle)
{
400816c0:	004136        	entry	a1, 32
	ARG_UNUSED(idle);

#if defined(CONFIG_TICKLESS_KERNEL)
	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
400816c3:	020266        	bnei	a2, -1, 400816c9 <z_clock_set_timeout+0x9>
400816c6:	fbf321        	l32r	a2, 40080694 <_iram_text_start+0x144>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400816c9:	0063c0        	rsil	a12, 3
	__asm__ volatile ("rsr.CCOUNT %0" : "=r"(val));
400816cc:	03eab0        	rsr.ccount	a11

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t curr = ccount(), cyc, adj;

	/* Round up to next tick boundary */
	cyc = ticks * CYC_PER_TICK;
400816cf:	080c      	movi.n	a8, 0
	ticks = MAX(MIN(ticks - 1, (int32_t)MAX_TICKS), 0);
400816d1:	220b      	addi.n	a2, a2, -1
	cyc = ticks * CYC_PER_TICK;
400816d3:	532280        	max	a2, a2, a8
400816d6:	fbef81        	l32r	a8, 40080694 <_iram_text_start+0x144>
	adj = (curr - last_count) + (CYC_PER_TICK - 1);
400816d9:	fbefa1        	l32r	a10, 40080698 <_iram_text_start+0x148>
	cyc = ticks * CYC_PER_TICK;
400816dc:	432280        	min	a2, a2, a8
	adj = (curr - last_count) + (CYC_PER_TICK - 1);
400816df:	fbe981        	l32r	a8, 40080684 <_iram_text_start+0x134>
	cyc = ticks * CYC_PER_TICK;
400816e2:	fbead1        	l32r	a13, 4008068c <_iram_text_start+0x13c>
	adj = (curr - last_count) + (CYC_PER_TICK - 1);
400816e5:	0898      	l32i.n	a9, a8, 0
	cyc = ticks * CYC_PER_TICK;
400816e7:	8222d0        	mull	a2, a2, a13
	adj = (curr - last_count) + (CYC_PER_TICK - 1);
400816ea:	c0aa90        	sub	a10, a10, a9
400816ed:	aaba      	add.n	a10, a10, a11
	if (cyc <= MAX_CYC - adj) {
400816ef:	f87c      	movi.n	a8, -1
400816f1:	30e8a0        	xor	a14, a8, a10
400816f4:	013e27        	bltu	a14, a2, 400816f9 <z_clock_set_timeout+0x39>
		cyc += adj;
400816f7:	82aa      	add.n	a8, a2, a10
	} else {
		cyc = MAX_CYC;
	}
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
400816f9:	fbe321        	l32r	a2, 40080688 <_iram_text_start+0x138>
400816fc:	a28820        	muluh	a8, a8, a2
	cyc += last_count;

	if ((cyc - curr) < MIN_DELAY) {
400816ff:	e7a322        	movi	a2, 0x3e7
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
40081702:	418980        	srli	a8, a8, 9
40081705:	8288d0        	mull	a8, a8, a13
	cyc += last_count;
40081708:	808980        	add	a8, a9, a8
	if ((cyc - curr) < MIN_DELAY) {
4008170b:	c0b8b0        	sub	a11, a8, a11
4008170e:	0232b7        	bltu	a2, a11, 40081714 <z_clock_set_timeout+0x54>
		cyc += CYC_PER_TICK;
40081711:	8088d0        	add	a8, a8, a13
	__asm__ volatile ("wsr.CCOMPARE" STRINGIFY(CONFIG_XTENSA_TIMER_ID) " %0"
40081714:	13f180        	wsr.ccompare1	a8
	XTOS_RESTORE_INTLEVEL(key);
40081717:	13e6c0        	wsr.ps	a12
4008171a:	002010        	rsync
	}

	set_ccompare(cyc);
	k_spin_unlock(&lock, key);
#endif
}
4008171d:	f01d      	retw.n
	...

40081720 <z_clock_elapsed>:

uint32_t z_clock_elapsed(void)
{
40081720:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40081723:	006380        	rsil	a8, 3
	__asm__ volatile ("rsr.CCOUNT %0" : "=r"(val));
40081726:	03ea20        	rsr.ccount	a2
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (ccount() - last_count) / CYC_PER_TICK;
40081729:	fbd691        	l32r	a9, 40080684 <_iram_text_start+0x134>
4008172c:	0998      	l32i.n	a9, a9, 0
4008172e:	c02290        	sub	a2, a2, a9
40081731:	fbd591        	l32r	a9, 40080688 <_iram_text_start+0x138>
40081734:	a22290        	muluh	a2, a2, a9
40081737:	412920        	srli	a2, a2, 9
	XTOS_RESTORE_INTLEVEL(key);
4008173a:	13e680        	wsr.ps	a8
4008173d:	002010        	rsync

	k_spin_unlock(&lock, key);
	return ret;
}
40081740:	f01d      	retw.n
	...

40081744 <z_xtensa_fatal_error>:
	return "na";
#endif
}

void z_xtensa_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
40081744:	004136        	entry	a1, 32
	if (esf) {
40081747:	338c      	beqz.n	a3, 4008174e <z_xtensa_fatal_error+0xa>
		z_xtensa_dump_stack(esf);
40081749:	03ad      	mov.n	a10, a3
4008174b:	0203a5        	call8	40083784 <z_xtensa_dump_stack>
	}

	z_fatal_error(reason, esf);
4008174e:	20b330        	or	a11, a3, a3
40081751:	20a220        	or	a10, a2, a2
40081754:	010925        	call8	400827e8 <z_fatal_error>
}
40081757:	000090        	retw
	...

4008175c <xtensa_spill_reg_windows>:
        SPILL_ALL_WINDOWS
4008175c:	10ccc0        	and	a12, a12, a12
4008175f:	408030        	rotw	3
40081762:	10ccc0        	and	a12, a12, a12
40081765:	408030        	rotw	3
40081768:	10ccc0        	and	a12, a12, a12
4008176b:	408030        	rotw	3
4008176e:	10ccc0        	and	a12, a12, a12
40081771:	408030        	rotw	3
40081774:	10ccc0        	and	a12, a12, a12
40081777:	408040        	rotw	4
        ret
4008177a:	f00d      	ret.n

4008177c <xtensa_save_high_regs>:
	rsr.WINDOWSTART a2
4008177c:	034920        	rsr.windowstart	a2
	slli a3, a2, (XCHAL_NUM_AREGS / 4)
4008177f:	113200        	slli	a3, a2, 16
	or a2, a2, a3
40081782:	202230        	or	a2, a2, a3
	rsr.WINDOWBASE a3
40081785:	034830        	rsr.windowbase	a3
	ssr a3
40081788:	400300        	ssr	a3
	srl a2, a2
4008178b:	912020        	srl	a2, a2
	mov a3, a1 /* Stash our original stack pointer */
4008178e:	013d      	mov.n	a3, a1
	bbsi a2, 1, _high_gpr_spill_done
40081790:	28e217        	bbsi	a2, 1, 400817bc <_high_gpr_spill_done>
	addi a1, a1, -16
40081793:	f0c112        	addi	a1, a1, -16
	s32i a4, a1, 0
40081796:	0149      	s32i.n	a4, a1, 0
	s32i a5, a1, 4
40081798:	1159      	s32i.n	a5, a1, 4
	s32i a6, a1, 8
4008179a:	2169      	s32i.n	a6, a1, 8
	s32i a7, a1, 12
4008179c:	3179      	s32i.n	a7, a1, 12
	bbsi a2, 2, _high_gpr_spill_done
4008179e:	1ae227        	bbsi	a2, 2, 400817bc <_high_gpr_spill_done>
	addi a1, a1, -16
400817a1:	f0c112        	addi	a1, a1, -16
	s32i a8, a1, 0
400817a4:	0189      	s32i.n	a8, a1, 0
	s32i a9, a1, 4
400817a6:	1199      	s32i.n	a9, a1, 4
	s32i a10, a1, 8
400817a8:	21a9      	s32i.n	a10, a1, 8
	s32i a11, a1, 12
400817aa:	31b9      	s32i.n	a11, a1, 12
	bbsi a2, 3, _high_gpr_spill_done
400817ac:	0ce237        	bbsi	a2, 3, 400817bc <_high_gpr_spill_done>
	addi a1, a1, -16
400817af:	f0c112        	addi	a1, a1, -16
	s32i a12, a1, 0
400817b2:	01c9      	s32i.n	a12, a1, 0
	s32i a13, a1, 4
400817b4:	11d9      	s32i.n	a13, a1, 4
	s32i a14, a1, 8
400817b6:	0261e2        	s32i	a14, a1, 8
	s32i a15, a1, 12
400817b9:	0361f2        	s32i	a15, a1, 12

400817bc <_high_gpr_spill_done>:
	addi a1, a1, -4
400817bc:	fcc112        	addi	a1, a1, -4
	s32i a3, a1, 0
400817bf:	0139      	s32i.n	a3, a1, 0
	ret
400817c1:	f00d      	ret.n
	...

400817c4 <xtensa_restore_high_regs>:
	l32i a2, a1, 0
400817c4:	0128      	l32i.n	a2, a1, 0
	addi a1, a1, 4
400817c6:	114b      	addi.n	a1, a1, 4
	mov a3, a2
400817c8:	023d      	mov.n	a3, a2
	beq a1, a2, _high_restore_done
400817ca:	261127        	beq	a1, a2, 400817f4 <_high_restore_done>
	addi a2, a2, -16
400817cd:	f0c222        	addi	a2, a2, -16
	l32i a4, a2, 0
400817d0:	0248      	l32i.n	a4, a2, 0
	l32i a5, a2, 4
400817d2:	1258      	l32i.n	a5, a2, 4
	l32i a6, a2, 8
400817d4:	2268      	l32i.n	a6, a2, 8
	l32i a7, a2, 12
400817d6:	3278      	l32i.n	a7, a2, 12
	beq a1, a2, _high_restore_done
400817d8:	181127        	beq	a1, a2, 400817f4 <_high_restore_done>
	addi a2, a2, -16
400817db:	f0c222        	addi	a2, a2, -16
	l32i a8, a2, 0
400817de:	0288      	l32i.n	a8, a2, 0
	l32i a9, a2, 4
400817e0:	1298      	l32i.n	a9, a2, 4
	l32i a10, a2, 8
400817e2:	22a8      	l32i.n	a10, a2, 8
	l32i a11, a2, 12
400817e4:	32b8      	l32i.n	a11, a2, 12
	beq a1, a2, _high_restore_done
400817e6:	0a1127        	beq	a1, a2, 400817f4 <_high_restore_done>
	addi a2, a2, -16
400817e9:	f0c222        	addi	a2, a2, -16
	l32i a12, a2, 0
400817ec:	02c8      	l32i.n	a12, a2, 0
	l32i a13, a2, 4
400817ee:	12d8      	l32i.n	a13, a2, 4
	l32i a14, a2, 8
400817f0:	22e8      	l32i.n	a14, a2, 8
	l32i a15, a2, 12
400817f2:	32f8      	l32i.n	a15, a2, 12

400817f4 <_high_restore_done>:
	mov a1, a3 /* Original stack */
400817f4:	031d      	mov.n	a1, a3
	ret
400817f6:	f00d      	ret.n
	...

400817f9 <_restore_context>:
	call0 xtensa_restore_high_regs
400817f9:	fffc85        	call0	400817c4 <xtensa_restore_high_regs>
	l32i a0, a1, BSA_PC_OFF
400817fc:	6108      	l32i.n	a0, a1, 24
	wsr.EPC6 a0
400817fe:	13b600        	wsr.epc6	a0
	l32i a0, a1, BSA_PS_OFF
40081801:	5108      	l32i.n	a0, a1, 20
	wsr.EPS6 a0
40081803:	13c600        	wsr.eps6	a0
	l32i a0, a1, BSA_SAR_OFF
40081806:	4108      	l32i.n	a0, a1, 16
	wsr.SAR a0
40081808:	130300        	wsr.sar	a0
	l32i a0, a1, BSA_LBEG_OFF
4008180b:	3108      	l32i.n	a0, a1, 12
	wsr.LBEG a0
4008180d:	130000        	wsr.lbeg	a0
	l32i a0, a1, BSA_LEND_OFF
40081810:	2108      	l32i.n	a0, a1, 8
	wsr.LEND a0
40081812:	130100        	wsr.lend	a0
	l32i a0, a1, BSA_LCOUNT_OFF
40081815:	1108      	l32i.n	a0, a1, 4
	wsr.LCOUNT a0
40081817:	130200        	wsr.lcount	a0
	l32i a0, a1, BSA_SCOMPARE1_OFF
4008181a:	0108      	l32i.n	a0, a1, 0
	wsr.SCOMPARE1 a0
4008181c:	130c00        	wsr.scompare1	a0
	rsync
4008181f:	002010        	rsync
	l32i a0, a1, BSA_A0_OFF
40081822:	7108      	l32i.n	a0, a1, 28
	l32i a2, a1, BSA_A2_OFF
40081824:	9128      	l32i.n	a2, a1, 36
	l32i a3, a1, BSA_A3_OFF
40081826:	a138      	l32i.n	a3, a1, 40
	addi a1, a1, BASE_SAVE_AREA_SIZE
40081828:	3cc112        	addi	a1, a1, 60
	rfi 6
4008182b:	003610        	rfi	6
	...

40081830 <xtensa_switch>:
	entry a1, 16
40081830:	002136        	entry	a1, 16
	SPILL_ALL_WINDOWS
40081833:	10ccc0        	and	a12, a12, a12
40081836:	408030        	rotw	3
40081839:	10ccc0        	and	a12, a12, a12
4008183c:	408030        	rotw	3
4008183f:	10ccc0        	and	a12, a12, a12
40081842:	408030        	rotw	3
40081845:	10ccc0        	and	a12, a12, a12
40081848:	408030        	rotw	3
4008184b:	10ccc0        	and	a12, a12, a12
4008184e:	408040        	rotw	4
	addi a1, a1, -BASE_SAVE_AREA_SIZE
40081851:	c4c112        	addi	a1, a1, -60
	s32i a0, a1, BSA_A0_OFF
40081854:	7109      	s32i.n	a0, a1, 28
	s32i a2, a1, BSA_A2_OFF
40081856:	9129      	s32i.n	a2, a1, 36
	s32i a3, a1, BSA_A3_OFF
40081858:	a139      	s32i.n	a3, a1, 40
	ODD_REG_SAVE
4008185a:	030300        	rsr.sar	a0
4008185d:	4109      	s32i.n	a0, a1, 16
4008185f:	030000        	rsr.lbeg	a0
40081862:	3109      	s32i.n	a0, a1, 12
40081864:	030100        	rsr.lend	a0
40081867:	2109      	s32i.n	a0, a1, 8
40081869:	030200        	rsr.lcount	a0
4008186c:	1109      	s32i.n	a0, a1, 4
4008186e:	030c00        	rsr.scompare1	a0
40081871:	0109      	s32i.n	a0, a1, 0
	rsr.PS a0
40081873:	03e600        	rsr.ps	a0
	s32i a0, a1, BSA_PS_OFF
40081876:	5109      	s32i.n	a0, a1, 20
	movi a0, _switch_restore_pc
40081878:	fb8901        	l32r	a0, 4008069c <_iram_text_start+0x14c>
	s32i a0, a1, BSA_PC_OFF
4008187b:	6109      	s32i.n	a0, a1, 24
	call0 xtensa_save_high_regs
4008187d:	ffefc5        	call0	4008177c <xtensa_save_high_regs>
	l32i a2, a1, 0
40081880:	0128      	l32i.n	a2, a1, 0
	l32i a3, a2, BSA_A3_OFF
40081882:	a238      	l32i.n	a3, a2, 40
	s32i a1, a3, 0
40081884:	0319      	s32i.n	a1, a3, 0
	l32i a1, a2, BSA_A2_OFF
40081886:	9218      	l32i.n	a1, a2, 36
	j _restore_context
40081888:	ffdb46        	j	400817f9 <_restore_context>

4008188b <_switch_restore_pc>:
	retw
4008188b:	f01d      	retw.n
4008188d:	000000        	ill

40081890 <_handle_excint>:
	EXCINT_HANDLER CONFIG_XTENSA_KERNEL_CPU_PTR_SR, ___cpu_t_nested_OFFSET, ___cpu_t_irq_stack_OFFSET
40081890:	8129      	s32i.n	a2, a1, 32
40081892:	030300        	rsr.sar	a0
40081895:	4109      	s32i.n	a0, a1, 16
40081897:	030000        	rsr.lbeg	a0
4008189a:	3109      	s32i.n	a0, a1, 12
4008189c:	030100        	rsr.lend	a0
4008189f:	2109      	s32i.n	a0, a1, 8
400818a1:	030200        	rsr.lcount	a0
400818a4:	1109      	s32i.n	a0, a1, 4
400818a6:	030c00        	rsr.scompare1	a0
400818a9:	0109      	s32i.n	a0, a1, 0
400818ab:	ffed05        	call0	4008177c <xtensa_save_high_regs>
400818ae:	0128      	l32i.n	a2, a1, 0
400818b0:	8228      	l32i.n	a2, a2, 32
400818b2:	03e600        	rsr.ps	a0
400818b5:	f30c      	movi.n	a3, 15
400818b7:	100030        	and	a0, a0, a3
400818ba:	a0cc      	bnez.n	a0, 400818c8 <_not_l1>
400818bc:	03e600        	rsr.ps	a0
400818bf:	01a032        	movi	a3, 1
400818c2:	200030        	or	a0, a0, a3
400818c5:	13e600        	wsr.ps	a0

400818c8 <_not_l1>:
400818c8:	03e600        	rsr.ps	a0
400818cb:	f36c      	movi.n	a3, -17
400818cd:	100030        	and	a0, a0, a3
400818d0:	13e600        	wsr.ps	a0
400818d3:	002010        	rsync
400818d6:	03f430        	rsr.misc0	a3
400818d9:	0308      	l32i.n	a0, a3, 0
400818db:	708c      	beqz.n	a0, 400818e6 <_switch_stacks_3>
400818dd:	001b      	addi.n	a0, a0, 1
400818df:	0309      	s32i.n	a0, a3, 0
400818e1:	013d      	mov.n	a3, a1
400818e3:	000146        	j	400818ec <_do_call_3>

400818e6 <_switch_stacks_3>:
400818e6:	001b      	addi.n	a0, a0, 1
400818e8:	0309      	s32i.n	a0, a3, 0
400818ea:	1338      	l32i.n	a3, a3, 4

400818ec <_do_call_3>:
400818ec:	036d      	mov.n	a6, a3
400818ee:	01ad      	mov.n	a10, a1
400818f0:	013d      	mov.n	a3, a1
400818f2:	02bd      	mov.n	a11, a2
400818f4:	0118      	l32i.n	a1, a1, 0
400818f6:	3cc112        	addi	a1, a1, 60
400818f9:	000095        	call4	40081904 <_xstack_call0_5>
400818fc:	031d      	mov.n	a1, a3
400818fe:	062d      	mov.n	a2, a6
40081900:	0003c6        	j	40081913 <_xstack_returned_5>
	...

40081904 <_xstack_call0_5>:
40081904:	002136        	entry	a1, 16
40081907:	021d      	mov.n	a1, a2
40081909:	000055        	call4	40081910 <_xstack_call1_5>
4008190c:	062d      	mov.n	a2, a6
4008190e:	f01d      	retw.n

40081910 <_xstack_call1_5>:
40081910:	0007a0        	jx	a7

40081913 <_xstack_returned_5>:
40081913:	006700        	rsil	a0, 7
40081916:	03f430        	rsr.misc0	a3
40081919:	0308      	l32i.n	a0, a3, 0
4008191b:	000b      	addi.n	a0, a0, -1
4008191d:	0309      	s32i.n	a0, a3, 0
4008191f:	251617        	beq	a6, a1, 40081948 <_restore_3>
40081922:	0118      	l32i.n	a1, a1, 0
40081924:	3cc112        	addi	a1, a1, 60
40081927:	10ccc0        	and	a12, a12, a12
4008192a:	408030        	rotw	3
4008192d:	10ccc0        	and	a12, a12, a12
40081930:	408030        	rotw	3
40081933:	10ccc0        	and	a12, a12, a12
40081936:	408030        	rotw	3
40081939:	10ccc0        	and	a12, a12, a12
4008193c:	408030        	rotw	3
4008193f:	10ccc0        	and	a12, a12, a12
40081942:	408040        	rotw	4
40081945:	201660        	or	a1, a6, a6

40081948 <_restore_3>:
40081948:	ffab46        	j	400817f9 <_restore_context>
	...

4008194c <xtensa_init_stack>:
LOG_MODULE_DECLARE(os);

void *xtensa_init_stack(int *stack_top,
			void (*entry)(void *, void *, void *),
			void *arg1, void *arg2, void *arg3)
{
4008194c:	004136        	entry	a1, 32
	 * arrange to enter the function with a CALLINC of 1 and a
	 * stack pointer 16 bytes above the top, so its ENTRY at the
	 * start will decrement the stack pointer by 16.
	 */
	const int bsasz = BASE_SAVE_AREA_SIZE - 16;
	void **bsa = (void **) (((char *) stack_top) - bsasz);
4008194f:	d4c272        	addi	a7, a2, -44

	(void)memset(bsa, 0, bsasz);
40081952:	cc2c      	movi.n	a12, 44
40081954:	0b0c      	movi.n	a11, 0
40081956:	20a770        	or	a10, a7, a7
40081959:	01e4e5        	call8	400837a8 <memset>

	bsa[BSA_PC_OFF/4] = z_thread_entry;
4008195c:	fb5191        	l32r	a9, 400806a0 <_iram_text_start+0x150>
4008195f:	ecc282        	addi	a8, a2, -20
40081962:	0899      	s32i.n	a9, a8, 0
	bsa[BSA_PS_OFF/4] = (void *)(PS_WOE | PS_UM | PS_CALLINC(1));
40081964:	fb5091        	l32r	a9, 400806a4 <_iram_text_start+0x154>
40081967:	e8c282        	addi	a8, a2, -24
4008196a:	0899      	s32i.n	a9, a8, 0
	/* Arguments to z_thread_entry().  Remember these start at A6,
	 * which will be rotated into A2 by the ENTRY instruction that
	 * begins the C function.  And A4-A7 and A8-A11 are optional
	 * quads that live below the BSA!
	 */
	bsa[-1] = arg1;  /* a7 */
4008196c:	d0c282        	addi	a8, a2, -48
4008196f:	0849      	s32i.n	a4, a8, 0
	bsa[-2] = entry; /* a6 */
40081971:	ccc282        	addi	a8, a2, -52
40081974:	0839      	s32i.n	a3, a8, 0
	bsa[-3] = 0;     /* a5 */
40081976:	c8c292        	addi	a9, a2, -56
40081979:	080c      	movi.n	a8, 0
4008197b:	0989      	s32i.n	a8, a9, 0
	bsa[-4] = 0;     /* a4 */
4008197d:	c4c292        	addi	a9, a2, -60
40081980:	0989      	s32i.n	a8, a9, 0

	bsa[-5] = 0;     /* a11 */
40081982:	c0c292        	addi	a9, a2, -64
40081985:	0989      	s32i.n	a8, a9, 0
	bsa[-6] = 0;     /* a10 */
40081987:	bcc292        	addi	a9, a2, -68
4008198a:	0989      	s32i.n	a8, a9, 0
	bsa[-7] = arg3;  /* a9 */
4008198c:	b8c282        	addi	a8, a2, -72
4008198f:	0869      	s32i.n	a6, a8, 0
	bsa[-8] = arg2;  /* a8 */
40081991:	b4c282        	addi	a8, a2, -76
40081994:	0859      	s32i.n	a5, a8, 0

	/* Finally push the BSA pointer and return the stack pointer
	 * as the handle
	 */
	bsa[-9] = bsa;
40081996:	b0c222        	addi	a2, a2, -80
40081999:	0279      	s32i.n	a7, a2, 0
	return &bsa[-9];
}
4008199b:	f01d      	retw.n
4008199d:	000000        	ill

400819a0 <arch_new_thread>:

void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
400819a0:	004136        	entry	a1, 32
	thread->switch_handle = xtensa_init_stack((int *)stack_ptr, entry,
400819a3:	81e8      	l32i.n	a14, a1, 32
{
400819a5:	07dd      	mov.n	a13, a7
	thread->switch_handle = xtensa_init_stack((int *)stack_ptr, entry,
400819a7:	06cd      	mov.n	a12, a6
400819a9:	05bd      	mov.n	a11, a5
400819ab:	04ad      	mov.n	a10, a4
400819ad:	fff9e5        	call8	4008194c <xtensa_init_stack>
400819b0:	1462a2        	s32i	a10, a2, 80
						  p1, p2, p3);
}
400819b3:	f01d      	retw.n
400819b5:	000000        	ill

400819b8 <z_irq_spurious>:

void z_irq_spurious(const void *arg)
{
400819b8:	004136        	entry	a1, 32
	int irqs, ie;

	ARG_UNUSED(arg);

	__asm__ volatile("rsr.interrupt %0" : "=r"(irqs));
400819bb:	03e280        	rsr.interrupt	a8
	__asm__ volatile("rsr.intenable %0" : "=r"(ie));
400819be:	03e480        	rsr.intenable	a8
	LOG_ERR(" ** Spurious INTERRUPT(s) %p, INTENABLE = %p",
		(void *)irqs, (void *)ie);
	z_xtensa_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
400819c1:	0b0c      	movi.n	a11, 0
400819c3:	1a0c      	movi.n	a10, 1
400819c5:	ffd7e5        	call8	40081744 <z_xtensa_fatal_error>
}
400819c8:	f01d      	retw.n
	...

400819cc <xtensa_int2_c>:
		__asm__ volatile("wsr.intclear %0" : : "r"(m)); \
	}							\
	return z_get_next_switch_handle(interrupted_stack);		\
}

DEF_INT_C_HANDLER(2)
400819cc:	004136        	entry	a1, 32
400819cf:	03e240        	rsr.interrupt	a4
400819d2:	03e430        	rsr.intenable	a3

static inline int _xtensa_handle_one_int2(unsigned int mask)
{
	int irq;

	if (mask & BIT(19)) {
400819d5:	fb3451        	l32r	a5, 400806a8 <_iram_text_start+0x158>
400819d8:	104430        	and	a4, a4, a3
400819db:	0e8457        	bany	a4, a5, 400819ed <xtensa_int2_c+0x21>
		mask = BIT(19);
		irq = 19;
		goto handle_irq;
	}
	if (mask & BIT(20)) {
400819de:	fb3331        	l32r	a3, 400806ac <_iram_text_start+0x15c>
400819e1:	0f8437        	bany	a4, a3, 400819f4 <xtensa_int2_c+0x28>
		mask = BIT(20);
		irq = 20;
		goto handle_irq;
	}
	if (mask & BIT(21)) {
400819e4:	fb3331        	l32r	a3, 400806b0 <_iram_text_start+0x160>
400819e7:	0e8437        	bany	a4, a3, 400819f9 <xtensa_int2_c+0x2d>
400819ea:	000986        	j	40081a14 <xtensa_int2_c+0x48>
		irq = 19;
400819ed:	381c      	movi.n	a8, 19
		mask = BIT(19);
400819ef:	053d      	mov.n	a3, a5
400819f1:	000186        	j	400819fb <xtensa_int2_c+0x2f>
		irq = 20;
400819f4:	481c      	movi.n	a8, 20
400819f6:	000046        	j	400819fb <xtensa_int2_c+0x2f>
		mask = BIT(21);
		irq = 21;
400819f9:	581c      	movi.n	a8, 21
		goto handle_irq;
	}
	return 0;
handle_irq:
	_sw_isr_table[irq].isr(_sw_isr_table[irq].arg);
400819fb:	fb2e91        	l32r	a9, 400806b4 <_iram_text_start+0x164>
400819fe:	1188d0        	slli	a8, a8, 3
40081a01:	898a      	add.n	a8, a9, a8
40081a03:	1898      	l32i.n	a9, a8, 4
40081a05:	08a8      	l32i.n	a10, a8, 0
40081a07:	304430        	xor	a4, a4, a3
40081a0a:	0009e0        	callx8	a9
40081a0d:	13e330        	wsr.intclear	a3
40081a10:	fff1c6        	j	400819db <xtensa_int2_c+0xf>
40081a13:	a22000        	muluh	a2, a0, a0
40081a16:	17e520        	lsi	f2, a5, 92
40081a19:	2aa001        	l32r	a0, 4004c49c <esp32_rom_gpio_matrix_out+0x42590>
40081a1c:	009020        	all4	b2, b0:b1:b2:b3
	...

40081a20 <xtensa_int3_c>:
DEF_INT_C_HANDLER(3)
40081a20:	004136        	entry	a1, 32
40081a23:	03e240        	rsr.interrupt	a4
40081a26:	03e430        	rsr.intenable	a3
40081a29:	104430        	and	a4, a4, a3
	if (mask & 0x408800) {
40081a2c:	fb2631        	l32r	a3, 400806c4 <_iram_text_start+0x174>
40081a2f:	150437        	bnone	a4, a3, 40081a48 <xtensa_int3_c+0x28>
		if (mask & BIT(11)) {
40081a32:	fb1031        	l32r	a3, 40080674 <_iram_text_start+0x124>
40081a35:	268437        	bany	a4, a3, 40081a5f <xtensa_int3_c+0x3f>
		if (mask & BIT(15)) {
40081a38:	fb1631        	l32r	a3, 40080690 <_iram_text_start+0x140>
40081a3b:	258437        	bany	a4, a3, 40081a64 <xtensa_int3_c+0x44>
		if (mask & BIT(22)) {
40081a3e:	fb1e31        	l32r	a3, 400806b8 <_iram_text_start+0x168>
40081a41:	490437        	bnone	a4, a3, 40081a8e <xtensa_int3_c+0x6e>
40081a44:	000846        	j	40081a69 <xtensa_int3_c+0x49>
40081a47:	1d3100        	lsi	f0, a1, 116
		if (mask & BIT(23)) {
40081a4a:	37fb      	addi.n	a3, a7, 15
40081a4c:	311f84        	lsi	f8, a15, 196
		if (mask & BIT(27)) {
40081a4f:	37fb03        	lsi	f0, a11, 220
40081a52:	311f84        	lsi	f8, a15, 196
		if (mask & BIT(29)) {
40081a55:	fb1b      	addi.n	a15, a11, 1
40081a57:	330437        	bnone	a4, a3, 40081a8e <xtensa_int3_c+0x6e>
			irq = 29;
40081a5a:	d81c      	movi.n	a8, 29
40081a5c:	000586        	j	40081a76 <xtensa_int3_c+0x56>
			irq = 11;
40081a5f:	b80c      	movi.n	a8, 11
40081a61:	000446        	j	40081a76 <xtensa_int3_c+0x56>
			irq = 15;
40081a64:	f80c      	movi.n	a8, 15
40081a66:	000306        	j	40081a76 <xtensa_int3_c+0x56>
			irq = 22;
40081a69:	681c      	movi.n	a8, 22
40081a6b:	0001c6        	j	40081a76 <xtensa_int3_c+0x56>
			irq = 23;
40081a6e:	781c      	movi.n	a8, 23
40081a70:	000086        	j	40081a76 <xtensa_int3_c+0x56>
40081a73:	b81c00        	lsi	f0, a12, 0x2e0
	_sw_isr_table[irq].isr(_sw_isr_table[irq].arg);
40081a76:	fb0f91        	l32r	a9, 400806b4 <_iram_text_start+0x164>
40081a79:	1188d0        	slli	a8, a8, 3
40081a7c:	898a      	add.n	a8, a9, a8
40081a7e:	1898      	l32i.n	a9, a8, 4
40081a80:	08a8      	l32i.n	a10, a8, 0
40081a82:	304430        	xor	a4, a4, a3
40081a85:	0009e0        	callx8	a9
40081a88:	13e330        	wsr.intclear	a3
40081a8b:	ffe746        	j	40081a2c <xtensa_int3_c+0xc>
40081a8e:	20a220        	or	a10, a2, a2
40081a91:	011025        	call8	40082b94 <z_get_next_switch_handle>
40081a94:	202aa0        	or	a2, a10, a10
40081a97:	000090        	retw
	...

40081a9c <xtensa_int4_c>:
DEF_INT_C_HANDLER(4)
40081a9c:	004136        	entry	a1, 32
40081a9f:	03e240        	rsr.interrupt	a4
40081aa2:	03e430        	rsr.intenable	a3
40081aa5:	104430        	and	a4, a4, a3

static inline int _xtensa_handle_one_int4(unsigned int mask)
{
	int irq;

	if (mask & 0x3000000) {
40081aa8:	fb0c31        	l32r	a3, 400806d8 <_iram_text_start+0x188>
40081aab:	0e0437        	bnone	a4, a3, 40081abd <xtensa_int4_c+0x21>
		if (mask & BIT(24)) {
40081aae:	fb0631        	l32r	a3, 400806c8 <_iram_text_start+0x178>
40081ab1:	198437        	bany	a4, a3, 40081ace <xtensa_int4_c+0x32>
			mask = BIT(24);
			irq = 24;
			goto handle_irq;
		}
		if (mask & BIT(25)) {
40081ab4:	fb0631        	l32r	a3, 400806cc <_iram_text_start+0x17c>
40081ab7:	370437        	bnone	a4, a3, 40081af2 <xtensa_int4_c+0x56>
40081aba:	000546        	j	40081ad3 <xtensa_int4_c+0x37>
			mask = BIT(25);
			irq = 25;
			goto handle_irq;
		}
	} else {
		if (mask & BIT(28)) {
40081abd:	fb0431        	l32r	a3, 400806d0 <_iram_text_start+0x180>
40081ac0:	148437        	bany	a4, a3, 40081ad8 <xtensa_int4_c+0x3c>
			mask = BIT(28);
			irq = 28;
			goto handle_irq;
		}
		if (mask & BIT(30)) {
40081ac3:	fb0431        	l32r	a3, 400806d4 <_iram_text_start+0x184>
40081ac6:	280437        	bnone	a4, a3, 40081af2 <xtensa_int4_c+0x56>
			mask = BIT(30);
			irq = 30;
40081ac9:	e81c      	movi.n	a8, 30
40081acb:	0002c6        	j	40081ada <xtensa_int4_c+0x3e>
			irq = 24;
40081ace:	881c      	movi.n	a8, 24
40081ad0:	000186        	j	40081ada <xtensa_int4_c+0x3e>
			irq = 25;
40081ad3:	981c      	movi.n	a8, 25
40081ad5:	000046        	j	40081ada <xtensa_int4_c+0x3e>
			irq = 28;
40081ad8:	c81c      	movi.n	a8, 28
			goto handle_irq;
		}
	}
	return 0;
handle_irq:
	_sw_isr_table[irq].isr(_sw_isr_table[irq].arg);
40081ada:	faf691        	l32r	a9, 400806b4 <_iram_text_start+0x164>
40081add:	1188d0        	slli	a8, a8, 3
40081ae0:	898a      	add.n	a8, a9, a8
40081ae2:	1898      	l32i.n	a9, a8, 4
40081ae4:	08a8      	l32i.n	a10, a8, 0
40081ae6:	304430        	xor	a4, a4, a3
40081ae9:	0009e0        	callx8	a9
40081aec:	13e330        	wsr.intclear	a3
40081aef:	ffed46        	j	40081aa8 <xtensa_int4_c+0xc>
40081af2:	20a220        	or	a10, a2, a2
40081af5:	0109e5        	call8	40082b94 <z_get_next_switch_handle>
40081af8:	202aa0        	or	a2, a10, a10
40081afb:	000090        	retw
	...

40081b00 <xtensa_int5_c>:
DEF_INT_C_HANDLER(5)
40081b00:	004136        	entry	a1, 32
40081b03:	03e240        	rsr.interrupt	a4
40081b06:	03e430        	rsr.intenable	a3
	if (mask & BIT(16)) {
40081b09:	faf451        	l32r	a5, 400806dc <_iram_text_start+0x18c>
40081b0c:	104430        	and	a4, a4, a3
40081b0f:	0001c6        	j	40081b1a <xtensa_int5_c+0x1a>
40081b12:	300000        	xor	a0, a0, a0
40081b15:	303044        	lsi	f4, a0, 192
40081b18:	5713e3        	lsi	f14, a3, 0x15c
40081b1b:	311084        	lsi	f8, a0, 196
	if (mask & BIT(26)) {
40081b1e:	37faf0        	lsi	f15, a10, 220
40081b21:	d61184        	lsi	f8, a1, 0x358
	if (mask & BIT(31)) {
40081b24:	1c0254        	lsi	f5, a2, 112
		irq = 31;
40081b27:	31f8      	l32i.n	a15, a1, 12
		mask = BIT(31);
40081b29:	ef          	.byte 0xef
40081b2a:	06fa      	add.n	a0, a6, a15
40081b2c:	1c0002        	l8ui	a0, a0, 28
		irq = 16;
40081b2f:	3d08      	l32i.n	a0, a13, 12
		mask = BIT(16);
40081b31:	004605        	call0	40081f94 <i2c_esp32_configure_pins+0x38>
40081b34:	a81c00        	lsi	f0, a12, 0x2a0
	_sw_isr_table[irq].isr(_sw_isr_table[irq].arg);
40081b37:	fadf91        	l32r	a9, 400806b4 <_iram_text_start+0x164>
40081b3a:	1188d0        	slli	a8, a8, 3
40081b3d:	808980        	add	a8, a9, a8
40081b40:	012892        	l32i	a9, a8, 4
40081b43:	0028a2        	l32i	a10, a8, 0
40081b46:	0009e0        	callx8	a9
40081b49:	fc7356        	bnez	a3, 40081b14 <xtensa_int5_c+0x14>
40081b4c:	20a220        	or	a10, a2, a2
40081b4f:	010465        	call8	40082b94 <z_get_next_switch_handle>
40081b52:	202aa0        	or	a2, a10, a10
40081b55:	000090        	retw

40081b58 <xtensa_int6_c>:
DEF_INT_C_HANDLER(6)
40081b58:	004136        	entry	a1, 32
40081b5b:	20a220        	or	a10, a2, a2
40081b5e:	03e280        	rsr.interrupt	a8
40081b61:	03e480        	rsr.intenable	a8
40081b64:	0102e5        	call8	40082b94 <z_get_next_switch_handle>
40081b67:	202aa0        	or	a2, a10, a10
40081b6a:	000090        	retw
40081b6d:	000000        	ill

40081b70 <xtensa_int7_c>:
DEF_INT_C_HANDLER(7)
40081b70:	004136        	entry	a1, 32
40081b73:	03e230        	rsr.interrupt	a3
40081b76:	03e440        	rsr.intenable	a4
40081b79:	103340        	and	a3, a3, a4
	if (mask & BIT(14)) {
40081b7c:	fadb41        	l32r	a4, 400806e8 <_iram_text_start+0x198>
40081b7f:	150347        	bnone	a3, a4, 40081b98 <xtensa_int7_c+0x28>
	_sw_isr_table[irq].isr(_sw_isr_table[irq].arg);
40081b82:	facc81        	l32r	a8, 400806b4 <_iram_text_start+0x164>
40081b85:	303340        	xor	a3, a3, a4
40081b88:	1d2892        	l32i	a9, a8, 116
40081b8b:	1c28a2        	l32i	a10, a8, 112
40081b8e:	0009e0        	callx8	a9
40081b91:	13e340        	wsr.intclear	a4
40081b94:	fff9c6        	j	40081b7f <xtensa_int7_c+0xf>
40081b97:	a22000        	muluh	a2, a0, a0
40081b9a:	ffa520        	f64cmph	a10, a5, a2, 15
40081b9d:	2aa000        	mul.s	f10, f0, f0
40081ba0:	009020        	all4	b2, b0:b1:b2:b3
	...

40081ba4 <xtensa_excint1_c>:
 * DEF_EXCINT 1 vector declaration in assembly code.  This one looks
 * different because exceptions and interrupts land at the same
 * vector; other interrupt levels have their own vectors.
 */
void *xtensa_excint1_c(int *interrupted_stack)
{
40081ba4:	004136        	entry	a1, 32
	int cause, vaddr, *bsa = *(int **)interrupted_stack;

	__asm__ volatile("rsr.exccause %0" : "=r"(cause));
40081ba7:	03e850        	rsr.exccause	a5

	if (cause == EXCCAUSE_LEVEL1_INTERRUPT) {
40081baa:	024526        	beqi	a5, 4, 40081bb0 <xtensa_excint1_c+0xc>
40081bad:	0045c6        	j	40081cc8 <xtensa_excint1_c+0x124>
static inline DEF_INT_C_HANDLER(1)
40081bb0:	03e240        	rsr.interrupt	a4
40081bb3:	03e430        	rsr.intenable	a3
		if (mask & 0x780) {
40081bb6:	80a762        	movi	a6, 0x780
40081bb9:	104430        	and	a4, a4, a3
	if (mask & 0x7f) {
40081bbc:	643040        	extui	a3, a4, 0, 7
40081bbf:	048316        	beqz	a3, 40081c0b <xtensa_excint1_c+0x67>
		if (mask & 0x7) {
40081bc2:	243040        	extui	a3, a4, 0, 3
40081bc5:	739c      	beqz.n	a3, 40081be0 <xtensa_excint1_c+0x3c>
			if (mask & BIT(0)) {
40081bc7:	043040        	extui	a3, a4, 0, 1
40081bca:	09a356        	bnez	a3, 40081c68 <xtensa_excint1_c+0xc4>
			if (mask & BIT(1)) {
40081bcd:	290c      	movi.n	a9, 2
40081bcf:	020497        	bnone	a4, a9, 40081bd5 <xtensa_excint1_c+0x31>
40081bd2:	0025c6        	j	40081c6d <xtensa_excint1_c+0xc9>
			if (mask & BIT(2)) {
40081bd5:	430c      	movi.n	a3, 4
40081bd7:	028437        	bany	a4, a3, 40081bdd <xtensa_excint1_c+0x39>
40081bda:	004186        	j	40081ce4 <xtensa_excint1_c+0x140>
40081bdd:	0024c6        	j	40081c74 <xtensa_excint1_c+0xd0>
			if (mask & 0x18) {
40081be0:	831c      	movi.n	a3, 24
40081be2:	120437        	bnone	a4, a3, 40081bf8 <xtensa_excint1_c+0x54>
				if (mask & BIT(3)) {
40081be5:	830c      	movi.n	a3, 8
40081be7:	020437        	bnone	a4, a3, 40081bed <xtensa_excint1_c+0x49>
40081bea:	0022c6        	j	40081c79 <xtensa_excint1_c+0xd5>
				if (mask & BIT(4)) {
40081bed:	031c      	movi.n	a3, 16
40081bef:	028437        	bany	a4, a3, 40081bf5 <xtensa_excint1_c+0x51>
40081bf2:	003b86        	j	40081ce4 <xtensa_excint1_c+0x140>
40081bf5:	002186        	j	40081c7f <xtensa_excint1_c+0xdb>
				if (mask & BIT(5)) {
40081bf8:	032c      	movi.n	a3, 32
40081bfa:	020437        	bnone	a4, a3, 40081c00 <xtensa_excint1_c+0x5c>
40081bfd:	0020c6        	j	40081c84 <xtensa_excint1_c+0xe0>
				if (mask & BIT(6)) {
40081c00:	034c      	movi.n	a3, 64
40081c02:	028437        	bany	a4, a3, 40081c08 <xtensa_excint1_c+0x64>
40081c05:	0036c6        	j	40081ce4 <xtensa_excint1_c+0x140>
40081c08:	001f46        	j	40081c89 <xtensa_excint1_c+0xe5>
		if (mask & 0x780) {
40081c0b:	2d0467        	bnone	a4, a6, 40081c3c <xtensa_excint1_c+0x98>
			if (mask & 0x180) {
40081c0e:	80a132        	movi	a3, 0x180
40081c11:	130437        	bnone	a4, a3, 40081c28 <xtensa_excint1_c+0x84>
				if (mask & BIT(7)) {
40081c14:	80a032        	movi	a3, 128
40081c17:	738437        	bany	a4, a3, 40081c8e <xtensa_excint1_c+0xea>
				if (mask & BIT(8)) {
40081c1a:	00a132        	movi	a3, 0x100
40081c1d:	028437        	bany	a4, a3, 40081c23 <xtensa_excint1_c+0x7f>
40081c20:	003006        	j	40081ce4 <xtensa_excint1_c+0x140>
40081c23:	001b06        	j	40081c93 <xtensa_excint1_c+0xef>
40081c26:	320000        	orbc	b0, b0, b0
				if (mask & BIT(9)) {
40081c29:	3700a2        	l8ui	a10, a0, 55
40081c2c:	326984        	lsi	f8, a9, 200
				if (mask & BIT(10)) {
40081c2f:	3700a4        	lsi	f10, a0, 220
40081c32:	060284        	lsi	f8, a2, 24
40081c35:	002b      	addi.n	a0, a0, 2
40081c37:	001886        	j	40081c9d <xtensa_excint1_c+0xf9>
40081c3a:	310000        	srai	a0, a0, 16
			if (mask & 0x3000) {
40081c3d:	af          	.byte 0xaf
40081c3e:	37fa      	add.n	a3, a7, a15
40081c40:	311104        	lsi	f0, a1, 196
				if (mask & BIT(12)) {
40081c43:	faaa      	add.n	a15, a10, a10
40081c45:	598437        	bany	a4, a3, 40081ca2 <xtensa_excint1_c+0xfe>
				if (mask & BIT(13)) {
40081c48:	fa8231        	l32r	a3, 40080650 <_iram_text_start+0x100>
40081c4b:	028437        	bany	a4, a3, 40081c51 <xtensa_excint1_c+0xad>
40081c4e:	002486        	j	40081ce4 <xtensa_excint1_c+0x140>
40081c51:	001486        	j	40081ca7 <xtensa_excint1_c+0x103>
				if (mask & BIT(17)) {
40081c54:	faa731        	l32r	a3, 400806f0 <_iram_text_start+0x1a0>
40081c57:	518437        	bany	a4, a3, 40081cac <xtensa_excint1_c+0x108>
				if (mask & BIT(18)) {
40081c5a:	faa631        	l32r	a3, 400806f4 <_iram_text_start+0x1a4>
40081c5d:	028437        	bany	a4, a3, 40081c63 <xtensa_excint1_c+0xbf>
40081c60:	002006        	j	40081ce4 <xtensa_excint1_c+0x140>
					irq = 18;
40081c63:	281c      	movi.n	a8, 18
40081c65:	001146        	j	40081cae <xtensa_excint1_c+0x10a>
				irq = 0;
40081c68:	080c      	movi.n	a8, 0
40081c6a:	001006        	j	40081cae <xtensa_excint1_c+0x10a>
				irq = 1;
40081c6d:	180c      	movi.n	a8, 1
				mask = BIT(1);
40081c6f:	093d      	mov.n	a3, a9
40081c71:	000e46        	j	40081cae <xtensa_excint1_c+0x10a>
				irq = 2;
40081c74:	098d      	mov.n	a8, a9
40081c76:	000d06        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 3;
40081c79:	380c      	movi.n	a8, 3
40081c7b:	000bc6        	j	40081cae <xtensa_excint1_c+0x10a>
40081c7e:	058d00        	extui	a8, a0, 29, 1
					irq = 4;
40081c81:	000a46        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 5;
40081c84:	580c      	movi.n	a8, 5
40081c86:	000906        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 6;
40081c89:	680c      	movi.n	a8, 6
40081c8b:	0007c6        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 7;
40081c8e:	780c      	movi.n	a8, 7
40081c90:	000686        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 8;
40081c93:	880c      	movi.n	a8, 8
40081c95:	000546        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 9;
40081c98:	980c      	movi.n	a8, 9
40081c9a:	000406        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 10;
40081c9d:	a80c      	movi.n	a8, 10
40081c9f:	0002c6        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 12;
40081ca2:	c80c      	movi.n	a8, 12
40081ca4:	000186        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 13;
40081ca7:	d80c      	movi.n	a8, 13
40081ca9:	000046        	j	40081cae <xtensa_excint1_c+0x10a>
					irq = 17;
40081cac:	181c      	movi.n	a8, 17
	_sw_isr_table[irq].isr(_sw_isr_table[irq].arg);
40081cae:	fa8191        	l32r	a9, 400806b4 <_iram_text_start+0x164>
40081cb1:	1188d0        	slli	a8, a8, 3
40081cb4:	898a      	add.n	a8, a9, a8
40081cb6:	1898      	l32i.n	a9, a8, 4
40081cb8:	08a8      	l32i.n	a10, a8, 0
40081cba:	304430        	xor	a4, a4, a3
40081cbd:	0009e0        	callx8	a9
40081cc0:	13e330        	wsr.intclear	a3
40081cc3:	ffbd46        	j	40081bbc <xtensa_excint1_c+0x18>
40081cc6:	660000        	lsi	f0, a0, 0x198

		return xtensa_int1_c(interrupted_stack);

	} else if (cause == EXCCAUSE_SYSCALL) {
40081cc9:	480c15        	call4	400c9d8c <_iram_text_end+0x45e52>
	int cause, vaddr, *bsa = *(int **)interrupted_stack;
40081ccc:	643802        	lsi	f0, a8, 0x190

		/* Xtensa exceptions don't automatically advance PC,
		 * have to skip the SYSCALL instruction manually or
		 * else it will just loop forever
		 */
		bsa[BSA_PC_OFF/4] += 3;
40081ccf:	333b      	addi.n	a3, a3, 3
40081cd1:	6439      	s32i.n	a3, a4, 24
40081cd3:	000346        	j	40081ce4 <xtensa_excint1_c+0x140>
40081cd6:	300000        	xor	a0, a0, a0

	} else {
		uint32_t ps = bsa[BSA_PS_OFF/4];

		__asm__ volatile("rsr.excvaddr %0" : "=r"(vaddr));
40081cd9:	ee          	.byte 0xee
40081cda:	a0a203        	lsi	f0, a2, 0x280
		/* FIXME: legacy xtensa port reported "HW" exception
		 * for all unhandled exceptions, which seems incorrect
		 * as these are software errors.  Should clean this
		 * up.
		 */
		z_xtensa_fatal_error(K_ERR_CPU_EXCEPTION,
40081cdd:	b22000        	mulsh	a2, a0, a0
40081ce0:	a62520        	lsi	f2, a5, 0x298
40081ce3:	ff          	.byte 0xff
				     (void *)interrupted_stack);
	}

	return z_get_next_switch_handle(interrupted_stack);
40081ce4:	02ad      	mov.n	a10, a2
40081ce6:	00eae5        	call8	40082b94 <z_get_next_switch_handle>
}
40081ce9:	0a2d      	mov.n	a2, a10
40081ceb:	f01d      	retw.n
40081ced:	000000        	ill

40081cf0 <__stdout_hook_install>:
}

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
40081cf0:	004136        	entry	a1, 32
	_stdout_hook = hook;
40081cf3:	fa8281        	l32r	a8, 400806fc <_iram_text_start+0x1ac>
40081cf6:	0829      	s32i.n	a2, a8, 0
}
40081cf8:	f01d      	retw.n
	...

40081cfc <gpio_esp32_pin_interrupt_configure>:

static int gpio_esp32_pin_interrupt_configure(const struct device *port,
					      gpio_pin_t pin,
					      enum gpio_int_mode mode,
					      enum gpio_int_trig trig)
{
40081cfc:	004136        	entry	a1, 32
	if (mode == GPIO_INT_MODE_DISABLED) {
40081cff:	fa5481        	l32r	a8, 40080650 <_iram_text_start+0x100>
{
40081d02:	743030        	extui	a3, a3, 0, 8
	if (mode == GPIO_INT_MODE_DISABLED) {
40081d05:	211487        	beq	a4, a8, 40081d2a <gpio_esp32_pin_interrupt_configure+0x2e>
	if (mode == GPIO_INT_MODE_LEVEL) {
40081d08:	fa7891        	l32r	a9, 400806e8 <_iram_text_start+0x198>
			return -ENOTSUP;
40081d0b:	ddaf82        	movi	a8, -35
	if (mode == GPIO_INT_MODE_LEVEL) {
40081d0e:	4f1497        	beq	a4, a9, 40081d61 <gpio_esp32_pin_interrupt_configure+0x65>
		switch (trig) {
40081d11:	fa7841        	l32r	a4, 400806f4 <_iram_text_start+0x1a4>
40081d14:	181547        	beq	a5, a4, 40081d30 <gpio_esp32_pin_interrupt_configure+0x34>
40081d17:	fa7a41        	l32r	a4, 40080700 <_iram_text_start+0x1b0>
40081d1a:	431547        	beq	a5, a4, 40081d61 <gpio_esp32_pin_interrupt_configure+0x65>
40081d1d:	fa7441        	l32r	a4, 400806f0 <_iram_text_start+0x1a0>
			return -EINVAL;
40081d20:	a86c      	movi.n	a8, -22
		switch (trig) {
40081d22:	3b9547        	bne	a5, a4, 40081d61 <gpio_esp32_pin_interrupt_configure+0x65>
			return 2;
40081d25:	280c      	movi.n	a8, 2
40081d27:	0001c6        	j	40081d32 <gpio_esp32_pin_interrupt_configure+0x36>
		return 0;       /* Disables interrupt for a pin. */
40081d2a:	080c      	movi.n	a8, 0
40081d2c:	000086        	j	40081d32 <gpio_esp32_pin_interrupt_configure+0x36>
40081d2f:	180c00        	lsxp	f0, a12, a0
	struct gpio_esp32_data *data = port->data;
	uint32_t io_pin = pin + data->port.pin_offset; /* Range from 0 - 39 */
40081d32:	3248      	l32i.n	a4, a2, 12
40081d34:	8498      	l32i.n	a9, a4, 32
40081d36:	939a      	add.n	a9, a3, a9
	uint32_t *reg = GET_GPIO_PIN_REG(io_pin);
40081d38:	fa7331        	l32r	a3, 40080704 <_iram_text_start+0x1b4>
40081d3b:	993a      	add.n	a9, a9, a3
40081d3d:	1199e0        	slli	a9, a9, 2
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40081d40:	006340        	rsil	a4, 3
	}

	key = irq_lock();

	reg_val = *reg;
	reg_val &= ~(GPIO_PIN_INT_ENA_M | GPIO_PIN_INT_TYPE_M);
40081d43:	fa7151        	l32r	a5, 40080708 <_iram_text_start+0x1b8>
	reg_val = *reg;
40081d46:	0938      	l32i.n	a3, a9, 0
	/* Enable Interrupt on CPU0 (PRO_CPU) */
	reg_val |= GPIO_CPU0_INT_ENABLE;
	/* Interrupt triggering mode */
	reg_val |= intr_trig_mode << GPIO_PIN_INT_TYPE_S;
40081d48:	118890        	slli	a8, a8, 7
	reg_val &= ~(GPIO_PIN_INT_ENA_M | GPIO_PIN_INT_TYPE_M);
40081d4b:	103350        	and	a3, a3, a5
40081d4e:	208830        	or	a8, a8, a3
	reg_val |= intr_trig_mode << GPIO_PIN_INT_TYPE_S;
40081d51:	fa4f31        	l32r	a3, 40080690 <_iram_text_start+0x140>
40081d54:	208830        	or	a8, a8, a3
	*reg = reg_val;
40081d57:	0989      	s32i.n	a8, a9, 0
	XTOS_RESTORE_INTLEVEL(key);
40081d59:	13e640        	wsr.ps	a4
40081d5c:	002010        	rsync

	irq_unlock(key);

	return 0;
40081d5f:	080c      	movi.n	a8, 0
}
40081d61:	082d      	mov.n	a2, a8
40081d63:	f01d      	retw.n
40081d65:	000000        	ill

40081d68 <gpio_esp32_isr>:
#if defined(CONFIG_GPIO_ESP32_1)
GPIO_DEVICE_INIT(1);
#endif

static void gpio_esp32_isr(const void *param)
{
40081d68:	004136        	entry	a1, 32

#if defined(CONFIG_GPIO_ESP32_0)
	gpio_esp32_fire_callbacks(DEVICE_GET(gpio_esp32_0));
40081d6b:	fa68a1        	l32r	a10, 4008070c <_iram_text_start+0x1bc>
40081d6e:	01b7a5        	call8	400838e8 <gpio_esp32_fire_callbacks>
#endif
#if defined(CONFIG_GPIO_ESP32_1)
	gpio_esp32_fire_callbacks(DEVICE_GET(gpio_esp32_1));
40081d71:	fa67a1        	l32r	a10, 40080710 <_iram_text_start+0x1c0>
40081d74:	01b725        	call8	400838e8 <gpio_esp32_fire_callbacks>
#endif

	ARG_UNUSED(param);
}
40081d77:	f01d      	retw.n
40081d79:	000000        	ill

40081d7c <gpio_esp32_init>:
{
40081d7c:	004136        	entry	a1, 32
	struct gpio_esp32_data *data = device->data;
40081d7f:	3228      	l32i.n	a2, a2, 12
40081d81:	fa64a1        	l32r	a10, 40080714 <_iram_text_start+0x1c4>
40081d84:	00a065        	call8	4008278c <z_impl_device_get_binding>
	data->pinmux = device_get_binding(CONFIG_PINMUX_NAME);
40081d87:	12a9      	s32i.n	a10, a2, 4
		return -ENOTSUP;
40081d89:	ddaf22        	movi	a2, -35
	if (!data->pinmux) {
40081d8c:	8abc      	beqz.n	a10, 40081dc8 <gpio_esp32_init+0x4c>
	if (!isr_connected) {
40081d8e:	fa6231        	l32r	a3, 40080718 <_iram_text_start+0x1c8>
	return 0;
40081d91:	020c      	movi.n	a2, 0
	if (!isr_connected) {
40081d93:	000382        	l8ui	a8, a3, 0
40081d96:	2e9827        	bne	a8, a2, 40081dc8 <gpio_esp32_init+0x4c>
 */
static inline void z_xt_ints_off(unsigned int mask)
{
	int val;

	__asm__ volatile("rsr.intenable %0" : "=r"(val));
40081d99:	03e480        	rsr.intenable	a8
	val &= ~mask;
40081d9c:	ffab92        	movi	a9, 0xfffffbff
40081d9f:	108890        	and	a8, a8, a9
	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(val));
40081da2:	13e480        	wsr.intenable	a8
40081da5:	002010        	rsync
		esp32_rom_intr_matrix_set(0, ETS_GPIO_INTR_SOURCE,
40081da8:	ac0c      	movi.n	a12, 10
40081daa:	6b1c      	movi.n	a11, 22
40081dac:	02ad      	mov.n	a10, a2
40081dae:	fa5b81        	l32r	a8, 4008071c <_iram_text_start+0x1cc>
40081db1:	0008e0        	callx8	a8
	__asm__ volatile("rsr.intenable %0" : "=r"(val));
40081db4:	03e480        	rsr.intenable	a8
	val |= mask;
40081db7:	00a492        	movi	a9, 0x400
40081dba:	208890        	or	a8, a8, a9
	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(val));
40081dbd:	13e480        	wsr.intenable	a8
40081dc0:	002010        	rsync
		isr_connected = true;
40081dc3:	180c      	movi.n	a8, 1
40081dc5:	004382        	s8i	a8, a3, 0
}
40081dc8:	f01d      	retw.n
	...

40081dcc <gpio_esp32_config>:
{
40081dcc:	006136        	entry	a1, 48
	struct gpio_esp32_data *data = dev->data;
40081dcf:	3268      	l32i.n	a6, a2, 12
{
40081dd1:	743030        	extui	a3, a3, 0, 8
	r = pinmux_pin_get(data->pinmux, io_pin, &func);
40081dd4:	16a8      	l32i.n	a10, a6, 4
	uint32_t io_pin = pin + data->port.pin_offset; /* Range from 0 - 39 */
40081dd6:	8658      	l32i.n	a5, a6, 32
				 uint32_t *func)
{
	const struct pinmux_driver_api *api =
		(const struct pinmux_driver_api *)dev->api;

	return api->get(dev, pin, func);
40081dd8:	2a28      	l32i.n	a2, a10, 8
40081dda:	535a      	add.n	a5, a3, a5
40081ddc:	1228      	l32i.n	a2, a2, 4
40081dde:	01cd      	mov.n	a12, a1
40081de0:	20b550        	or	a11, a5, a5
40081de3:	0002e0        	callx8	a2
40081de6:	0a2d      	mov.n	a2, a10
	if (r < 0) {
40081de8:	090a96        	bltz	a10, 40081e7c <gpio_esp32_config+0xb0>
	pinmux_pin_set(data->pinmux, io_pin, PIN_FUNC_GPIO);
40081deb:	16a8      	l32i.n	a10, a6, 4
	return api->set(dev, pin, func);
40081ded:	2c0c      	movi.n	a12, 2
40081def:	2a28      	l32i.n	a2, a10, 8
40081df1:	05bd      	mov.n	a11, a5
40081df3:	0228      	l32i.n	a2, a2, 0
40081df5:	0002e0        	callx8	a2
	if (flags & GPIO_PULL_UP) {
40081df8:	0c1c      	movi.n	a12, 16
40081dfa:	10c4c0        	and	a12, a4, a12
40081dfd:	16a8      	l32i.n	a10, a6, 4
40081dff:	9c8c      	beqz.n	a12, 40081e0c <gpio_esp32_config+0x40>
				    uint8_t func)
{
	const struct pinmux_driver_api *api =
		(const struct pinmux_driver_api *)dev->api;

	return api->pullup(dev, pin, func);
40081e01:	2a28      	l32i.n	a2, a10, 8
40081e03:	1c0c      	movi.n	a12, 1
40081e05:	2228      	l32i.n	a2, a2, 8
40081e07:	000206        	j	40081e13 <gpio_esp32_config+0x47>
40081e0a:	570000        	lsi	f0, a0, 0x15c
	} else if (flags & GPIO_PULL_DOWN) {
40081e0d:	280864        	lsi	f6, a8, 160
40081e10:	282a      	add.n	a2, a8, a2
40081e12:	05bd22        	l32ai	a2, a13, 20
40081e15:	0002e0        	callx8	a2
	if (flags & GPIO_OUTPUT) {
40081e18:	16a8      	l32i.n	a10, a6, 4
40081e1a:	2a28      	l32i.n	a2, a10, 8
40081e1c:	3288      	l32i.n	a8, a2, 12
40081e1e:	00a222        	movi	a2, 0x200
40081e21:	102420        	and	a2, a4, a2
40081e24:	04c216        	beqz	a2, 40081e74 <gpio_esp32_config+0xa8>
	uint32_t *reg = GET_GPIO_PIN_REG(io_pin);
40081e27:	fa3721        	l32r	a2, 40080704 <_iram_text_start+0x1b4>
40081e2a:	252a      	add.n	a2, a5, a2
40081e2c:	1122e0        	slli	a2, a2, 2
		if (flags & GPIO_SINGLE_ENDED) {
40081e2f:	0d6417        	bbci	a4, 1, 40081e40 <gpio_esp32_config+0x74>
			if (flags & GPIO_LINE_OPEN_DRAIN) {
40081e32:	4b0c      	movi.n	a11, 4
40081e34:	1104b7        	bnone	a4, a11, 40081e49 <gpio_esp32_config+0x7d>
				*reg |= GPIO_PIN_PAD_DRIVER;
40081e37:	0298      	l32i.n	a9, a2, 0
40081e39:	2099b0        	or	a9, a9, a11
40081e3c:	0001c6        	j	40081e47 <gpio_esp32_config+0x7b>
40081e3f:	029800        	andb	b9, b8, b0
			*reg &= ~GPIO_PIN_PAD_DRIVER;
40081e42:	bb7c      	movi.n	a11, -5
40081e44:	1099b0        	and	a9, a9, a11
40081e47:	0299      	s32i.n	a9, a2, 0
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
40081e49:	0464b7        	bbci	a4, 11, 40081e51 <gpio_esp32_config+0x85>
			*data->port.set_reg = BIT(pin);
40081e4c:	2648      	l32i.n	a4, a6, 8
40081e4e:	000106        	j	40081e56 <gpio_esp32_config+0x8a>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
40081e51:	1064a7        	bbci	a4, 10, 40081e65 <gpio_esp32_config+0x99>
			*data->port.clear_reg = BIT(pin);
40081e54:	3648      	l32i.n	a4, a6, 12
40081e56:	01a022        	movi	a2, 1
40081e59:	401300        	ssl	a3
40081e5c:	a13200        	sll	a3, a2
40081e5f:	0020c0        	memw
40081e62:	006432        	s32i	a3, a4, 0
					  uint8_t func)
{
	const struct pinmux_driver_api *api =
		(const struct pinmux_driver_api *)dev->api;

	return api->input(dev, pin, func);
40081e65:	0c0c      	movi.n	a12, 0
40081e67:	05bd      	mov.n	a11, a5
40081e69:	0008e0        	callx8	a8
		if (r < 0) {
40081e6c:	020c      	movi.n	a2, 0
40081e6e:	432a20        	min	a2, a10, a2
40081e71:	0001c6        	j	40081e7c <gpio_esp32_config+0xb0>
40081e74:	1c0c      	movi.n	a12, 1
40081e76:	20b550        	or	a11, a5, a5
40081e79:	0008e0        	callx8	a8
}
40081e7c:	f01d      	retw.n
	...

40081e80 <i2c_esp32_isr>:

	return ret;
}

static void i2c_esp32_isr(const struct device *device)
{
40081e80:	004136        	entry	a1, 32
	const int fifo_give_mask = I2C_ACK_ERR_INT_ST |
				   I2C_TIME_OUT_INT_ST |
				   I2C_TRANS_COMPLETE_INT_ST |
				   I2C_ARBITRATION_LOST_INT_ST;
	const struct i2c_esp32_config *config = device->config;
40081e83:	012232        	l32i	a3, a2, 4

	if (sys_read32(I2C_INT_STATUS_REG(config->index)) & fifo_give_mask) {
40081e86:	002392        	l32i	a9, a3, 0
40081e89:	1189e0        	slli	a8, a9, 2
40081e8c:	808890        	add	a8, a8, a9
40081e8f:	fa2491        	l32r	a9, 40080720 <_iram_text_start+0x1d0>
40081e92:	118820        	slli	a8, a8, 14
40081e95:	889a      	add.n	a8, a8, a9
	return *(volatile uint32_t *)addr;
40081e97:	0020c0        	memw
40081e9a:	0898      	l32i.n	a9, a8, 0
40081e9c:	a0a582        	movi	a8, 0x5a0
40081e9f:	060987        	bnone	a9, a8, 40081ea9 <i2c_esp32_isr+0x29>

		/* Only give the semaphore if a watched interrupt happens.
		 * Error checking is performed at the other side of the
		 * semaphore, by reading the status register.
		 */
		k_sem_give(&data->fifo_sem);
40081ea2:	32a8      	l32i.n	a10, a2, 12
40081ea4:	aa8b      	addi.n	a10, a10, 8
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
40081ea6:	0132e5        	call8	400831d4 <z_impl_k_sem_give>
	}

	/* Acknowledge all I2C interrupts */
	sys_write32(~0, I2C_INT_CLR_REG(config->index));
40081ea9:	0398      	l32i.n	a9, a3, 0
40081eab:	fa1e21        	l32r	a2, 40080724 <_iram_text_start+0x1d4>
40081eae:	1189e0        	slli	a8, a9, 2
40081eb1:	889a      	add.n	a8, a8, a9
40081eb3:	118820        	slli	a8, a8, 14
40081eb6:	882a      	add.n	a8, a8, a2
	*(volatile uint32_t *)addr = data;
40081eb8:	f27c      	movi.n	a2, -1
40081eba:	0020c0        	memw
40081ebd:	0829      	s32i.n	a2, a8, 0
}
40081ebf:	f01d      	retw.n
40081ec1:	000000        	ill

40081ec4 <i2c_esp32_reset_fifo$isra$0>:
static inline void i2c_esp32_reset_fifo(const struct i2c_esp32_config *config)
40081ec4:	004136        	entry	a1, 32
	uint32_t reg = I2C_FIFO_CONF_REG(config->index);
40081ec7:	1182e0        	slli	a8, a2, 2
40081eca:	282a      	add.n	a2, a8, a2
40081ecc:	fa1781        	l32r	a8, 40080728 <_iram_text_start+0x1d8>
40081ecf:	112220        	slli	a2, a2, 14
40081ed2:	228a      	add.n	a2, a2, a8
	return *(volatile uint32_t *)addr;
40081ed4:	0020c0        	memw
40081ed7:	0288      	l32i.n	a8, a2, 0
40081ed9:	fa0791        	l32r	a9, 400806f8 <_iram_text_start+0x1a8>
40081edc:	208890        	or	a8, a8, a9
	*(volatile uint32_t *)addr = data;
40081edf:	0020c0        	memw
40081ee2:	0289      	s32i.n	a8, a2, 0
	return *(volatile uint32_t *)addr;
40081ee4:	0020c0        	memw
40081ee7:	0288      	l32i.n	a8, a2, 0
	sys_write32(sys_read32(mem_addr) & ~v, mem_addr);
40081ee9:	fa1091        	l32r	a9, 4008072c <_iram_text_start+0x1dc>
40081eec:	108890        	and	a8, a8, a9
	*(volatile uint32_t *)addr = data;
40081eef:	0020c0        	memw
40081ef2:	0289      	s32i.n	a8, a2, 0
}
40081ef4:	f01d      	retw.n
	...

40081ef8 <i2c_esp32_write_addr>:
{
40081ef8:	004136        	entry	a1, 32
	const struct i2c_esp32_config *config = dev->config;
40081efb:	1268      	l32i.n	a6, a2, 4
	struct i2c_esp32_data *data = dev->data;
40081efd:	3278      	l32i.n	a7, a2, 12
	i2c_esp32_reset_fifo(config);
40081eff:	06a8      	l32i.n	a10, a6, 0
40081f01:	fffc25        	call8	40081ec4 <i2c_esp32_reset_fifo$isra$0>
	sys_write32(addr & I2C_FIFO_RDATA, I2C_DATA_APB_REG(config->index));
40081f04:	0628      	l32i.n	a2, a6, 0
40081f06:	748050        	extui	a8, a5, 0, 8
40081f09:	1192e0        	slli	a9, a2, 2
40081f0c:	992a      	add.n	a9, a9, a2
40081f0e:	fa0821        	l32r	a2, 40080730 <_iram_text_start+0x1e0>
40081f11:	119920        	slli	a9, a9, 14
40081f14:	992a      	add.n	a9, a9, a2
40081f16:	0020c0        	memw
40081f19:	0989      	s32i.n	a8, a9, 0
	if (data->dev_config & I2C_ADDR_10_BITS) {
40081f1b:	0788      	l32i.n	a8, a7, 0
	uint32_t addr_len = 1U;
40081f1d:	190c      	movi.n	a9, 1
	if (data->dev_config & I2C_ADDR_10_BITS) {
40081f1f:	156807        	bbci	a8, 0, 40081f38 <i2c_esp32_write_addr+0x40>
		sys_write32(I2C_DATA_APB_REG(config->index),
40081f22:	0668      	l32i.n	a6, a6, 0
			    (addr >> 8) & I2C_FIFO_RDATA);
40081f24:	415850        	srli	a5, a5, 8
		sys_write32(I2C_DATA_APB_REG(config->index),
40081f27:	1186e0        	slli	a8, a6, 2
40081f2a:	886a      	add.n	a8, a8, a6
40081f2c:	118820        	slli	a8, a8, 14
40081f2f:	882a      	add.n	a8, a8, a2
40081f31:	0020c0        	memw
40081f34:	0589      	s32i.n	a8, a5, 0
		addr_len++;
40081f36:	290c      	movi.n	a9, 2
	if ((msg->flags & I2C_MSG_RW_MASK) != I2C_MSG_WRITE) {
40081f38:	080422        	l8ui	a2, a4, 8
40081f3b:	116207        	bbci	a2, 0, 40081f50 <i2c_esp32_write_addr+0x58>
		*cmd++ = (struct i2c_esp32_cmd) {
40081f3e:	940c      	movi.n	a4, 9
40081f40:	114480        	slli	a4, a4, 8
40081f43:	209940        	or	a9, a9, a4
40081f46:	234b      	addi.n	a2, a3, 4
40081f48:	0020c0        	memw
40081f4b:	0399      	s32i.n	a9, a3, 0
40081f4d:	0001c6        	j	40081f58 <i2c_esp32_write_addr+0x60>
		msg->len += addr_len;
40081f50:	1458      	l32i.n	a5, a4, 4
40081f52:	032d      	mov.n	a2, a3
40081f54:	959a      	add.n	a9, a5, a9
40081f56:	1499      	s32i.n	a9, a4, 4
}
40081f58:	f01d      	retw.n
	...

40081f5c <i2c_esp32_configure_pins>:
{
40081f5c:	004136        	entry	a1, 32
#ifndef ZEPHYR_INCLUDE_DRIVERS_GPIO_GPIO_ESP32_H_
#define ZEPHYR_INCLUDE_DRIVERS_GPIO_GPIO_ESP32_H_

static const char *gpio_esp32_get_gpio_for_pin(int pin)
{
	if (pin < 32) {
40081f5f:	1fa052        	movi	a5, 31
		return NULL;
#endif /* CONFIG_GPIO_ESP32_0 */
	}

#if defined(CONFIG_GPIO_ESP32_1)
	return DT_LABEL(DT_INST(1, espressif_esp32_gpio));
40081f62:	f9f4a1        	l32r	a10, 40080734 <_iram_text_start+0x1e4>
	if (pin < 32) {
40081f65:	022527        	blt	a5, a2, 40081f6b <i2c_esp32_configure_pins+0xf>
		return DT_LABEL(DT_INST(0, espressif_esp32_gpio));
40081f68:	f9f4a1        	l32r	a10, 40080738 <_iram_text_start+0x1e8>
40081f6b:	008225        	call8	4008278c <z_impl_device_get_binding>
		return -EINVAL;
40081f6e:	eaaf82        	movi	a8, -22
	if (!gpio) {
40081f71:	047a16        	beqz	a10, 40081fbc <i2c_esp32_configure_pins+0x60>
	ret = gpio_pin_configure(gpio, pin, pin_mode);
40081f74:	746020        	extui	a6, a2, 0, 8
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
40081f77:	032a52        	l32i	a5, a10, 12
	return api->pin_configure(port, pin, flags);
40081f7a:	2a88      	l32i.n	a8, a10, 8
40081f7c:	f9f0c1        	l32r	a12, 4008073c <_iram_text_start+0x1ec>
40081f7f:	0888      	l32i.n	a8, a8, 0
40081f81:	06bd      	mov.n	a11, a6
40081f83:	0008e0        	callx8	a8
40081f86:	0a8d      	mov.n	a8, a10
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
40081f88:	0adc      	bnez.n	a10, 40081f9c <i2c_esp32_configure_pins+0x40>
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
40081f8a:	eb7c      	movi.n	a11, -2
40081f8c:	401600        	ssl	a6
40081f8f:	818bb0        	src	a8, a11, a11
40081f92:	05b8      	l32i.n	a11, a5, 0
40081f94:	10bb80        	and	a11, a11, a8
40081f97:	05b9      	s32i.n	a11, a5, 0
	if (ret < 0) {
40081f99:	000086        	j	40081f9f <i2c_esp32_configure_pins+0x43>
40081f9c:	01ca96        	bltz	a10, 40081fbc <i2c_esp32_configure_pins+0x60>
	esp32_rom_gpio_matrix_out(pin, matrix_out, false, false);
40081f9f:	0d0c      	movi.n	a13, 0
40081fa1:	0dcd      	mov.n	a12, a13
40081fa3:	03bd      	mov.n	a11, a3
40081fa5:	20a220        	or	a10, a2, a2
40081fa8:	f9e681        	l32r	a8, 40080740 <_iram_text_start+0x1f0>
40081fab:	0008e0        	callx8	a8
	esp32_rom_gpio_matrix_in(pin, matrix_in, false);
40081fae:	0c0c      	movi.n	a12, 0
40081fb0:	04bd      	mov.n	a11, a4
40081fb2:	02ad      	mov.n	a10, a2
40081fb4:	f9e481        	l32r	a8, 40080744 <_iram_text_start+0x1f4>
40081fb7:	0008e0        	callx8	a8
40081fba:	080c      	movi.n	a8, 0
}
40081fbc:	082d      	mov.n	a2, a8
40081fbe:	f01d      	retw.n

40081fc0 <i2c_esp32_configure>:
{
40081fc0:	006136        	entry	a1, 48
	const struct i2c_esp32_config *config = dev->config;
40081fc3:	1248      	l32i.n	a4, a2, 4
	struct i2c_esp32_data *data = dev->data;
40081fc5:	3278      	l32i.n	a7, a2, 12
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40081fc7:	006360        	rsil	a6, 3
	ret = i2c_esp32_configure_pins(config->pins.scl,
40081fca:	64c8      	l32i.n	a12, a4, 24
40081fcc:	54b8      	l32i.n	a11, a4, 20
40081fce:	0724a2        	l32i	a10, a4, 28
40081fd1:	fff8a5        	call8	40081f5c <i2c_esp32_configure_pins>
	if (ret < 0) {
40081fd4:	242a96        	bltz	a10, 4008221a <i2c_esp32_configure+0x25a>
	ret = i2c_esp32_configure_pins(config->pins.sda,
40081fd7:	44c8      	l32i.n	a12, a4, 16
40081fd9:	34b8      	l32i.n	a11, a4, 12
40081fdb:	84a8      	l32i.n	a10, a4, 32
40081fdd:	fff7e5        	call8	40081f5c <i2c_esp32_configure_pins>
	if (ret < 0) {
40081fe0:	236a96        	bltz	a10, 4008221a <i2c_esp32_configure+0x25a>
	clock_control_on(data->clock_dev, config->peripheral_id);
40081fe3:	a7a8      	l32i.n	a10, a7, 40
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->api;

	return api->on(dev, sys);
40081fe5:	0924b2        	l32i	a11, a4, 36
40081fe8:	2a58      	l32i.n	a5, a10, 8
40081fea:	002552        	l32i	a5, a5, 0
40081fed:	0005e0        	callx8	a5
	if (config->mode.tx_lsb_first) {
40081ff0:	280492        	l8ui	a9, a4, 40
		v |= I2C_TX_LSB_FIRST;
40081ff3:	084c      	movi.n	a8, 64
40081ff5:	050c      	movi.n	a5, 0
40081ff7:	935890        	movnez	a5, a8, a9
	if (config->mode.rx_lsb_first) {
40081ffa:	290482        	l8ui	a8, a4, 41
40081ffd:	488c      	beqz.n	a8, 40082005 <i2c_esp32_configure+0x45>
		v |= I2C_RX_LSB_FIRST;
40081fff:	80a082        	movi	a8, 128
40082002:	205580        	or	a5, a5, a8
	if (dev_config & I2C_MODE_MASTER) {
40082005:	0498      	l32i.n	a9, a4, 0
40082007:	1189e0        	slli	a8, a9, 2
4008200a:	889a      	add.n	a8, a8, a9
4008200c:	f9cf91        	l32r	a9, 40080748 <_iram_text_start+0x1f8>
4008200f:	118820        	slli	a8, a8, 14
40082012:	889a      	add.n	a8, a8, a9
40082014:	091c      	movi.n	a9, 16
40082016:	0f0397        	bnone	a3, a9, 40082029 <i2c_esp32_configure+0x69>
40082019:	070c      	movi.n	a7, 0
		v |= I2C_MS_MODE;
4008201b:	205590        	or	a5, a5, a9
4008201e:	0020c0        	memw
40082021:	0879      	s32i.n	a7, a8, 0
40082023:	001506        	j	4008207b <i2c_esp32_configure+0xbb>
40082026:	000000        	ill
		uint32_t addr = (data->address & I2C_SLAVE_ADDR_V);
40082029:	021772        	l16ui	a7, a7, 4
4008202c:	e47070        	extui	a7, a7, 0, 15
		if (dev_config & I2C_ADDR_10_BITS) {
4008202f:	056307        	bbci	a3, 0, 40082038 <i2c_esp32_configure+0x78>
			addr |= I2C_ADDR_10BIT_EN;
40082032:	f9ac91        	l32r	a9, 400806e4 <_iram_text_start+0x194>
40082035:	207790        	or	a7, a7, a9
40082038:	0020c0        	memw
4008203b:	0879      	s32i.n	a7, a8, 0
		sys_clear_bit(I2C_CTR_REG(config->index), I2C_TRANS_START_S);
4008203d:	0488      	l32i.n	a8, a4, 0

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
4008203f:	dfaf92        	movi	a9, -33
40082042:	1178e0        	slli	a7, a8, 2
40082045:	778a      	add.n	a7, a7, a8
40082047:	f9c181        	l32r	a8, 4008074c <_iram_text_start+0x1fc>
4008204a:	117720        	slli	a7, a7, 14
4008204d:	778a      	add.n	a7, a7, a8
	uint32_t temp = *(volatile uint32_t *)addr;
4008204f:	0020c0        	memw
40082052:	0788      	l32i.n	a8, a7, 0
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
40082054:	108890        	and	a8, a8, a9
40082057:	0020c0        	memw
4008205a:	0789      	s32i.n	a8, a7, 0
		sys_clear_bit(I2C_FIFO_CONF_REG(config->index),
4008205c:	0488      	l32i.n	a8, a4, 0
4008205e:	f9bc91        	l32r	a9, 40080750 <_iram_text_start+0x200>
40082061:	1178e0        	slli	a7, a8, 2
40082064:	778a      	add.n	a7, a7, a8
40082066:	f9b081        	l32r	a8, 40080728 <_iram_text_start+0x1d8>
40082069:	117720        	slli	a7, a7, 14
4008206c:	778a      	add.n	a7, a7, a8
	uint32_t temp = *(volatile uint32_t *)addr;
4008206e:	0020c0        	memw
40082071:	0788      	l32i.n	a8, a7, 0
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
40082073:	108890        	and	a8, a8, a9
40082076:	0020c0        	memw
40082079:	0789      	s32i.n	a8, a7, 0
	sys_write32(v, I2C_CTR_REG(config->index));
4008207b:	0488      	l32i.n	a8, a4, 0
	v |= I2C_CLK_EN;
4008207d:	03a172        	movi	a7, 0x103
40082080:	205570        	or	a5, a5, a7
	sys_write32(v, I2C_CTR_REG(config->index));
40082083:	1178e0        	slli	a7, a8, 2
40082086:	778a      	add.n	a7, a7, a8
40082088:	f9b181        	l32r	a8, 4008074c <_iram_text_start+0x1fc>
4008208b:	117720        	slli	a7, a7, 14
4008208e:	778a      	add.n	a7, a7, a8
40082090:	0020c0        	memw
40082093:	0759      	s32i.n	a5, a7, 0
	const struct i2c_esp32_config *config = dev->config;
40082095:	1258      	l32i.n	a5, a2, 4
	struct i2c_esp32_data *data = dev->data;
40082097:	3278      	l32i.n	a7, a2, 12
	uint32_t sys_clk_freq = 0;
40082099:	020c      	movi.n	a2, 0
4008209b:	0129      	s32i.n	a2, a1, 0
	ret = i2c_esp32_configure_speed(dev, I2C_SPEED_GET(dev_config));
4008209d:	243130        	extui	a3, a3, 1, 3
	uint32_t freq_hz = speed_to_freq_tbl[speed];
400820a0:	f9ad21        	l32r	a2, 40080754 <_iram_text_start+0x204>
400820a3:	1133e0        	slli	a3, a3, 2
400820a6:	323a      	add.n	a3, a2, a3
400820a8:	0328      	l32i.n	a2, a3, 0
		return -ENOTSUP;
400820aa:	ddafa2        	movi	a10, -35
	if (!freq_hz) {
400820ad:	163216        	beqz	a2, 40082214 <i2c_esp32_configure+0x254>
	if (clock_control_get_rate(data->clock_dev,
400820b0:	a7a8      	l32i.n	a10, a7, 40
		(const struct clock_control_driver_api *)dev->api;

	__ASSERT(api->get_rate != NULL, "%s not implemented for device %s",
		__func__, dev->name);

	return api->get_rate(dev, sys, rate);
400820b2:	95b8      	l32i.n	a11, a5, 36
400820b4:	2a38      	l32i.n	a3, a10, 8
400820b6:	01cd      	mov.n	a12, a1
400820b8:	3338      	l32i.n	a3, a3, 12
400820ba:	0003e0        	callx8	a3
400820bd:	151a56        	bnez	a10, 40082212 <i2c_esp32_configure+0x252>
		   I2C_SCL_LOW_PERIOD_REG(config->index));
400820c0:	0578      	l32i.n	a7, a5, 0
	period = (sys_clk_freq / freq_hz);
400820c2:	0188      	l32i.n	a8, a1, 0
400820c4:	c28820        	quou	a8, a8, a2
		   I2C_SCL_LOW_PERIOD_REG(config->index));
400820c7:	1127e0        	slli	a2, a7, 2
400820ca:	227a      	add.n	a2, a2, a7
400820cc:	f9a371        	l32r	a7, 40080758 <_iram_text_start+0x208>
400820cf:	112220        	slli	a2, a2, 14
400820d2:	227a      	add.n	a2, a2, a7
	return *(volatile uint32_t *)addr;
400820d4:	0020c0        	memw
400820d7:	0278      	l32i.n	a7, a2, 0
	period /= 2U; /* Set hold and setup times to 1/2th of period */
400820d9:	413180        	srli	a3, a8, 1
	sys_write32(sys_read32(mem_addr) | v, mem_addr);
400820dc:	207370        	or	a7, a3, a7
	*(volatile uint32_t *)addr = data;
400820df:	0020c0        	memw
400820e2:	0279      	s32i.n	a7, a2, 0
		   I2C_SCL_HIGH_PERIOD_REG(config->index));
400820e4:	0578      	l32i.n	a7, a5, 0
	period /= 2U; /* Set sample and hold times to 1/4th of period */
400820e6:	418280        	srli	a8, a8, 2
		   I2C_SCL_HIGH_PERIOD_REG(config->index));
400820e9:	1127e0        	slli	a2, a7, 2
400820ec:	227a      	add.n	a2, a2, a7
400820ee:	f99b71        	l32r	a7, 4008075c <_iram_text_start+0x20c>
400820f1:	112220        	slli	a2, a2, 14
400820f4:	227a      	add.n	a2, a2, a7
	return *(volatile uint32_t *)addr;
400820f6:	0020c0        	memw
400820f9:	0278      	l32i.n	a7, a2, 0
400820fb:	207370        	or	a7, a3, a7
	*(volatile uint32_t *)addr = data;
400820fe:	0020c0        	memw
40082101:	0279      	s32i.n	a7, a2, 0
		   I2C_SCL_START_HOLD_REG(config->index));
40082103:	0578      	l32i.n	a7, a5, 0
40082105:	1127e0        	slli	a2, a7, 2
40082108:	227a      	add.n	a2, a2, a7
4008210a:	f99571        	l32r	a7, 40080760 <_iram_text_start+0x210>
4008210d:	112220        	slli	a2, a2, 14
40082110:	227a      	add.n	a2, a2, a7
	return *(volatile uint32_t *)addr;
40082112:	0020c0        	memw
40082115:	0278      	l32i.n	a7, a2, 0
40082117:	207370        	or	a7, a3, a7
	*(volatile uint32_t *)addr = data;
4008211a:	0020c0        	memw
4008211d:	0279      	s32i.n	a7, a2, 0
		   I2C_SCL_RSTART_SETUP_REG(config->index));
4008211f:	0578      	l32i.n	a7, a5, 0
40082121:	1127e0        	slli	a2, a7, 2
40082124:	227a      	add.n	a2, a2, a7
40082126:	f98f71        	l32r	a7, 40080764 <_iram_text_start+0x214>
40082129:	112220        	slli	a2, a2, 14
4008212c:	227a      	add.n	a2, a2, a7
	return *(volatile uint32_t *)addr;
4008212e:	0020c0        	memw
40082131:	0278      	l32i.n	a7, a2, 0
40082133:	207370        	or	a7, a3, a7
	*(volatile uint32_t *)addr = data;
40082136:	0020c0        	memw
40082139:	0279      	s32i.n	a7, a2, 0
		   I2C_SCL_STOP_HOLD_REG(config->index));
4008213b:	0578      	l32i.n	a7, a5, 0
4008213d:	1127e0        	slli	a2, a7, 2
40082140:	227a      	add.n	a2, a2, a7
40082142:	f98971        	l32r	a7, 40080768 <_iram_text_start+0x218>
40082145:	112220        	slli	a2, a2, 14
40082148:	227a      	add.n	a2, a2, a7
	return *(volatile uint32_t *)addr;
4008214a:	0020c0        	memw
4008214d:	0278      	l32i.n	a7, a2, 0
4008214f:	207370        	or	a7, a3, a7
	*(volatile uint32_t *)addr = data;
40082152:	0020c0        	memw
40082155:	0279      	s32i.n	a7, a2, 0
		   I2C_SCL_STOP_SETUP_REG(config->index));
40082157:	0578      	l32i.n	a7, a5, 0
40082159:	1127e0        	slli	a2, a7, 2
4008215c:	227a      	add.n	a2, a2, a7
4008215e:	f98371        	l32r	a7, 4008076c <_iram_text_start+0x21c>
40082161:	112220        	slli	a2, a2, 14
40082164:	227a      	add.n	a2, a2, a7
	return *(volatile uint32_t *)addr;
40082166:	0020c0        	memw
40082169:	0278      	l32i.n	a7, a2, 0
4008216b:	203370        	or	a3, a3, a7
	*(volatile uint32_t *)addr = data;
4008216e:	0020c0        	memw
40082171:	0239      	s32i.n	a3, a2, 0
		   I2C_SDA_HOLD_REG(config->index));
40082173:	0538      	l32i.n	a3, a5, 0
40082175:	1123e0        	slli	a2, a3, 2
40082178:	223a      	add.n	a2, a2, a3
4008217a:	f97d31        	l32r	a3, 40080770 <_iram_text_start+0x220>
4008217d:	112220        	slli	a2, a2, 14
40082180:	223a      	add.n	a2, a2, a3
	return *(volatile uint32_t *)addr;
40082182:	0020c0        	memw
40082185:	0238      	l32i.n	a3, a2, 0
40082187:	203830        	or	a3, a8, a3
	*(volatile uint32_t *)addr = data;
4008218a:	0020c0        	memw
4008218d:	0239      	s32i.n	a3, a2, 0
		   I2C_SDA_SAMPLE_REG(config->index));
4008218f:	0538      	l32i.n	a3, a5, 0
40082191:	ffab52        	movi	a5, 0xfffffbff
40082194:	1123e0        	slli	a2, a3, 2
40082197:	223a      	add.n	a2, a2, a3
40082199:	f97631        	l32r	a3, 40080774 <_iram_text_start+0x224>
4008219c:	112220        	slli	a2, a2, 14
4008219f:	223a      	add.n	a2, a2, a3
	return *(volatile uint32_t *)addr;
400821a1:	0020c0        	memw
400821a4:	0238      	l32i.n	a3, a2, 0
400821a6:	208830        	or	a8, a8, a3
	*(volatile uint32_t *)addr = data;
400821a9:	0020c0        	memw
400821ac:	0289      	s32i.n	a8, a2, 0
	sys_clear_bit(I2C_FIFO_CONF_REG(config->index), I2C_NONFIFO_EN_S);
400821ae:	0438      	l32i.n	a3, a4, 0
400821b0:	1123e0        	slli	a2, a3, 2
400821b3:	223a      	add.n	a2, a2, a3
400821b5:	f95c31        	l32r	a3, 40080728 <_iram_text_start+0x1d8>
400821b8:	112220        	slli	a2, a2, 14
400821bb:	223a      	add.n	a2, a2, a3
	uint32_t temp = *(volatile uint32_t *)addr;
400821bd:	0020c0        	memw
400821c0:	0238      	l32i.n	a3, a2, 0
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
400821c2:	103350        	and	a3, a3, a5
400821c5:	0020c0        	memw
400821c8:	0239      	s32i.n	a3, a2, 0
	sys_write32(v << I2C_TIME_OUT_REG_S, I2C_TO_REG(config->index));
400821ca:	0438      	l32i.n	a3, a4, 0
400821cc:	1123e0        	slli	a2, a3, 2
400821cf:	223a      	add.n	a2, a2, a3
400821d1:	f96931        	l32r	a3, 40080778 <_iram_text_start+0x228>
400821d4:	112220        	slli	a2, a2, 14
400821d7:	223a      	add.n	a2, a2, a3
400821d9:	f96831        	l32r	a3, 4008077c <_iram_text_start+0x22c>
400821dc:	0020c0        	memw
400821df:	0239      	s32i.n	a3, a2, 0
		    I2C_INT_ENA_REG(config->index));
400821e1:	0438      	l32i.n	a3, a4, 0
400821e3:	1123e0        	slli	a2, a3, 2
400821e6:	223a      	add.n	a2, a2, a3
400821e8:	f96631        	l32r	a3, 40080780 <_iram_text_start+0x230>
400821eb:	112220        	slli	a2, a2, 14
400821ee:	223a      	add.n	a2, a2, a3
400821f0:	a0a532        	movi	a3, 0x5a0
400821f3:	0020c0        	memw
400821f6:	0239      	s32i.n	a3, a2, 0
	__asm__ volatile("rsr.intenable %0" : "=r"(val));
400821f8:	03e430        	rsr.intenable	a3
	z_xt_ints_on(1 << irq);
400821fb:	c448      	l32i.n	a4, a4, 48
400821fd:	120c      	movi.n	a2, 1
400821ff:	401400        	ssl	a4
40082202:	a12200        	sll	a2, a2
	val |= mask;
40082205:	202230        	or	a2, a2, a3
	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(val));
40082208:	13e420        	wsr.intenable	a2
4008220b:	002010        	rsync
4008220e:	000086        	j	40082214 <i2c_esp32_configure+0x254>
40082211:	aa6c00        	floor.s	a6, f12, 0
	XTOS_RESTORE_INTLEVEL(key);
40082214:	13e660        	wsr.ps	a6
40082217:	002010        	rsync
}
4008221a:	0a2d      	mov.n	a2, a10
4008221c:	f01d      	retw.n
	...

40082220 <i2c_esp32_transmit>:
{
40082220:	004136        	entry	a1, 32
	const struct i2c_esp32_config *config = dev->config;
40082223:	1238      	l32i.n	a3, a2, 4
	struct i2c_esp32_data *data = dev->data;
40082225:	32a8      	l32i.n	a10, a2, 12
	sys_set_bit(I2C_CTR_REG(config->index), I2C_TRANS_START_S);
40082227:	0328      	l32i.n	a2, a3, 0
	*(volatile uint32_t *)addr = temp | (1 << bit);
40082229:	092c      	movi.n	a9, 32
4008222b:	1182e0        	slli	a8, a2, 2
4008222e:	882a      	add.n	a8, a8, a2
40082230:	f94721        	l32r	a2, 4008074c <_iram_text_start+0x1fc>
40082233:	118820        	slli	a8, a8, 14
40082236:	882a      	add.n	a8, a8, a2
	uint32_t temp = *(volatile uint32_t *)addr;
40082238:	0020c0        	memw
4008223b:	0828      	l32i.n	a2, a8, 0
	*(volatile uint32_t *)addr = temp | (1 << bit);
4008223d:	202290        	or	a2, a2, a9
40082240:	0020c0        	memw
40082243:	0829      	s32i.n	a2, a8, 0
	return z_impl_k_sem_take(sem, timeout);
40082245:	f94fc1        	l32r	a12, 40080784 <_iram_text_start+0x234>
40082248:	f8ccd1        	l32r	a13, 40080578 <_iram_text_start+0x28>
4008224b:	aa8b      	addi.n	a10, a10, 8
4008224d:	00fc25        	call8	40083210 <z_impl_k_sem_take>
		return -ETIMEDOUT;
40082250:	c4af22        	movi	a2, -60
	if (k_sem_take(&data->fifo_sem, K_MSEC(I2C_ESP32_TIMEOUT_MS)) < 0) {
40082253:	026a96        	bltz	a10, 4008227d <i2c_esp32_transmit+0x5d>
	status = sys_read32(I2C_INT_RAW_REG(config->index));
40082256:	0328      	l32i.n	a2, a3, 0
40082258:	1182e0        	slli	a8, a2, 2
4008225b:	882a      	add.n	a8, a8, a2
4008225d:	f94a21        	l32r	a2, 40080788 <_iram_text_start+0x238>
40082260:	118820        	slli	a8, a8, 14
40082263:	882a      	add.n	a8, a8, a2
	return *(volatile uint32_t *)addr;
40082265:	0020c0        	memw
40082268:	0898      	l32i.n	a9, a8, 0
	if (status & (I2C_ARBITRATION_LOST_INT_RAW | I2C_ACK_ERR_INT_RAW)) {
4008226a:	20a482        	movi	a8, 0x420
4008226d:	108980        	and	a8, a9, a8
		return -EIO;
40082270:	b27c      	movi.n	a2, -5
	if (status & (I2C_ARBITRATION_LOST_INT_RAW | I2C_ACK_ERR_INT_RAW)) {
40082272:	78cc      	bnez.n	a8, 4008227d <i2c_esp32_transmit+0x5d>
	if (status & I2C_TIME_OUT_INT_RAW) {
40082274:	049890        	extui	a9, a9, 8, 1
	return 0;
40082277:	c4af22        	movi	a2, -60
4008227a:	832890        	moveqz	a2, a8, a9
}
4008227d:	f01d      	retw.n
	...

40082280 <i2c_esp32_init>:
		    POST_KERNEL, CONFIG_I2C_INIT_PRIORITY,
		    &i2c_esp32_driver_api);
#endif /* DT_NODE_HAS_STATUS(DT_DRV_INST(1), okay) */

static int i2c_esp32_init(const struct device *dev)
{
40082280:	004136        	entry	a1, 32
	const struct i2c_esp32_config *config = dev->config;
40082283:	1248      	l32i.n	a4, a2, 4
extern "C" {
#endif

static inline uint32_t i2c_map_dt_bitrate(uint32_t bitrate)
{
	switch (bitrate) {
40082285:	f94151        	l32r	a5, 4008078c <_iram_text_start+0x23c>
	struct i2c_esp32_data *data = dev->data;
	uint32_t bitrate_cfg = i2c_map_dt_bitrate(config->bitrate);
40082288:	e488      	l32i.n	a8, a4, 56
	struct i2c_esp32_data *data = dev->data;
4008228a:	3268      	l32i.n	a6, a2, 12
	case I2C_BITRATE_STANDARD:
		return I2C_SPEED_STANDARD << I2C_SPEED_SHIFT;
	case I2C_BITRATE_FAST:
		return I2C_SPEED_FAST << I2C_SPEED_SHIFT;
	case I2C_BITRATE_FAST_PLUS:
		return I2C_SPEED_FAST_PLUS << I2C_SPEED_SHIFT;
4008228c:	630c      	movi.n	a3, 6
	switch (bitrate) {
4008228e:	2c1857        	beq	a8, a5, 400822be <i2c_esp32_init+0x3e>
40082291:	143587        	bltu	a5, a8, 400822a9 <i2c_esp32_init+0x29>
40082294:	f93f51        	l32r	a5, 40080790 <_iram_text_start+0x240>
		return I2C_SPEED_STANDARD << I2C_SPEED_SHIFT;
40082297:	230c      	movi.n	a3, 2
	switch (bitrate) {
40082299:	211857        	beq	a8, a5, 400822be <i2c_esp32_init+0x3e>
		return I2C_SPEED_ULTRA << I2C_SPEED_SHIFT;
	}

	LOG_ERR("Invalid I2C bit rate value");

	return 0;
4008229c:	f93e31        	l32r	a3, 40080794 <_iram_text_start+0x244>
4008229f:	450c      	movi.n	a5, 4
400822a1:	c08830        	sub	a8, a8, a3
400822a4:	000446        	j	400822b9 <i2c_esp32_init+0x39>
400822a7:	510000        	lsi	f0, a0, 0x144
	switch (bitrate) {
400822aa:	f93b      	addi.n	a15, a9, 3
		return I2C_SPEED_HIGH << I2C_SPEED_SHIFT;
400822ac:	830c      	movi.n	a3, 8
	switch (bitrate) {
400822ae:	0c1857        	beq	a8, a5, 400822be <i2c_esp32_init+0x3e>
	return 0;
400822b1:	f93a31        	l32r	a3, 4008079c <_iram_text_start+0x24c>
400822b4:	a50c      	movi.n	a5, 10
400822b6:	c08830        	sub	a8, a8, a3
400822b9:	030c      	movi.n	a3, 0
400822bb:	833580        	moveqz	a3, a5, a8
	data->clock_dev = device_get_binding(config->clock_name);
400822be:	24a8      	l32i.n	a10, a4, 8
400822c0:	004ca5        	call8	4008278c <z_impl_device_get_binding>
400822c3:	a6a9      	s32i.n	a10, a6, 40
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400822c5:	006350        	rsil	a5, 3
	return z_impl_k_sem_init(sem, initial_count, limit);
400822c8:	1c0c      	movi.n	a12, 1
400822ca:	0cbd      	mov.n	a11, a12
400822cc:	a68b      	addi.n	a10, a6, 8
400822ce:	0175e5        	call8	40083a2c <z_impl_k_sem_init>
400822d1:	1c0c      	movi.n	a12, 1
400822d3:	20bcc0        	or	a11, a12, a12
400822d6:	18c6a2        	addi	a10, a6, 24
400822d9:	017525        	call8	40083a2c <z_impl_k_sem_init>
	__asm__ volatile("rsr.intenable %0" : "=r"(val));
400822dc:	03e460        	rsr.intenable	a6
	z_xt_ints_off(1 << irq);
400822df:	c498      	l32i.n	a9, a4, 48
	val &= ~mask;
400822e1:	e87c      	movi.n	a8, -2
400822e3:	401900        	ssl	a9
400822e6:	818880        	src	a8, a8, a8
400822e9:	108860        	and	a8, a8, a6
	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(val));
400822ec:	13e480        	wsr.intenable	a8
400822ef:	002010        	rsync
	irq_disable(config->irq.line);

	/* Even if irq_enable() is called on config->irq.line, disable
	 * interrupt sources in the I2C controller.
	 */
	sys_write32(0, I2C_INT_ENA_REG(config->index));
400822f2:	0468      	l32i.n	a6, a4, 0
	*(volatile uint32_t *)addr = data;
400822f4:	0a0c      	movi.n	a10, 0
400822f6:	1186e0        	slli	a8, a6, 2
400822f9:	886a      	add.n	a8, a8, a6
400822fb:	f92161        	l32r	a6, 40080780 <_iram_text_start+0x230>
400822fe:	118820        	slli	a8, a8, 14
40082301:	886a      	add.n	a8, a8, a6
40082303:	0020c0        	memw
40082306:	0068a2        	s32i	a10, a8, 0
	esp32_rom_intr_matrix_set(0, config->irq.source, config->irq.line);
40082309:	0c24c2        	l32i	a12, a4, 48
4008230c:	b4b8      	l32i.n	a11, a4, 44
4008230e:	f90381        	l32r	a8, 4008071c <_iram_text_start+0x1cc>
40082311:	0008e0        	callx8	a8

	config->connect_irq();
40082314:	1468      	l32i.n	a6, a4, 4
40082316:	0006e0        	callx8	a6
	XTOS_RESTORE_INTLEVEL(key);
40082319:	13e650        	wsr.ps	a5
4008231c:	002010        	rsync
	irq_unlock(key);

	return i2c_esp32_configure(dev, config->default_config | bitrate_cfg);
4008231f:	d4b8      	l32i.n	a11, a4, 52
40082321:	02ad      	mov.n	a10, a2
40082323:	20b3b0        	or	a11, a3, a11
40082326:	ffc9a5        	call8	40081fc0 <i2c_esp32_configure>
}
40082329:	0a2d      	mov.n	a2, a10
4008232b:	f01d      	retw.n
4008232d:	000000        	ill

40082330 <i2c_esp32_wait$isra$1>:
static int i2c_esp32_wait(const struct device *dev,
40082330:	004136        	entry	a1, 32
	int counter = 0;
40082333:	040c      	movi.n	a4, 0
	if (*counter > I2C_ESP32_TIMEOUT) {
40082335:	85a352        	movi	a5, 0x385
	if (wait_cmd) {
40082338:	199347        	bne	a3, a4, 40082355 <i2c_esp32_wait$isra$1+0x25>
4008233b:	000cc6        	j	40082372 <i2c_esp32_wait$isra$1+0x42>
	*counter = *counter + 1;
4008233e:	441b      	addi.n	a4, a4, 1
	if (*counter > I2C_ESP32_TIMEOUT) {
40082340:	059457        	bne	a4, a5, 40082349 <i2c_esp32_wait$isra$1+0x19>
		return -ETIMEDOUT;
40082343:	c4af22        	movi	a2, -60
40082346:	001206        	j	40082392 <i2c_esp32_wait$isra$1+0x62>
	if (*counter > I2C_ESP32_SPIN_THRESHOLD) {
40082349:	58a282        	movi	a8, 0x258
4008234c:	05a847        	bge	a8, a4, 40082355 <i2c_esp32_wait$isra$1+0x25>
	z_impl_k_yield();
4008234f:	201110        	or	a1, a1, a1
40082352:	00db25        	call8	40083104 <z_impl_k_yield>
		while (!wait_cmd->done) {
40082355:	0020c0        	memw
40082358:	0388      	l32i.n	a8, a3, 0
4008235a:	fe08d6        	bgez	a8, 4008233e <i2c_esp32_wait$isra$1+0xe>
4008235d:	000446        	j	40082372 <i2c_esp32_wait$isra$1+0x42>
	*counter = *counter + 1;
40082360:	01c442        	addi	a4, a4, 1
	if (*counter > I2C_ESP32_TIMEOUT) {
40082363:	85a332        	movi	a3, 0x385
40082366:	d91437        	beq	a4, a3, 40082343 <i2c_esp32_wait$isra$1+0x13>
	if (*counter > I2C_ESP32_SPIN_THRESHOLD) {
40082369:	58a232        	movi	a3, 0x258
4008236c:	02a347        	bge	a3, a4, 40082372 <i2c_esp32_wait$isra$1+0x42>
4008236f:	00d965        	call8	40083104 <z_impl_k_yield>
	while (sys_read32(I2C_SR_REG(config->index)) & I2C_BUS_BUSY) {
40082372:	002292        	l32i	a9, a2, 0
40082375:	f90a31        	l32r	a3, 400807a0 <_iram_text_start+0x250>
40082378:	1189e0        	slli	a8, a9, 2
4008237b:	808890        	add	a8, a8, a9
4008237e:	118820        	slli	a8, a8, 14
40082381:	883a      	add.n	a8, a8, a3
	return *(volatile uint32_t *)addr;
40082383:	0020c0        	memw
40082386:	0888      	l32i.n	a8, a8, 0
40082388:	031c      	movi.n	a3, 16
4008238a:	108830        	and	a8, a8, a3
4008238d:	fcf856        	bnez	a8, 40082360 <i2c_esp32_wait$isra$1+0x30>
	return 0;
40082390:	082d      	mov.n	a2, a8
}
40082392:	f01d      	retw.n

40082394 <i2c_esp32_transfer>:
{
40082394:	008136        	entry	a1, 64
40082397:	206220        	or	a6, a2, a2
	struct i2c_esp32_data *data = dev->data;
4008239a:	032222        	l32i	a2, a2, 12
{
4008239d:	744040        	extui	a4, a4, 0, 8
400823a0:	f45050        	extui	a5, a5, 0, 16
	k_sem_take(&data->transfer_sem, K_FOREVER);
400823a3:	18c272        	addi	a7, a2, 24
	return z_impl_k_sem_take(sem, timeout);
400823a6:	f87ac1        	l32r	a12, 40080590 <_iram_text_start+0x40>
400823a9:	f879d1        	l32r	a13, 40080590 <_iram_text_start+0x40>
400823ac:	20a770        	or	a10, a7, a7
400823af:	00e625        	call8	40083210 <z_impl_k_sem_take>
	addr &= BIT_MASK(data->dev_config & I2C_ADDR_10_BITS ? 10 : 7);
400823b2:	0228      	l32i.n	a2, a2, 0
400823b4:	ffa392        	movi	a9, 0x3ff
400823b7:	042020        	extui	a2, a2, 0, 1
400823ba:	7fa082        	movi	a8, 127
400823bd:	938920        	movnez	a8, a9, a2
400823c0:	1124f0        	slli	a2, a4, 1
400823c3:	224a      	add.n	a2, a2, a4
400823c5:	1122e0        	slli	a2, a2, 2
400823c8:	232a      	add.n	a2, a3, a2
400823ca:	105850        	and	a5, a8, a5
	addr <<= 1;
400823cd:	1155f0        	slli	a5, a5, 1
	for (i = 0U; i < num_msgs; i++) {
400823d0:	4129      	s32i.n	a2, a1, 16
	addr |= BIT(0);
400823d2:	120c      	movi.n	a2, 1
	cmd = i2c_esp32_write_addr(dev, cmd, &msg, addr);
400823d4:	202520        	or	a2, a5, a2
400823d7:	5129      	s32i.n	a2, a1, 20
	for (i = 0U; i < num_msgs; i++) {
400823d9:	007806        	j	400825bd <i2c_esp32_transfer+0x229>
		if ((msgs[i].flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
400823dc:	012642        	l32i	a4, a6, 4
400823df:	0123a2        	l32i	a10, a3, 4
400823e2:	002482        	l32i	a8, a4, 0
400823e5:	2398      	l32i.n	a9, a3, 8
400823e7:	1128e0        	slli	a2, a8, 2
400823ea:	228a      	add.n	a2, a2, a8
400823ec:	f8ee81        	l32r	a8, 400807a4 <_iram_text_start+0x254>
400823ef:	112220        	slli	a2, a2, 14
400823f2:	228a      	add.n	a2, a2, a8
400823f4:	03c8      	l32i.n	a12, a3, 0
400823f6:	080382        	l8ui	a8, a3, 8
400823f9:	01c9      	s32i.n	a12, a1, 0
400823fb:	048080        	extui	a8, a8, 0, 1
400823fe:	11a9      	s32i.n	a10, a1, 4
40082400:	2199      	s32i.n	a9, a1, 8
40082402:	b24b      	addi.n	a11, a2, 4
40082404:	0c3856        	bnez	a8, 400824cb <i2c_esp32_transfer+0x137>
	*cmd++ = (struct i2c_esp32_cmd) {
40082407:	0020c0        	memw
4008240a:	0289      	s32i.n	a8, a2, 0
	cmd = i2c_esp32_write_addr(dev, cmd, &msg, addr);
4008240c:	05dd      	mov.n	a13, a5
4008240e:	01cd      	mov.n	a12, a1
40082410:	06ad      	mov.n	a10, a6
40082412:	ffae65        	call8	40081ef8 <i2c_esp32_write_addr>
40082415:	0abd      	mov.n	a11, a10
		uint32_t to_send = MIN(I2C_ESP32_BUFFER_SIZE, msg.len);
40082417:	022c      	movi.n	a2, 32
40082419:	002986        	j	400824c3 <i2c_esp32_transfer+0x12f>
4008241c:	882000        	lsi	f0, a0, 0x220
4008241f:	c4d163        	lsi	f6, a1, 0x310
				    I2C_DATA_APB_REG(config->index));
40082422:	adf8      	l32i.n	a15, a13, 40
40082424:	7608      	l32i.n	a0, a6, 28
40082426:	198a      	add.n	a1, a9, a8
			sys_write32(*msg.buf++,
40082428:	0198      	l32i.n	a9, a1, 0
				    I2C_DATA_APB_REG(config->index));
4008242a:	04e8      	l32i.n	a14, a4, 0
			sys_write32(*msg.buf++,
4008242c:	c91b      	addi.n	a12, a9, 1
4008242e:	01c9      	s32i.n	a12, a1, 0
40082430:	0009c2        	l8ui	a12, a9, 0
				    I2C_DATA_APB_REG(config->index));
40082433:	119ee0        	slli	a9, a14, 2
40082436:	99ea      	add.n	a9, a9, a14
40082438:	119920        	slli	a9, a9, 14
4008243b:	99da      	add.n	a9, a9, a13
	*(volatile uint32_t *)addr = data;
4008243d:	0020c0        	memw
40082440:	09c9      	s32i.n	a12, a9, 0
		*cmd++ = (struct i2c_esp32_cmd) {
40082442:	990c      	movi.n	a9, 9
40082444:	11a980        	slli	a10, a9, 8
40082447:	749080        	extui	a9, a8, 0, 8
4008244a:	2099a0        	or	a9, a9, a10
4008244d:	0020c0        	memw
40082450:	0b99      	s32i.n	a9, a11, 0
		msg.len -= to_send;
40082452:	1198      	l32i.n	a9, a1, 4
40082454:	c08980        	sub	a8, a9, a8
40082457:	1189      	s32i.n	a8, a1, 4
		if (!msg.len && (msg.flags & I2C_MSG_STOP)) {
40082459:	c8dc      	bnez.n	a8, 40082479 <i2c_esp32_transfer+0xe5>
4008245b:	080192        	l8ui	a9, a1, 8
4008245e:	176917        	bbci	a9, 1, 40082479 <i2c_esp32_transfer+0xe5>
			*cmd = (struct i2c_esp32_cmd) {
40082461:	0020c0        	memw
40082464:	1b89      	s32i.n	a8, a11, 4
40082466:	f87991        	l32r	a9, 4008064c <_iram_text_start+0xfc>
40082469:	0020c0        	memw
4008246c:	1b88      	l32i.n	a8, a11, 4
4008246e:	108890        	and	a8, a8, a9
40082471:	f8cd91        	l32r	a9, 400807a8 <_iram_text_start+0x258>
40082474:	000586        	j	4008248e <i2c_esp32_transfer+0xfa>
40082477:	0c0000        	lsi	f0, a0, 48
			*cmd = (struct i2c_esp32_cmd) {
4008247a:	c008      	l32i.n	a0, a0, 48
4008247c:	890020        	lsi	f2, a0, 0x224
4008247f:	911b      	addi.n	a9, a1, 1
40082481:	c0f873        	lsi	f7, a8, 0x300
40082484:	880020        	lsi	f2, a0, 0x220
40082487:	901b      	addi.n	a9, a0, 1
40082489:	1088      	l32i.n	a8, a0, 4
4008248b:	f87191        	l32r	a9, 40080650 <_iram_text_start+0x100>
4008248e:	208890        	or	a8, a8, a9
40082491:	0020c0        	memw
40082494:	1b89      	s32i.n	a8, a11, 4
	ret = i2c_esp32_transmit(dev);
40082496:	06ad      	mov.n	a10, a6
40082498:	61b9      	s32i.n	a11, a1, 24
4008249a:	ffd865        	call8	40082220 <i2c_esp32_transmit>
4008249d:	0a8d      	mov.n	a8, a10
	if (!ret) {
4008249f:	61b8      	l32i.n	a11, a1, 24
400824a1:	7acc      	bnez.n	a10, 400824ac <i2c_esp32_transfer+0x118>
		return i2c_esp32_wait(dev, wait_cmd);
400824a3:	16a8      	l32i.n	a10, a6, 4
400824a5:	bb4b      	addi.n	a11, a11, 4
400824a7:	ffe8a5        	call8	40082330 <i2c_esp32_wait$isra$1>
400824aa:	0a8d      	mov.n	a8, a10
		if (ret < 0) {
400824ac:	109896        	bltz	a8, 400825b9 <i2c_esp32_transfer+0x225>
		i2c_esp32_reset_fifo(config);
400824af:	04a8      	l32i.n	a10, a4, 0
400824b1:	ffa125        	call8	40081ec4 <i2c_esp32_reset_fifo$isra$0>
	for (; msg.len; cmd = (void *)I2C_COMD0_REG(config->index)) {
400824b4:	0488      	l32i.n	a8, a4, 0
400824b6:	11b8e0        	slli	a11, a8, 2
400824b9:	bb8a      	add.n	a11, a11, a8
400824bb:	f8ba81        	l32r	a8, 400807a4 <_iram_text_start+0x254>
400824be:	11bb20        	slli	a11, a11, 14
400824c1:	bb8a      	add.n	a11, a11, a8
400824c3:	1188      	l32i.n	a8, a1, 4
400824c5:	f54856        	bnez	a8, 4008241d <i2c_esp32_transfer+0x89>
400824c8:	003b46        	j	400825b9 <i2c_esp32_transfer+0x225>
	*cmd++ = (struct i2c_esp32_cmd) {
400824cb:	080c      	movi.n	a8, 0
	cmd = i2c_esp32_write_addr(dev, cmd, &msg, addr);
400824cd:	51d8      	l32i.n	a13, a1, 20
	*cmd++ = (struct i2c_esp32_cmd) {
400824cf:	0020c0        	memw
400824d2:	0289      	s32i.n	a8, a2, 0
	cmd = i2c_esp32_write_addr(dev, cmd, &msg, addr);
400824d4:	01cd      	mov.n	a12, a1
400824d6:	20a660        	or	a10, a6, a6
400824d9:	ffa1e5        	call8	40081ef8 <i2c_esp32_write_addr>
	for (; msg.len; cmd = (void *)I2C_COMD0_REG(config->index)) {
400824dc:	003506        	j	400825b4 <i2c_esp32_transfer+0x220>
400824df:	000000        	ill
		uint32_t to_read = MIN(I2C_ESP32_BUFFER_SIZE, msg.len - 1);
400824e2:	280b      	addi.n	a2, a8, -1
400824e4:	092c      	movi.n	a9, 32
400824e6:	632290        	minu	a2, a2, a9
		if (to_read) {
400824e9:	0f1826        	beqi	a8, 1, 400824fc <i2c_esp32_transfer+0x168>
			*cmd++ = (struct i2c_esp32_cmd) {
400824ec:	f880c1        	l32r	a12, 400806ec <_iram_text_start+0x19c>
400824ef:	74b020        	extui	a11, a2, 0, 8
400824f2:	20bbc0        	or	a11, a11, a12
400824f5:	0020c0        	memw
400824f8:	0ab9      	s32i.n	a11, a10, 0
400824fa:	aa4b      	addi.n	a10, a10, 4
		if (msg.len - to_read <= 1U) {
400824fc:	c08820        	sub	a8, a8, a2
400824ff:	3728f6        	bgeui	a8, 2, 4008253a <i2c_esp32_transfer+0x1a6>
			*cmd++ = (struct i2c_esp32_cmd) {
40082502:	f8aa81        	l32r	a8, 400807ac <_iram_text_start+0x25c>
40082505:	ba4b      	addi.n	a11, a10, 4
40082507:	0020c0        	memw
4008250a:	0a89      	s32i.n	a8, a10, 0
			if (msg.flags & I2C_MSG_STOP) {
4008250c:	080182        	l8ui	a8, a1, 8
			to_read++;
4008250f:	221b      	addi.n	a2, a2, 1
			if (msg.flags & I2C_MSG_STOP) {
40082511:	236817        	bbci	a8, 1, 40082538 <i2c_esp32_transfer+0x1a4>
				*cmd++ = (struct i2c_esp32_cmd) {
40082514:	080c      	movi.n	a8, 0
40082516:	0020c0        	memw
40082519:	1a89      	s32i.n	a8, a10, 4
4008251b:	0020c0        	memw
4008251e:	1a88      	l32i.n	a8, a10, 4
40082520:	f84bc1        	l32r	a12, 4008064c <_iram_text_start+0xfc>
40082523:	1088c0        	and	a8, a8, a12
40082526:	f8a0c1        	l32r	a12, 400807a8 <_iram_text_start+0x258>
40082529:	2088c0        	or	a8, a8, a12
4008252c:	0020c0        	memw
4008252f:	1a89      	s32i.n	a8, a10, 4
40082531:	4a0c      	movi.n	a10, 4
		if (!wait_cmd) {
40082533:	3b8c      	beqz.n	a11, 4008253a <i2c_esp32_transfer+0x1a6>
40082535:	000786        	j	40082557 <i2c_esp32_transfer+0x1c3>
			*cmd++ = (struct i2c_esp32_cmd) {
40082538:	0bad      	mov.n	a10, a11
			*cmd++ = (struct i2c_esp32_cmd) {
4008253a:	0b0c      	movi.n	a11, 0
4008253c:	0020c0        	memw
4008253f:	0ab9      	s32i.n	a11, a10, 0
40082541:	0020c0        	memw
40082544:	0a88      	l32i.n	a8, a10, 0
40082546:	f841c1        	l32r	a12, 4008064c <_iram_text_start+0xfc>
40082549:	1088c0        	and	a8, a8, a12
4008254c:	f841c1        	l32r	a12, 40080650 <_iram_text_start+0x100>
4008254f:	2088c0        	or	a8, a8, a12
40082552:	0020c0        	memw
40082555:	0a89      	s32i.n	a8, a10, 0
	ret = i2c_esp32_transmit(dev);
40082557:	06ad      	mov.n	a10, a6
40082559:	61b9      	s32i.n	a11, a1, 24
4008255b:	ffcc65        	call8	40082220 <i2c_esp32_transmit>
4008255e:	0a8d      	mov.n	a8, a10
	if (!ret) {
40082560:	61b8      	l32i.n	a11, a1, 24
40082562:	006a56        	bnez	a10, 4008256c <i2c_esp32_transfer+0x1d8>
		return i2c_esp32_wait(dev, wait_cmd);
40082565:	16a8      	l32i.n	a10, a6, 4
40082567:	ffdca5        	call8	40082330 <i2c_esp32_wait$isra$1>
4008256a:	0a8d      	mov.n	a8, a10
		if (ret < 0) {
4008256c:	049896        	bltz	a8, 400825b9 <i2c_esp32_transfer+0x225>
		for (i = 0U; i < to_read; i++) {
4008256f:	0a0c      	movi.n	a10, 0
			uint32_t v = sys_read32(I2C_DATA_APB_REG(config->index));
40082571:	f86fb1        	l32r	a11, 40080730 <_iram_text_start+0x1e0>
40082574:	000786        	j	40082596 <i2c_esp32_transfer+0x202>
40082577:	24c200        	extui	a12, a0, 2, 3
4008257a:	caa200        	float.s	f10, a2, 0
		for (i = 0U; i < to_read; i++) {
4008257d:	8ce001        	l32r	a0, 40065900 <esp32_rom_gpio_matrix_out+0x5b9f4>
			uint32_t v = sys_read32(I2C_DATA_APB_REG(config->index));
40082580:	88ca11        	l32r	a1, 400648a8 <esp32_rom_gpio_matrix_out+0x5a99c>
40082583:	118820        	slli	a8, a8, 14
40082586:	88ba      	add.n	a8, a8, a11
	return *(volatile uint32_t *)addr;
40082588:	0020c0        	memw
4008258b:	08c8      	l32i.n	a12, a8, 0
			*msg.buf++ = v & I2C_FIFO_RDATA;
4008258d:	0188      	l32i.n	a8, a1, 0
4008258f:	d81b      	addi.n	a13, a8, 1
40082591:	01d9      	s32i.n	a13, a1, 0
40082593:	0048c2        	s8i	a12, a8, 0
		for (i = 0U; i < to_read; i++) {
40082596:	de9a27        	bne	a10, a2, 40082578 <i2c_esp32_transfer+0x1e4>
		msg.len -= to_read;
40082599:	1188      	l32i.n	a8, a1, 4
4008259b:	c0a8a0        	sub	a10, a8, a10
4008259e:	11a9      	s32i.n	a10, a1, 4
		i2c_esp32_reset_fifo(config);
400825a0:	04a8      	l32i.n	a10, a4, 0
400825a2:	ff9225        	call8	40081ec4 <i2c_esp32_reset_fifo$isra$0>
	for (; msg.len; cmd = (void *)I2C_COMD0_REG(config->index)) {
400825a5:	0488      	l32i.n	a8, a4, 0
400825a7:	11a8e0        	slli	a10, a8, 2
400825aa:	aa8a      	add.n	a10, a10, a8
400825ac:	f87e81        	l32r	a8, 400807a4 <_iram_text_start+0x254>
400825af:	11aa20        	slli	a10, a10, 14
400825b2:	aa8a      	add.n	a10, a10, a8
400825b4:	1188      	l32i.n	a8, a1, 4
400825b6:	f28856        	bnez	a8, 400824e2 <i2c_esp32_transfer+0x14e>
		if (ret < 0) {
400825b9:	33cb      	addi.n	a3, a3, 12
400825bb:	88cc      	bnez.n	a8, 400825c7 <i2c_esp32_transfer+0x233>
	for (i = 0U; i < num_msgs; i++) {
400825bd:	4128      	l32i.n	a2, a1, 16
400825bf:	021237        	beq	a2, a3, 400825c5 <i2c_esp32_transfer+0x231>
400825c2:	ff8586        	j	400823dc <i2c_esp32_transfer+0x48>
400825c5:	080c      	movi.n	a8, 0
	z_impl_k_sem_give(sem);
400825c7:	07ad      	mov.n	a10, a7
400825c9:	6189      	s32i.n	a8, a1, 24
400825cb:	00c0a5        	call8	400831d4 <z_impl_k_sem_give>
}
400825ce:	6188      	l32i.n	a8, a1, 24
400825d0:	082d      	mov.n	a2, a8
400825d2:	f01d      	retw.n

400825d4 <uart_esp32_configure>:
	return 0;
}

static int uart_esp32_configure(const struct device *dev,
				const struct uart_config *cfg)
{
400825d4:	006136        	entry	a1, 48
	uint32_t conf0 = UART_TICK_REF_ALWAYS_ON;
	uint32_t conf1 = (UART_RX_FIFO_THRESH << UART_RXFIFO_FULL_THRHD_S)
		      | (UART_TX_FIFO_THRESH << UART_TXFIFO_EMPTY_THRHD_S);

	uart_esp32_configure_pins(dev);
400825d7:	1248      	l32i.n	a4, a2, 4
	esp32_rom_gpio_matrix_out(cfg->pins.tx,
400825d9:	0d0c      	movi.n	a13, 0
400825db:	34b8      	l32i.n	a11, a4, 12
400825dd:	0724a2        	l32i	a10, a4, 28
400825e0:	0dcd      	mov.n	a12, a13
400825e2:	f85781        	l32r	a8, 40080740 <_iram_text_start+0x1f0>
400825e5:	0008e0        	callx8	a8
	esp32_rom_gpio_matrix_in(cfg->pins.rx,
400825e8:	44b8      	l32i.n	a11, a4, 16
400825ea:	84a8      	l32i.n	a10, a4, 32
400825ec:	0c0c      	movi.n	a12, 0
400825ee:	f85581        	l32r	a8, 40080744 <_iram_text_start+0x1f4>
400825f1:	0008e0        	callx8	a8
	if (cfg->pins.cts) {
400825f4:	a4a8      	l32i.n	a10, a4, 40
400825f6:	aa8c      	beqz.n	a10, 40082604 <uart_esp32_configure+0x30>
		esp32_rom_gpio_matrix_out(cfg->pins.cts,
400825f8:	0d0c      	movi.n	a13, 0
400825fa:	64b8      	l32i.n	a11, a4, 24
400825fc:	0dcd      	mov.n	a12, a13
400825fe:	f85081        	l32r	a8, 40080740 <_iram_text_start+0x1f0>
40082601:	0008e0        	callx8	a8
	if (cfg->pins.rts) {
40082604:	94a8      	l32i.n	a10, a4, 36
40082606:	8a8c      	beqz.n	a10, 40082612 <uart_esp32_configure+0x3e>
		esp32_rom_gpio_matrix_in(cfg->pins.rts,
40082608:	54b8      	l32i.n	a11, a4, 20
4008260a:	0c0c      	movi.n	a12, 0
4008260c:	f84e81        	l32r	a8, 40080744 <_iram_text_start+0x1f4>
4008260f:	0008e0        	callx8	a8
	clock_control_on(DEV_DATA(dev)->clock_dev, DEV_CFG(dev)->peripheral_id);
40082612:	3248      	l32i.n	a4, a2, 12
40082614:	1258      	l32i.n	a5, a2, 4
40082616:	24a8      	l32i.n	a10, a4, 8
	return api->on(dev, sys);
40082618:	b5b8      	l32i.n	a11, a5, 44
4008261a:	2a48      	l32i.n	a4, a10, 8
4008261c:	0448      	l32i.n	a4, a4, 0
4008261e:	0004e0        	callx8	a4

	/*
	 * Reset RX Buffer by reading all received bytes
	 * Hardware Reset functionality can't be used with UART 1/2
	 */
	while (UART_RXFIFO_COUNT(DEV_BASE(dev)->status) != 0) {
40082621:	12b8      	l32i.n	a11, a2, 4
40082623:	0b58      	l32i.n	a5, a11, 0
40082625:	000106        	j	4008262d <uart_esp32_configure+0x59>
		(void) DEV_BASE(dev)->fifo;
40082628:	0020c0        	memw
4008262b:	0548      	l32i.n	a4, a5, 0
	while (UART_RXFIFO_COUNT(DEV_BASE(dev)->status) != 0) {
4008262d:	0020c0        	memw
40082630:	7548      	l32i.n	a4, a5, 28
40082632:	744040        	extui	a4, a4, 0, 8
40082635:	fef456        	bnez	a4, 40082628 <uart_esp32_configure+0x54>
	}

	switch (cfg->parity) {
40082638:	040342        	l8ui	a4, a3, 4
4008263b:	0d1426        	beqi	a4, 1, 4008264c <uart_esp32_configure+0x78>
4008263e:	249c      	beqz.n	a4, 40082654 <uart_esp32_configure+0x80>
		break;
	case UART_CFG_PARITY_ODD:
		conf0 |= UART_PARITY;
		break;
	default:
		return -ENOTSUP;
40082640:	ddaf92        	movi	a9, -35
	switch (cfg->parity) {
40082643:	022426        	beqi	a4, 2, 40082649 <uart_esp32_configure+0x75>
40082646:	002606        	j	400826e2 <uart_esp32_configure+0x10e>
40082649:	0001c6        	j	40082654 <uart_esp32_configure+0x80>
		conf0 |= UART_PARITY;
4008264c:	f85951        	l32r	a5, 400807b0 <_iram_text_start+0x260>
4008264f:	000106        	j	40082657 <uart_esp32_configure+0x83>
40082652:	510000        	lsi	f0, a0, 0x144
		conf0 &= ~(UART_PARITY);
40082655:	82f802        	s32ri	a0, a8, 0x208
	}

	switch (cfg->stop_bits) {
40082658:	920503        	lsi	f0, a5, 0x248
	case UART_CFG_STOP_BITS_1_5:
	case UART_CFG_STOP_BITS_2:
		conf0 |= cfg->stop_bits << UART_STOP_BIT_NUM_S;
		break;
	default:
		return -ENOTSUP;
4008265b:	af          	.byte 0xaf
4008265c:	0bdd      	mov.n	a13, a11
	switch (cfg->stop_bits) {
4008265e:	f648      	l32i.n	a4, a6, 60
40082660:	c07f34        	lsi	f3, a15, 0x300
		conf0 |= cfg->stop_bits << UART_STOP_BIT_NUM_S;
40082663:	11a8      	l32i.n	a10, a1, 4
	}

	if (cfg->data_bits <= UART_CFG_DATA_BITS_8) {
40082665:	060382        	l8ui	a8, a3, 6
40082668:	7648f6        	bgeui	a8, 4, 400826e2 <uart_esp32_configure+0x10e>
		conf0 |= cfg->data_bits << UART_BIT_NUM_S;
4008266b:	1148e0        	slli	a4, a8, 2
4008266e:	2044a0        	or	a4, a4, a10
40082671:	204450        	or	a4, a4, a5
	} else {
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
40082674:	070352        	l8ui	a5, a3, 7
40082677:	d58c      	beqz.n	a5, 40082688 <uart_esp32_configure+0xb4>
40082679:	651566        	bnei	a5, 1, 400826e2 <uart_esp32_configure+0x10e>
	case UART_CFG_FLOW_CTRL_NONE:
		conf0 &= ~(UART_TX_FLOW_EN);
		conf1 &= ~(UART_RX_FLOW_EN);
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		conf0 |= UART_TX_FLOW_EN;
4008267c:	f80551        	l32r	a5, 40080690 <_iram_text_start+0x140>
4008267f:	204450        	or	a4, a4, a5
		conf1 |= UART_RX_FLOW_EN;
40082682:	f84c51        	l32r	a5, 400807b4 <_iram_text_start+0x264>
		break;
40082685:	000086        	j	4008268b <uart_esp32_configure+0xb7>
		conf1 &= ~(UART_RX_FLOW_EN);
40082688:	01a152        	movi	a5, 0x101
	uint32_t sys_clk_freq = 0;
4008268b:	080c      	movi.n	a8, 0
4008268d:	0189      	s32i.n	a8, a1, 0
	if (clock_control_get_rate(DEV_DATA(dev)->clock_dev,
4008268f:	3288      	l32i.n	a8, a2, 12
	return api->get_rate(dev, sys, rate);
40082691:	bbb8      	l32i.n	a11, a11, 44
40082693:	28a8      	l32i.n	a10, a8, 8
40082695:	01cd      	mov.n	a12, a1
40082697:	2a88      	l32i.n	a8, a10, 8
	default:
		return -ENOTSUP;
	}

	if (uart_esp32_set_baudrate(dev, cfg->baudrate)) {
40082699:	002362        	l32i	a6, a3, 0
4008269c:	032882        	l32i	a8, a8, 12
4008269f:	0008e0        	callx8	a8
400826a2:	12b8      	l32i.n	a11, a2, 4
	if (clock_control_get_rate(DEV_DATA(dev)->clock_dev,
400826a4:	6aec      	bnez.n	a10, 400826ce <uart_esp32_configure+0xfa>
	uint32_t clk_div = (((sys_clk_freq) << 4) / baudrate);
400826a6:	0188      	l32i.n	a8, a1, 0
	while (UART_TXFIFO_COUNT(DEV_BASE(dev)->status)) {
400826a8:	0ba8      	l32i.n	a10, a11, 0
	uint32_t clk_div = (((sys_clk_freq) << 4) / baudrate);
400826aa:	1188c0        	slli	a8, a8, 4
400826ad:	c28860        	quou	a8, a8, a6
	while (UART_TXFIFO_COUNT(DEV_BASE(dev)->status)) {
400826b0:	0020c0        	memw
400826b3:	7a98      	l32i.n	a9, a10, 28
400826b5:	759090        	extui	a9, a9, 16, 8
400826b8:	ff4956        	bnez	a9, 400826b0 <uart_esp32_configure+0xdc>
	if (clk_div < 16) {
400826bb:	f90c      	movi.n	a9, 15
400826bd:	0db987        	bgeu	a9, a8, 400826ce <uart_esp32_configure+0xfa>
	DEV_BASE(dev)->clk_div = ((clk_div >> 4) | (clk_div & 0xf));
400826c0:	419480        	srli	a9, a8, 4
400826c3:	348080        	extui	a8, a8, 0, 4
400826c6:	208980        	or	a8, a9, a8
400826c9:	0020c0        	memw
400826cc:	5a89      	s32i.n	a8, a10, 20
		DEV_DATA(dev)->uart_config.baudrate = cfg->baudrate;
400826ce:	0338      	l32i.n	a3, a3, 0
400826d0:	3228      	l32i.n	a2, a2, 12
	}

	DEV_BASE(dev)->conf0 = conf0;
	DEV_BASE(dev)->conf1 = conf1;

	return 0;
400826d2:	090c      	movi.n	a9, 0
		DEV_DATA(dev)->uart_config.baudrate = cfg->baudrate;
400826d4:	0239      	s32i.n	a3, a2, 0
	DEV_BASE(dev)->conf0 = conf0;
400826d6:	0b28      	l32i.n	a2, a11, 0
400826d8:	0020c0        	memw
400826db:	8249      	s32i.n	a4, a2, 32
	DEV_BASE(dev)->conf1 = conf1;
400826dd:	0020c0        	memw
400826e0:	9259      	s32i.n	a5, a2, 36
}
400826e2:	092d      	mov.n	a2, a9
400826e4:	f01d      	retw.n
	...

400826e8 <uart_esp32_init>:

static int uart_esp32_init(const struct device *dev)
{
400826e8:	004136        	entry	a1, 32
	struct uart_esp32_data *data = DEV_DATA(dev);

	data->clock_dev = device_get_binding(DEV_CFG(dev)->clock_name);
400826eb:	012282        	l32i	a8, a2, 4
	struct uart_esp32_data *data = DEV_DATA(dev);
400826ee:	032232        	l32i	a3, a2, 12
	data->clock_dev = device_get_binding(DEV_CFG(dev)->clock_name);
400826f1:	0228a2        	l32i	a10, a8, 8
400826f4:	000965        	call8	4008278c <z_impl_device_get_binding>

	__ASSERT_NO_MSG(data->clock_dev);

	uart_esp32_configure(dev, &DEV_DATA(dev)->uart_config);
400826f7:	32b8      	l32i.n	a11, a2, 12
	data->clock_dev = device_get_binding(DEV_CFG(dev)->clock_name);
400826f9:	23a9      	s32i.n	a10, a3, 8
	uart_esp32_configure(dev, &DEV_DATA(dev)->uart_config);
400826fb:	02ad      	mov.n	a10, a2
400826fd:	ffed65        	call8	400825d4 <uart_esp32_configure>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->dev_conf.irq_config_func(dev);
#endif
	return 0;
}
40082700:	020c      	movi.n	a2, 0
40082702:	f01d      	retw.n

40082704 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
40082704:	004136        	entry	a1, 32
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40082707:	f82c81        	l32r	a8, 400807b8 <_iram_text_start+0x268>
4008270a:	1132e0        	slli	a3, a2, 2
4008270d:	221b      	addi.n	a2, a2, 1
4008270f:	1122e0        	slli	a2, a2, 2
40082712:	383a      	add.n	a3, a8, a3
40082714:	282a      	add.n	a2, a8, a2
40082716:	0338      	l32i.n	a3, a3, 0
40082718:	0248      	l32i.n	a4, a2, 0

		if (dev != NULL) {
			z_object_init(dev);
		}

		if ((entry->init(dev) == 0) && (dev != NULL)) {
4008271a:	150c      	movi.n	a5, 1
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
4008271c:	000d86        	j	40082756 <z_sys_init_run_level+0x52>
4008271f:	132800        	lsi	f0, a8, 76
		if ((entry->init(dev) == 0) && (dev != NULL)) {
40082722:	0388      	l32i.n	a8, a3, 0
40082724:	02ad      	mov.n	a10, a2
40082726:	0008e0        	callx8	a8
40082729:	7aec      	bnez.n	a10, 40082754 <z_sys_init_run_level+0x50>
4008272b:	52ac      	beqz.n	a2, 40082754 <z_sys_init_run_level+0x50>
			/* Initialization was successful.
			 * Set the init status bit so device is declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
4008272d:	f82381        	l32r	a8, 400807bc <_iram_text_start+0x26c>
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
40082730:	f82491        	l32r	a9, 400807c0 <_iram_text_start+0x270>
40082733:	c02280        	sub	a2, a2, a8
40082736:	212420        	srai	a2, a2, 4
40082739:	418520        	srli	a8, a2, 5
4008273c:	1188e0        	slli	a8, a8, 2
4008273f:	889a      	add.n	a8, a8, a9
	uint32_t temp = *(volatile uint32_t *)addr;
40082741:	0020c0        	memw
40082744:	0898      	l32i.n	a9, a8, 0
	*(volatile uint32_t *)addr = temp | (1 << bit);
40082746:	401200        	ssl	a2
40082749:	a12500        	sll	a2, a5
4008274c:	202290        	or	a2, a2, a9
4008274f:	0020c0        	memw
40082752:	0829      	s32i.n	a2, a8, 0
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40082754:	338b      	addi.n	a3, a3, 8
40082756:	c63347        	bltu	a3, a4, 40082720 <z_sys_init_run_level+0x1c>
		}
	}
}
40082759:	f01d      	retw.n
	...

4008275c <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
4008275c:	004136        	entry	a1, 32
	return !!(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
					(dev - __device_start)));
4008275f:	f81781        	l32r	a8, 400807bc <_iram_text_start+0x26c>
}

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
40082762:	f81791        	l32r	a9, 400807c0 <_iram_text_start+0x270>
40082765:	c08280        	sub	a8, a2, a8
40082768:	218480        	srai	a8, a8, 4
4008276b:	412580        	srli	a2, a8, 5
4008276e:	1122e0        	slli	a2, a2, 2
40082771:	229a      	add.n	a2, a2, a9
	uint32_t temp = *(volatile uint32_t *)addr;
40082773:	0020c0        	memw
40082776:	02a8      	l32i.n	a10, a2, 0
	return temp & (1 << bit);
40082778:	190c      	movi.n	a9, 1
4008277a:	401800        	ssl	a8
4008277d:	a12900        	sll	a2, a9
40082780:	1022a0        	and	a2, a2, a10
	return !!(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
40082783:	080c      	movi.n	a8, 0
40082785:	938920        	movnez	a8, a9, a2
40082788:	082d      	mov.n	a2, a8
}
4008278a:	f01d      	retw.n

4008278c <z_impl_device_get_binding>:
{
4008278c:	004136        	entry	a1, 32
4008278f:	024d      	mov.n	a4, a2
	for (dev = __device_start; dev != __device_end; dev++) {
40082791:	f80a21        	l32r	a2, 400807bc <_iram_text_start+0x26c>
40082794:	f80b31        	l32r	a3, 400807c0 <_iram_text_start+0x270>
40082797:	025d      	mov.n	a5, a2
40082799:	000486        	j	400827af <z_impl_device_get_binding+0x23>
4008279c:	a22000        	muluh	a2, a0, a0
		if (z_device_ready(dev) && (dev->name == name)) {
4008279f:	fba520        	f64subc	a2, a5, 1, 0
400827a2:	ff          	.byte 0xff
400827a3:	005a16        	beqz	a10, 400827ac <z_impl_device_get_binding+0x20>
400827a6:	002282        	l32i	a8, a2, 0
400827a9:	2f1847        	beq	a8, a4, 400827dc <z_impl_device_get_binding+0x50>
	for (dev = __device_start; dev != __device_end; dev++) {
400827ac:	10c222        	addi	a2, a2, 16
400827af:	ea9237        	bne	a2, a3, 4008279d <z_impl_device_get_binding+0x11>
	for (dev = __device_start; dev != __device_end; dev++) {
400827b2:	052d      	mov.n	a2, a5
400827b4:	0007c6        	j	400827d7 <z_impl_device_get_binding+0x4b>
400827b7:	000000        	ill
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
400827ba:	02ad      	mov.n	a10, a2
400827bc:	fff9e5        	call8	4008275c <z_device_ready>
400827bf:	7acc      	bnez.n	a10, 400827ca <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
400827c1:	10c222        	addi	a2, a2, 16
400827c4:	0003c6        	j	400827d7 <z_impl_device_get_binding+0x4b>
400827c7:	000000        	ill
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
400827ca:	02b8      	l32i.n	a11, a2, 0
400827cc:	04ad      	mov.n	a10, a4
400827ce:	00fbe5        	call8	4008378c <strcmp>
400827d1:	feca56        	bnez	a10, 400827c1 <z_impl_device_get_binding+0x35>
400827d4:	000106        	j	400827dc <z_impl_device_get_binding+0x50>
	for (dev = __device_start; dev != __device_end; dev++) {
400827d7:	df9237        	bne	a2, a3, 400827ba <z_impl_device_get_binding+0x2e>
	return NULL;
400827da:	020c      	movi.n	a2, 0
}
400827dc:	f01d      	retw.n
	...

400827e0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
400827e0:	004136        	entry	a1, 32
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
400827e3:	02ad      	mov.n	a10, a2
400827e5:	012025        	call8	400839e8 <arch_system_halt>

400827e8 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
400827e8:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400827eb:	006350        	rsil	a5, 3
	return z_impl_k_current_get();
400827ee:	009da5        	call8	400831c8 <z_impl_k_current_get>
400827f1:	204aa0        	or	a4, a10, a10
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	z_coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
400827f4:	03bd      	mov.n	a11, a3
400827f6:	02ad      	mov.n	a10, a2
400827f8:	fffe65        	call8	400827e0 <k_sys_fatal_error_handler>
	XTOS_RESTORE_INTLEVEL(key);
400827fb:	13e650        	wsr.ps	a5
400827fe:	002010        	rsync
	z_impl_k_thread_abort(thread);
40082801:	04ad      	mov.n	a10, a4
40082803:	00b7e5        	call8	40083380 <z_impl_k_thread_abort>
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
40082806:	f01d      	retw.n

40082808 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
40082808:	004136        	entry	a1, 32
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
4008280b:	f7ee81        	l32r	a8, 400807c4 <_iram_text_start+0x274>
4008280e:	190c      	movi.n	a9, 1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
40082810:	02a0a2        	movi	a10, 2
	z_sys_post_kernel = true;
40082813:	004892        	s8i	a9, a8, 0
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
40082816:	ffeee5        	call8	40082704 <z_sys_init_run_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
40082819:	f7ebc1        	l32r	a12, 400807c8 <_iram_text_start+0x278>
4008281c:	f7ecb1        	l32r	a11, 400807cc <_iram_text_start+0x27c>
4008281f:	f7eca1        	l32r	a10, 400807d0 <_iram_text_start+0x280>
40082822:	fe7ba5        	call8	40080fdc <printk>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
40082825:	3a0c      	movi.n	a10, 3
40082827:	ffede5        	call8	40082704 <z_sys_init_run_level>

	z_init_static_threads();
4008282a:	00ade5        	call8	40083308 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
4008282d:	fe3425        	call8	40080b70 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
40082830:	f7e991        	l32r	a9, 400807d4 <_iram_text_start+0x284>
40082833:	ea7c      	movi.n	a10, -2
40082835:	0c0982        	l8ui	a8, a9, 12
40082838:	1088a0        	and	a8, a8, a10
4008283b:	0c4982        	s8i	a8, a9, 12

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
4008283e:	f01d      	retw.n

40082840 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
40082840:	020136        	entry	a1, 0x100

static ALWAYS_INLINE void arch_kernel_init(void)
{
	_cpu_t *cpu0 = &_kernel.cpus[0];

	cpu0->nested = 0;
40082843:	f74b21        	l32r	a2, 40080570 <_iram_text_start+0x20>
40082846:	030c      	movi.n	a3, 0
40082848:	0239      	s32i.n	a3, a2, 0
	 * access.  That saves 4 bytes of immediate value to store the
	 * address when compared to the legacy scheme.  But in SMP
	 * this record is a per-CPU thing and having it stored in a SR
	 * already is a big win.
	 */
	WSR(CONFIG_XTENSA_KERNEL_CPU_PTR_SR, cpu0);
4008284a:	13f420        	wsr.misc0	a2
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
4008284d:	01a142        	movi	a4, 0x101
40082850:	0e5142        	s16i	a4, a1, 28
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
40082853:	10c142        	addi	a4, a1, 16
40082856:	2249      	s32i.n	a4, a2, 8

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
40082858:	03ad      	mov.n	a10, a3
4008285a:	ffeaa5        	call8	40082704 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
4008285d:	1a0c      	movi.n	a10, 1
4008285f:	ffea65        	call8	40082704 <z_sys_init_run_level>
	z_sched_init();
40082862:	008865        	call8	400830e8 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
40082865:	f7db41        	l32r	a4, 400807d4 <_iram_text_start+0x284>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40082868:	f7de51        	l32r	a5, 400807e0 <_iram_text_start+0x290>
	_kernel.ready_q.cache = &z_main_thread;
4008286b:	e249      	s32i.n	a4, a2, 56
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
4008286d:	3159      	s32i.n	a5, a1, 12
4008286f:	f7dad1        	l32r	a13, 400807d8 <_iram_text_start+0x288>
40082872:	150c      	movi.n	a5, 1
40082874:	f780c1        	l32r	a12, 40080674 <_iram_text_start+0x124>
40082877:	f7d9b1        	l32r	a11, 400807dc <_iram_text_start+0x28c>
4008287a:	03fd      	mov.n	a15, a3
4008287c:	03ed      	mov.n	a14, a3
4008287e:	1139      	s32i.n	a3, a1, 4
40082880:	0139      	s32i.n	a3, a1, 0
40082882:	2159      	s32i.n	a5, a1, 8
40082884:	04ad      	mov.n	a10, a4
40082886:	009d25        	call8	40083258 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40082889:	0d0462        	l8ui	a6, a4, 13
4008288c:	b77c      	movi.n	a7, -5
4008288e:	106670        	and	a6, a6, a7
40082891:	0d4462        	s8i	a6, a4, 13
	z_ready_thread(&z_main_thread);
40082894:	04ad      	mov.n	a10, a4
40082896:	0040a5        	call8	40082ca0 <z_ready_thread>
	z_setup_new_thread(thread, stack,
40082899:	f7d441        	l32r	a4, 400807ec <_iram_text_start+0x29c>
4008289c:	f90c      	movi.n	a9, 15
4008289e:	f7d1d1        	l32r	a13, 400807e4 <_iram_text_start+0x294>
400828a1:	f7d1b1        	l32r	a11, 400807e8 <_iram_text_start+0x298>
400828a4:	3139      	s32i.n	a3, a1, 12
400828a6:	1199      	s32i.n	a9, a1, 4
400828a8:	0139      	s32i.n	a3, a1, 0
400828aa:	03fd      	mov.n	a15, a3
400828ac:	03ed      	mov.n	a14, a3
400828ae:	2159      	s32i.n	a5, a1, 8
400828b0:	00a4c2        	movi	a12, 0x400
400828b3:	04ad      	mov.n	a10, a4
400828b5:	346192        	s32i	a9, a1, 208
400828b8:	0099e5        	call8	40083258 <z_setup_new_thread>
400828bb:	0d0462        	l8ui	a6, a4, 13
		_kernel.cpus[i].id = i;
400828be:	144232        	s8i	a3, a2, 20
400828c1:	106670        	and	a6, a6, a7
400828c4:	0d4462        	s8i	a6, a4, 13
		_kernel.cpus[i].irq_stack =
400828c7:	f7ca61        	l32r	a6, 400807f0 <_iram_text_start+0x2a0>
	z_setup_new_thread(thread, stack,
400828ca:	342192        	l32i	a9, a1, 208
		_kernel.cpus[i].irq_stack =
400828cd:	1269      	s32i.n	a6, a2, 4
	z_setup_new_thread(thread, stack,
400828cf:	f7ca61        	l32r	a6, 400807f8 <_iram_text_start+0x2a8>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
400828d2:	3249      	s32i.n	a4, a2, 12
	z_setup_new_thread(thread, stack,
400828d4:	f7c4d1        	l32r	a13, 400807e4 <_iram_text_start+0x294>
400828d7:	f7c7b1        	l32r	a11, 400807f4 <_iram_text_start+0x2a4>
400828da:	3139      	s32i.n	a3, a1, 12
400828dc:	0139      	s32i.n	a3, a1, 0
400828de:	03fd      	mov.n	a15, a3
400828e0:	03ed      	mov.n	a14, a3
400828e2:	2159      	s32i.n	a5, a1, 8
400828e4:	1199      	s32i.n	a9, a1, 4
400828e6:	00a4c2        	movi	a12, 0x400
400828e9:	06ad      	mov.n	a10, a6
400828eb:	0096e5        	call8	40083258 <z_setup_new_thread>
400828ee:	cd0432        	l8ui	a3, a4, 205
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
400828f1:	9269      	s32i.n	a6, a2, 36
400828f3:	103370        	and	a3, a3, a7
400828f6:	cd4432        	s8i	a3, a4, 205
		_kernel.cpus[i].irq_stack =
400828f9:	f7c031        	l32r	a3, 400807fc <_iram_text_start+0x2ac>
		_kernel.cpus[i].id = i;
400828fc:	2c4252        	s8i	a5, a2, 44
		_kernel.cpus[i].irq_stack =
400828ff:	7239      	s32i.n	a3, a2, 28
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
40082901:	f7bf31        	l32r	a3, 40080800 <_iram_text_start+0x2b0>
40082904:	c239      	s32i.n	a3, a2, 48
	list->tail = (sys_dnode_t *)list;
40082906:	d239      	s32i.n	a3, a2, 52
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082908:	006350        	rsil	a5, 3
	old_thread = _current;
4008290b:	2248      	l32i.n	a4, a2, 8
	return _kernel.ready_q.cache;
4008290d:	e238      	l32i.n	a3, a2, 56
	if (new_thread != old_thread) {
4008290f:	121437        	beq	a4, a3, 40082925 <z_cstart+0xe5>
		z_reset_time_slice();
40082912:	001565        	call8	40082a68 <z_reset_time_slice>
		old_thread->swap_retval = -EAGAIN;
40082915:	567c      	movi.n	a6, -11

void xtensa_switch(void *switch_to, void **switched_from);

static inline void arch_switch(void *switch_to, void **switched_from)
{
	return xtensa_switch(switch_to, switched_from);
40082917:	1423a2        	l32i	a10, a3, 80
4008291a:	136462        	s32i	a6, a4, 76
		_current_cpu->current = new_thread;
4008291d:	2239      	s32i.n	a3, a2, 8
4008291f:	50c4b2        	addi	a11, a4, 80
40082922:	fef0e5        	call8	40081830 <xtensa_switch>
	XTOS_RESTORE_INTLEVEL(key);
40082925:	13e650        	wsr.ps	a5
40082928:	002010        	rsync
	...

4008292c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
4008292c:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4008292f:	006370        	rsil	a7, 3
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	sys_trace_mutex_lock(mutex);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
40082932:	3238      	l32i.n	a3, a2, 12
40082934:	f70f61        	l32r	a6, 40080570 <_iram_text_start+0x20>
40082937:	938c      	beqz.n	a3, 40082944 <z_impl_k_mutex_lock+0x18>
40082939:	22a8      	l32i.n	a10, a2, 8
4008293b:	2698      	l32i.n	a9, a6, 8
4008293d:	0f1a97        	beq	a10, a9, 40082950 <z_impl_k_mutex_lock+0x24>
40082940:	000946        	j	40082969 <z_impl_k_mutex_lock+0x3d>
40082943:	264800        	lsi	f0, a8, 152

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
40082946:	0e0442        	l8ui	a4, a4, 14
40082949:	234400        	sext	a4, a4, 7
4008294c:	000086        	j	40082952 <z_impl_k_mutex_lock+0x26>
4008294f:	424800        	xorb	b4, b8, b0
					mutex->owner_orig_prio;

		mutex->lock_count++;
40082952:	331b      	addi.n	a3, a3, 1
40082954:	3239      	s32i.n	a3, a2, 12
		mutex->owner = _current;
40082956:	2638      	l32i.n	a3, a6, 8
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
40082958:	4249      	s32i.n	a4, a2, 16
		mutex->owner = _current;
4008295a:	2239      	s32i.n	a3, a2, 8
	XTOS_RESTORE_INTLEVEL(key);
4008295c:	13e670        	wsr.ps	a7
4008295f:	002010        	rsync
			mutex->owner_orig_prio);

		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
40082962:	0a0c      	movi.n	a10, 0
40082964:	002206        	j	400829f0 <z_impl_k_mutex_lock+0xc4>
40082967:	500000        	lsi	f0, a0, 0x140
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
4008296a:	cc2034        	lsi	f3, a0, 0x330
4008296d:	e67093        	lsi	f9, a0, 0x398
40082970:	201013        	lsi	f1, a0, 128
40082973:	0a7c00        	add.s	f7, f12, f0
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
40082976:	001d86        	j	400829f0 <z_impl_k_mutex_lock+0xc4>
	}

	new_prio = new_prio_for_inheritance(_current->base.prio,
40082979:	0e0a82        	l8ui	a8, a10, 14
4008297c:	0e09b2        	l8ui	a11, a9, 14
4008297f:	238800        	sext	a8, a8, 7
40082982:	23bb00        	sext	a11, a11, 7
40082985:	43bb80        	min	a11, a11, a8
40082988:	00a032        	movi	a3, 0
4008298b:	53bb30        	max	a11, a11, a3
					    mutex->owner->base.prio);

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
4008298e:	05ab87        	bge	a11, a8, 40082997 <z_impl_k_mutex_lock+0x6b>
		return z_set_prio(mutex->owner, new_prio);
40082991:	0068a5        	call8	4008301c <z_set_prio>
40082994:	203aa0        	or	a3, a10, a10
		resched = adjust_owner_prio(mutex, new_prio);
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
40082997:	f79b61        	l32r	a6, 40080804 <_iram_text_start+0x2b4>
4008299a:	20e440        	or	a14, a4, a4
4008299d:	05fd      	mov.n	a15, a5
4008299f:	02cd      	mov.n	a12, a2
400829a1:	07bd      	mov.n	a11, a7
400829a3:	06ad      	mov.n	a10, a6
400829a5:	0065a5        	call8	40083000 <z_pend_curr>
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
400829a8:	044a16        	beqz	a10, 400829f0 <z_impl_k_mutex_lock+0xc4>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400829ab:	006350        	rsil	a5, 3
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
400829ae:	0248      	l32i.n	a4, a2, 0

	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = (waiter != NULL) ?
400829b0:	42b8      	l32i.n	a11, a2, 16
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
400829b2:	0f1427        	beq	a4, a2, 400829c5 <z_impl_k_mutex_lock+0x99>
400829b5:	c48c      	beqz.n	a4, 400829c5 <z_impl_k_mutex_lock+0x99>
400829b7:	0e0442        	l8ui	a4, a4, 14
400829ba:	234400        	sext	a4, a4, 7
400829bd:	43b4b0        	min	a11, a4, a11
400829c0:	040c      	movi.n	a4, 0
400829c2:	53bb40        	max	a11, a11, a4
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);

	resched = adjust_owner_prio(mutex, new_prio) || resched;
400829c5:	22a8      	l32i.n	a10, a2, 8
	if (mutex->owner->base.prio != new_prio) {
400829c7:	0e0a22        	l8ui	a2, a10, 14
400829ca:	232200        	sext	a2, a2, 7
400829cd:	049b27        	bne	a11, a2, 400829d5 <z_impl_k_mutex_lock+0xa9>

	if (resched) {
400829d0:	439c      	beqz.n	a3, 400829e8 <z_impl_k_mutex_lock+0xbc>
400829d2:	000146        	j	400829db <z_impl_k_mutex_lock+0xaf>
		return z_set_prio(mutex->owner, new_prio);
400829d5:	006465        	call8	4008301c <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
400829d8:	ff4a16        	beqz	a10, 400829d0 <z_impl_k_mutex_lock+0xa4>
		z_reschedule(&lock, key);
400829db:	20b550        	or	a11, a5, a5
400829de:	20a660        	or	a10, a6, a6
400829e1:	0013a5        	call8	40082b1c <z_reschedule>
400829e4:	000186        	j	400829ee <z_impl_k_mutex_lock+0xc2>
400829e7:	e65000        	lsi	f0, a0, 0x398
	XTOS_RESTORE_INTLEVEL(key);
400829ea:	201013        	lsi	f1, a0, 128
400829ed:	5a7c00        	msub.s	f7, f12, f0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
400829f0:	0a2d      	mov.n	a2, a10
400829f2:	f01d      	retw.n

400829f4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
400829f4:	004136        	entry	a1, 32
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	CHECKIF(mutex->owner == NULL) {
400829f7:	2288      	l32i.n	a8, a2, 8
		return -EINVAL;
400829f9:	a96c      	movi.n	a9, -22
	CHECKIF(mutex->owner == NULL) {
400829fb:	062816        	beqz	a8, 40082a61 <z_impl_k_mutex_unlock+0x6d>
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
400829fe:	f6dc31        	l32r	a3, 40080570 <_iram_text_start+0x20>
		return -EPERM;
40082a01:	f97c      	movi.n	a9, -1
	CHECKIF(mutex->owner != _current) {
40082a03:	2338      	l32i.n	a3, a3, 8
40082a05:	589837        	bne	a8, a3, 40082a61 <z_impl_k_mutex_unlock+0x6d>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
40082a08:	0f0832        	l8ui	a3, a8, 15
40082a0b:	339a      	add.n	a3, a3, a9
40082a0d:	0f4832        	s8i	a3, a8, 15

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
40082a10:	3288      	l32i.n	a8, a2, 12
40082a12:	061826        	beqi	a8, 1, 40082a1c <z_impl_k_mutex_unlock+0x28>
		mutex->lock_count--;
40082a15:	889a      	add.n	a8, a8, a9
40082a17:	3289      	s32i.n	a8, a2, 12
		goto k_mutex_unlock_return;
40082a19:	000fc6        	j	40082a5c <z_impl_k_mutex_unlock+0x68>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082a1c:	006330        	rsil	a3, 3
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
40082a1f:	22a8      	l32i.n	a10, a2, 8
40082a21:	42b8      	l32i.n	a11, a2, 16
	if (mutex->owner->base.prio != new_prio) {
40082a23:	0e0a82        	l8ui	a8, a10, 14
40082a26:	238800        	sext	a8, a8, 7
40082a29:	021b87        	beq	a11, a8, 40082a2f <z_impl_k_mutex_unlock+0x3b>
		return z_set_prio(mutex->owner, new_prio);
40082a2c:	005ee5        	call8	4008301c <z_set_prio>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
40082a2f:	02ad      	mov.n	a10, a2
40082a31:	0067a5        	call8	400830ac <z_unpend_first_thread>

	mutex->owner = new_owner;
40082a34:	22a9      	s32i.n	a10, a2, 8

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
40082a36:	aa9c      	beqz.n	a10, 40082a54 <z_impl_k_mutex_unlock+0x60>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
40082a38:	0e0a82        	l8ui	a8, a10, 14
40082a3b:	238800        	sext	a8, a8, 7
40082a3e:	4289      	s32i.n	a8, a2, 16
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
40082a40:	020c      	movi.n	a2, 0
40082a42:	136a22        	s32i	a2, a10, 76
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
40082a45:	0025a5        	call8	40082ca0 <z_ready_thread>
		z_reschedule(&lock, key);
40082a48:	f76fa1        	l32r	a10, 40080804 <_iram_text_start+0x2b4>
40082a4b:	03bd      	mov.n	a11, a3
40082a4d:	000ce5        	call8	40082b1c <z_reschedule>
40082a50:	000206        	j	40082a5c <z_impl_k_mutex_unlock+0x68>
40082a53:	32a900        	orbc	b10, b9, b0
	XTOS_RESTORE_INTLEVEL(key);
40082a56:	13e630        	wsr.ps	a3
40082a59:	002010        	rsync
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
40082a5c:	0019e5        	call8	40082bfc <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
40082a5f:	090c      	movi.n	a9, 0
}
40082a61:	092d      	mov.n	a2, a9
40082a63:	f01d      	retw.n
40082a65:	000000        	ill

40082a68 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
40082a68:	004136        	entry	a1, 32
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
40082a6b:	f76721        	l32r	a2, 40080808 <_iram_text_start+0x2b8>
40082a6e:	002282        	l32i	a8, a2, 0
40082a71:	013816        	beqz	a8, 40082a88 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
40082a74:	fecaa5        	call8	40081720 <z_clock_elapsed>
40082a77:	002282        	l32i	a8, a2, 0
40082a7a:	f6bd21        	l32r	a2, 40080570 <_iram_text_start+0x20>
40082a7d:	a8aa      	add.n	a10, a8, a10
40082a7f:	42a9      	s32i.n	a10, a2, 16
		z_set_timeout_expiry(slice_time, false);
40082a81:	0b0c      	movi.n	a11, 0
40082a83:	08ad      	mov.n	a10, a8
40082a85:	00b2e5        	call8	400835b4 <z_set_timeout_expiry>
	}
}
40082a88:	f01d      	retw.n
	...

40082a8c <z_swap_irqlock>:
{
40082a8c:	004136        	entry	a1, 32
	old_thread = _current;
40082a8f:	f6b831        	l32r	a3, 40080570 <_iram_text_start+0x20>
40082a92:	2358      	l32i.n	a5, a3, 8
	return _kernel.ready_q.cache;
40082a94:	e348      	l32i.n	a4, a3, 56
	if (new_thread != old_thread) {
40082a96:	121547        	beq	a5, a4, 40082aac <z_swap_irqlock+0x20>
		z_reset_time_slice();
40082a99:	fffce5        	call8	40082a68 <z_reset_time_slice>
		old_thread->swap_retval = -EAGAIN;
40082a9c:	587c      	movi.n	a8, -11
40082a9e:	1424a2        	l32i	a10, a4, 80
40082aa1:	136582        	s32i	a8, a5, 76
		_current_cpu->current = new_thread;
40082aa4:	2349      	s32i.n	a4, a3, 8
40082aa6:	50c5b2        	addi	a11, a5, 80
40082aa9:	fed865        	call8	40081830 <xtensa_switch>
40082aac:	13e620        	wsr.ps	a2
40082aaf:	002010        	rsync
	return _current->swap_retval;
40082ab2:	2338      	l32i.n	a3, a3, 8
}
40082ab4:	132322        	l32i	a2, a3, 76
40082ab7:	f01d      	retw.n
40082ab9:	000000        	ill

40082abc <z_swap$isra$14>:
static inline int z_swap(struct k_spinlock *lock, k_spinlock_key_t key)
40082abc:	004136        	entry	a1, 32
	old_thread = _current;
40082abf:	f6ac31        	l32r	a3, 40080570 <_iram_text_start+0x20>
40082ac2:	2358      	l32i.n	a5, a3, 8
40082ac4:	e348      	l32i.n	a4, a3, 56
	if (new_thread != old_thread) {
40082ac6:	121547        	beq	a5, a4, 40082adc <z_swap$isra$14+0x20>
		z_reset_time_slice();
40082ac9:	fff9e5        	call8	40082a68 <z_reset_time_slice>
		old_thread->swap_retval = -EAGAIN;
40082acc:	587c      	movi.n	a8, -11
40082ace:	1424a2        	l32i	a10, a4, 80
40082ad1:	136582        	s32i	a8, a5, 76
		_current_cpu->current = new_thread;
40082ad4:	2349      	s32i.n	a4, a3, 8
40082ad6:	50c5b2        	addi	a11, a5, 80
40082ad9:	fed565        	call8	40081830 <xtensa_switch>
40082adc:	13e620        	wsr.ps	a2
40082adf:	002010        	rsync
	return _current->swap_retval;
40082ae2:	2338      	l32i.n	a3, a3, 8
}
40082ae4:	132322        	l32i	a2, a3, 76
40082ae7:	f01d      	retw.n
40082ae9:	000000        	ill

40082aec <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
40082aec:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082aef:	006340        	rsil	a4, 3
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
40082af2:	f69f81        	l32r	a8, 40080570 <_iram_text_start+0x20>
40082af5:	00a092        	movi	a9, 0
40082af8:	046892        	s32i	a9, a8, 16
		} else {
			return t / (from_hz / to_hz);
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
40082afb:	1182e0        	slli	a8, a2, 2
40082afe:	808820        	add	a8, a8, a2
		slice_time = k_ms_to_ticks_ceil32(slice);
40082b01:	f74121        	l32r	a2, 40080808 <_iram_text_start+0x2b8>
40082b04:	1188f0        	slli	a8, a8, 1
40082b07:	0289      	s32i.n	a8, a2, 0
		slice_max_prio = prio;
40082b09:	f74021        	l32r	a2, 4008080c <_iram_text_start+0x2bc>
40082b0c:	0239      	s32i.n	a3, a2, 0
		z_reset_time_slice();
40082b0e:	fff5a5        	call8	40082a68 <z_reset_time_slice>
	XTOS_RESTORE_INTLEVEL(key);
40082b11:	13e640        	wsr.ps	a4
40082b14:	002010        	rsync
	}
}
40082b17:	f01d      	retw.n
40082b19:	000000        	ill

40082b1c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
40082b1c:	004136        	entry	a1, 32
}

static ALWAYS_INLINE bool arch_irq_unlocked(unsigned int key)
{
	return (key & 0xf) == 0; /* INTLEVEL field */
40082b1f:	348030        	extui	a8, a3, 0, 4
40082b22:	20a330        	or	a10, a3, a3
	return arch_irq_unlocked(key) && !arch_is_in_isr();
40082b25:	017856        	bnez	a8, 40082b40 <z_reschedule+0x24>

static ALWAYS_INLINE _cpu_t *arch_curr_cpu(void)
{
	_cpu_t *cpu;

	cpu = (_cpu_t *)RSR(CONFIG_XTENSA_KERNEL_CPU_PTR_SR);
40082b28:	03f480        	rsr.misc0	a8
40082b2b:	002882        	l32i	a8, a8, 0
40082b2e:	e8cc      	bnez.n	a8, 40082b40 <z_reschedule+0x24>
40082b30:	f69081        	l32r	a8, 40080570 <_iram_text_start+0x20>
	if (resched(key.key) && need_swap()) {
40082b33:	e898      	l32i.n	a9, a8, 56
40082b35:	2888      	l32i.n	a8, a8, 8
40082b37:	051987        	beq	a9, a8, 40082b40 <z_reschedule+0x24>
		z_swap(lock, key);
40082b3a:	fff825        	call8	40082abc <z_swap$isra$14>
40082b3d:	000146        	j	40082b46 <z_reschedule+0x2a>
	XTOS_RESTORE_INTLEVEL(key);
40082b40:	13e6a0        	wsr.ps	a10
40082b43:	002010        	rsync
	} else {
		k_spin_unlock(lock, key);
	}
}
40082b46:	f01d      	retw.n

40082b48 <z_reschedule_irqlock>:

void z_reschedule_irqlock(uint32_t key)
{
40082b48:	004136        	entry	a1, 32
	return (key & 0xf) == 0; /* INTLEVEL field */
40082b4b:	348020        	extui	a8, a2, 0, 4
40082b4e:	20a220        	or	a10, a2, a2
	return arch_irq_unlocked(key) && !arch_is_in_isr();
40082b51:	00f856        	bnez	a8, 40082b64 <z_reschedule_irqlock+0x1c>
40082b54:	03f480        	rsr.misc0	a8
40082b57:	002882        	l32i	a8, a8, 0
40082b5a:	006856        	bnez	a8, 40082b64 <z_reschedule_irqlock+0x1c>
	if (resched(key)) {
		z_swap_irqlock(key);
40082b5d:	fff2e5        	call8	40082a8c <z_swap_irqlock>
40082b60:	000186        	j	40082b6a <z_reschedule_irqlock+0x22>
40082b63:	e6a000        	lsi	f0, a0, 0x398
	XTOS_RESTORE_INTLEVEL(key);
40082b66:	201013        	lsi	f1, a0, 128
40082b69:	f01d00        	subx8	a1, a13, a0

40082b6c <z_reschedule_unlocked>:
{
40082b6c:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082b6f:	0063a0        	rsil	a10, 3
	(void) z_reschedule_irqlock(arch_irq_lock());
40082b72:	fffd65        	call8	40082b48 <z_reschedule_irqlock>
}
40082b75:	f01d      	retw.n
	...

40082b78 <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
40082b78:	004136        	entry	a1, 32
40082b7b:	0063a0        	rsil	a10, 3
	--_current->base.sched_locked;
40082b7e:	f67c81        	l32r	a8, 40080570 <_iram_text_start+0x20>
40082b81:	2898      	l32i.n	a9, a8, 8
40082b83:	0f0982        	l8ui	a8, a9, 15
40082b86:	880b      	addi.n	a8, a8, -1
40082b88:	0f4982        	s8i	a8, a9, 15
	XTOS_RESTORE_INTLEVEL(key);
40082b8b:	13e6a0        	wsr.ps	a10
40082b8e:	002010        	rsync
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
40082b91:	f01d      	retw.n
	...

40082b94 <z_get_next_switch_handle>:
	_current_cpu->current = new_thread;
}

#ifdef CONFIG_USE_SWITCH
void *z_get_next_switch_handle(void *interrupted)
{
40082b94:	004136        	entry	a1, 32
	_current->switch_handle = interrupted;
40082b97:	f67681        	l32r	a8, 40080570 <_iram_text_start+0x20>
40082b9a:	28a8      	l32i.n	a10, a8, 8
	return _kernel.ready_q.cache;
40082b9c:	e898      	l32i.n	a9, a8, 56
40082b9e:	146a22        	s32i	a2, a10, 80
#endif
		}
	}
#else
	struct k_thread *thread = z_get_next_ready_thread();
	if (_current != thread) {
40082ba1:	011a97        	beq	a10, a9, 40082ba6 <z_get_next_switch_handle+0x12>
	_current_cpu->current = new_thread;
40082ba4:	2899      	s32i.n	a9, a8, 8
		set_current(thread);
	}
#endif

	wait_for_switch(_current);
	return _current->switch_handle;
40082ba6:	2888      	l32i.n	a8, a8, 8
}
40082ba8:	142822        	l32i	a2, a8, 80
40082bab:	f01d      	retw.n
40082bad:	000000        	ill

40082bb0 <update_cache>:
{
40082bb0:	004136        	entry	a1, 32
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
40082bb3:	f717a1        	l32r	a10, 40080810 <_iram_text_start+0x2c0>
40082bb6:	00e665        	call8	40083a1c <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
40082bb9:	f66d31        	l32r	a3, 40080570 <_iram_text_start+0x20>
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
40082bbc:	204aa0        	or	a4, a10, a10
	if (_current->base.thread_state & _THREAD_ABORTING) {
40082bbf:	022382        	l32i	a8, a3, 8
40082bc2:	0d0892        	l8ui	a9, a8, 13
40082bc5:	086957        	bbci	a9, 5, 40082bd1 <update_cache+0x21>
		_current->base.thread_state |= _THREAD_DEAD;
40082bc8:	08a0a2        	movi	a10, 8
40082bcb:	2099a0        	or	a9, a9, a10
40082bce:	0d4892        	s8i	a9, a8, 13
	return thread ? thread : _current_cpu->idle_thread;
40082bd1:	04cc      	bnez.n	a4, 40082bd5 <update_cache+0x25>
40082bd3:	3348      	l32i.n	a4, a3, 12
	if (preempt_ok != 0) {
40082bd5:	42dc      	bnez.n	a2, 40082bed <update_cache+0x3d>
	if (z_is_thread_prevented_from_running(_current)) {
40082bd7:	0d0892        	l8ui	a9, a8, 13
40082bda:	449090        	extui	a9, a9, 0, 5
40082bdd:	c9cc      	bnez.n	a9, 40082bed <update_cache+0x3d>
	if (is_preempt(_current) || is_metairq(thread)) {
40082bdf:	071892        	l16ui	a9, a8, 14
40082be2:	7fa0a2        	movi	a10, 127
40082be5:	04ba97        	bgeu	a10, a9, 40082bed <update_cache+0x3d>
		_kernel.ready_q.cache = _current;
40082be8:	e389      	s32i.n	a8, a3, 56
40082bea:	000286        	j	40082bf8 <update_cache+0x48>
		if (thread != _current) {
40082bed:	051847        	beq	a8, a4, 40082bf6 <update_cache+0x46>
			z_reset_time_slice();
40082bf0:	201110        	or	a1, a1, a1
40082bf3:	ffe765        	call8	40082a68 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
40082bf6:	e349      	s32i.n	a4, a3, 56
}
40082bf8:	f01d      	retw.n
	...

40082bfc <k_sched_unlock>:
{
40082bfc:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082bff:	006320        	rsil	a2, 3
		++_current->base.sched_locked;
40082c02:	f65b81        	l32r	a8, 40080570 <_iram_text_start+0x20>
		update_cache(0);
40082c05:	00a0a2        	movi	a10, 0
		++_current->base.sched_locked;
40082c08:	022892        	l32i	a9, a8, 8
40082c0b:	0f0982        	l8ui	a8, a9, 15
40082c0e:	01c882        	addi	a8, a8, 1
40082c11:	0f4982        	s8i	a8, a9, 15
		update_cache(0);
40082c14:	fff9a5        	call8	40082bb0 <update_cache>
	XTOS_RESTORE_INTLEVEL(key);
40082c17:	13e620        	wsr.ps	a2
40082c1a:	002010        	rsync
	z_reschedule_unlocked();
40082c1d:	fff4e5        	call8	40082b6c <z_reschedule_unlocked>
}
40082c20:	f01d      	retw.n
	...

40082c24 <ready_thread>:
{
40082c24:	004136        	entry	a1, 32
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
40082c27:	0d0282        	l8ui	a8, a2, 13
40082c2a:	448080        	extui	a8, a8, 0, 5
40082c2d:	06b856        	bnez	a8, 40082c9c <ready_thread+0x78>
	if (z_is_thread_ready(thread)) {
40082c30:	62b8      	l32i.n	a11, a2, 24
40082c32:	066b56        	bnez	a11, 40082c9c <ready_thread+0x78>
40082c35:	f64ea1        	l32r	a10, 40080570 <_iram_text_start+0x20>
{
	struct k_thread *t;

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40082c38:	1f0c      	movi.n	a15, 1
40082c3a:	fa88      	l32i.n	a8, a10, 60
40082c3c:	0bcd      	mov.n	a12, a11
40082c3e:	93cf80        	movnez	a12, a15, a8
40082c41:	74c0c0        	extui	a12, a12, 0, 8
40082c44:	102ad2        	l32i	a13, a10, 64
40082c47:	f6f2e1        	l32r	a14, 40080810 <_iram_text_start+0x2c0>
40082c4a:	fcac      	beqz.n	a12, 40082c7d <ready_thread+0x59>
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
40082c4c:	c098e0        	sub	a9, a8, a14
40082c4f:	93bf90        	movnez	a11, a15, a9
40082c52:	7490b0        	extui	a9, a11, 0, 8
40082c55:	49ac      	beqz.n	a9, 40082c7d <ready_thread+0x59>
	if (thread_1->base.prio < thread_2->base.prio) {
40082c57:	0e0292        	l8ui	a9, a2, 14
40082c5a:	239900        	sext	a9, a9, 7
40082c5d:	0e08b2        	l8ui	a11, a8, 14
40082c60:	23bb00        	sext	a11, a11, 7
40082c63:	0da9b7        	bge	a9, a11, 40082c74 <ready_thread+0x50>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	node->prev = successor->prev;
40082c66:	1898      	l32i.n	a9, a8, 4
	node->next = successor;
40082c68:	0289      	s32i.n	a8, a2, 0
	node->prev = successor->prev;
40082c6a:	1299      	s32i.n	a9, a2, 4
	successor->prev->next = node;
40082c6c:	0929      	s32i.n	a2, a9, 0
	successor->prev = node;
40082c6e:	1829      	s32i.n	a2, a8, 4
40082c70:	0005c6        	j	40082c8b <ready_thread+0x67>
40082c73:	1d8700        	lsi	f0, a7, 116
	return (node == list->tail) ? NULL : node->next;
40082c76:	288205        	call0	400ab498 <_iram_text_end+0x2755e>
40082c79:	f85600        	lsi	f0, a6, 0x3e0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40082c7c:	d2fd      	lsi	f15, a2, 8
	node->prev = list->tail;
40082c7e:	820162        	l8ui	a6, a1, 130
	list->tail->next = node;
40082c81:	102a      	add.n	a1, a0, a2
	node->next = list;
40082c83:	0062e2        	s32i	a14, a2, 0
	list->tail->next = node;
40082c86:	0829      	s32i.n	a2, a8, 0
	list->tail = node;
40082c88:	106a22        	s32i	a2, a10, 64
	thread->base.thread_state |= states;
40082c8b:	0d0282        	l8ui	a8, a2, 13
40082c8e:	80af92        	movi	a9, -128
40082c91:	208890        	or	a8, a8, a9
40082c94:	0d4282        	s8i	a8, a2, 13
		update_cache(0);
40082c97:	0a0c      	movi.n	a10, 0
40082c99:	fff165        	call8	40082bb0 <update_cache>
}
40082c9c:	f01d      	retw.n
	...

40082ca0 <z_ready_thread>:
{
40082ca0:	004136        	entry	a1, 32
40082ca3:	02ad      	mov.n	a10, a2
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082ca5:	006330        	rsil	a3, 3
		ready_thread(thread);
40082ca8:	fff7a5        	call8	40082c24 <ready_thread>
	XTOS_RESTORE_INTLEVEL(key);
40082cab:	13e630        	wsr.ps	a3
40082cae:	002010        	rsync
}
40082cb1:	f01d      	retw.n
	...

40082cb4 <z_thread_timeout>:
{
40082cb4:	004136        	entry	a1, 32
	struct k_thread *thread = CONTAINER_OF(timeout,
40082cb7:	e8c232        	addi	a3, a2, -24
	if (thread->base.pended_on != NULL) {
40082cba:	022342        	l32i	a4, a3, 8
40082cbd:	f5c222        	addi	a2, a2, -11
40082cc0:	01c416        	beqz	a4, 40082ce0 <z_thread_timeout+0x2c>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082cc3:	006340        	rsil	a4, 3
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
40082cc6:	03ad      	mov.n	a10, a3
40082cc8:	00d3e5        	call8	40083a08 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
40082ccb:	000282        	l8ui	a8, a2, 0
40082cce:	d97c      	movi.n	a9, -3
40082cd0:	108890        	and	a8, a8, a9
40082cd3:	004282        	s8i	a8, a2, 0
		thread->base.pended_on = NULL;
40082cd6:	080c      	movi.n	a8, 0
40082cd8:	2389      	s32i.n	a8, a3, 8
	XTOS_RESTORE_INTLEVEL(key);
40082cda:	13e640        	wsr.ps	a4
40082cdd:	002010        	rsync
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
40082ce0:	000282        	l8ui	a8, a2, 0
40082ce3:	b96c      	movi.n	a9, -21
40082ce5:	108890        	and	a8, a8, a9
40082ce8:	004282        	s8i	a8, a2, 0
	z_ready_thread(thread);
40082ceb:	03ad      	mov.n	a10, a3
40082ced:	fffb25        	call8	40082ca0 <z_ready_thread>
}
40082cf0:	f01d      	retw.n
	...

40082cf4 <z_sched_start>:
{
40082cf4:	004136        	entry	a1, 32
40082cf7:	02ad      	mov.n	a10, a2
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082cf9:	006320        	rsil	a2, 3
	if (z_has_thread_started(thread)) {
40082cfc:	0d0a82        	l8ui	a8, a10, 13
40082cff:	0be827        	bbsi	a8, 2, 40082d0e <z_sched_start+0x1a>
	XTOS_RESTORE_INTLEVEL(key);
40082d02:	13e620        	wsr.ps	a2
40082d05:	002010        	rsync
		return;
40082d08:	0005c6        	j	40082d23 <z_sched_start+0x2f>
40082d0b:	000000        	ill
	thread->base.thread_state &= ~_THREAD_PRESTART;
40082d0e:	fbaf92        	movi	a9, -5
40082d11:	108890        	and	a8, a8, a9
40082d14:	0d4a82        	s8i	a8, a10, 13
	ready_thread(thread);
40082d17:	fff0e5        	call8	40082c24 <ready_thread>
	z_reschedule(&sched_spinlock, key);
40082d1a:	f6bea1        	l32r	a10, 40080814 <_iram_text_start+0x2c4>
40082d1d:	20b220        	or	a11, a2, a2
40082d20:	ffdfa5        	call8	40082b1c <z_reschedule>
}
40082d23:	000090        	retw
	...

40082d28 <z_move_thread_to_end_of_prio_q>:
{
40082d28:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082d2b:	006330        	rsil	a3, 3
		if (z_is_thread_queued(thread)) {
40082d2e:	0d0282        	l8ui	a8, a2, 13
40082d31:	056877        	bbci	a8, 7, 40082d3a <z_move_thread_to_end_of_prio_q+0x12>
	sys_dlist_remove(&thread->base.qnode_dlist);
40082d34:	20a220        	or	a10, a2, a2
40082d37:	00cd25        	call8	40083a08 <sys_dlist_remove>
	return list->head == list;
40082d3a:	f60d91        	l32r	a9, 40080570 <_iram_text_start+0x20>
40082d3d:	f6b4d1        	l32r	a13, 40080810 <_iram_text_start+0x2c0>
40082d40:	0f2982        	l32i	a8, a9, 60
40082d43:	1029c2        	l32i	a12, a9, 64
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40082d46:	027816        	beqz	a8, 40082d71 <z_move_thread_to_end_of_prio_q+0x49>
40082d49:	2418d7        	beq	a8, a13, 40082d71 <z_move_thread_to_end_of_prio_q+0x49>
	if (thread_1->base.prio < thread_2->base.prio) {
40082d4c:	0e02a2        	l8ui	a10, a2, 14
40082d4f:	23aa00        	sext	a10, a10, 7
40082d52:	0e08b2        	l8ui	a11, a8, 14
40082d55:	23bb00        	sext	a11, a11, 7
40082d58:	0caab7        	bge	a10, a11, 40082d68 <z_move_thread_to_end_of_prio_q+0x40>
	node->prev = successor->prev;
40082d5b:	18a8      	l32i.n	a10, a8, 4
	node->next = successor;
40082d5d:	0289      	s32i.n	a8, a2, 0
	node->prev = successor->prev;
40082d5f:	12a9      	s32i.n	a10, a2, 4
	successor->prev->next = node;
40082d61:	0a29      	s32i.n	a2, a10, 0
	successor->prev = node;
40082d63:	1829      	s32i.n	a2, a8, 4
40082d65:	000586        	j	40082d7f <z_move_thread_to_end_of_prio_q+0x57>
	return (node == list->tail) ? NULL : node->next;
40082d68:	051c87        	beq	a12, a8, 40082d71 <z_move_thread_to_end_of_prio_q+0x49>
40082d6b:	002882        	l32i	a8, a8, 0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40082d6e:	fe0856        	bnez	a8, 40082d52 <z_move_thread_to_end_of_prio_q+0x2a>
	node->prev = list->tail;
40082d71:	0162c2        	s32i	a12, a2, 4
	list->tail->next = node;
40082d74:	102982        	l32i	a8, a9, 64
	node->next = list;
40082d77:	0062d2        	s32i	a13, a2, 0
	list->tail->next = node;
40082d7a:	0829      	s32i.n	a2, a8, 0
	list->tail = node;
40082d7c:	106922        	s32i	a2, a9, 64
	thread->base.thread_state |= states;
40082d7f:	0d0282        	l8ui	a8, a2, 13
40082d82:	80afa2        	movi	a10, -128
40082d85:	2088a0        	or	a8, a8, a10
		update_cache(thread == _current);
40082d88:	29a8      	l32i.n	a10, a9, 8
40082d8a:	0d4282        	s8i	a8, a2, 13
40082d8d:	c0aa20        	sub	a10, a10, a2
40082d90:	180c      	movi.n	a8, 1
40082d92:	020c      	movi.n	a2, 0
40082d94:	8328a0        	moveqz	a2, a8, a10
40082d97:	02ad      	mov.n	a10, a2
40082d99:	ffe165        	call8	40082bb0 <update_cache>
	XTOS_RESTORE_INTLEVEL(key);
40082d9c:	13e630        	wsr.ps	a3
40082d9f:	002010        	rsync
}
40082da2:	f01d      	retw.n

40082da4 <z_time_slice>:
{
40082da4:	004136        	entry	a1, 32
	if (slice_time && sliceable(_current)) {
40082da7:	f69881        	l32r	a8, 40080808 <_iram_text_start+0x2b8>
40082daa:	002892        	l32i	a9, a8, 0
40082dad:	f5f081        	l32r	a8, 40080570 <_iram_text_start+0x20>
40082db0:	039916        	beqz	a9, 40082ded <z_time_slice+0x49>
40082db3:	28a8      	l32i.n	a10, a8, 8
		&& !z_is_thread_timeout_active(thread);
40082db5:	7fa0b2        	movi	a11, 127
40082db8:	071a92        	l16ui	a9, a10, 14
40082dbb:	2e3b97        	bltu	a11, a9, 40082ded <z_time_slice+0x49>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
40082dbe:	f69391        	l32r	a9, 4008080c <_iram_text_start+0x2bc>
40082dc1:	0e0ab2        	l8ui	a11, a10, 14
40082dc4:	0998      	l32i.n	a9, a9, 0
40082dc6:	23bb00        	sext	a11, a11, 7
40082dc9:	202b97        	blt	a11, a9, 40082ded <z_time_slice+0x49>
		&& !z_is_idle_thread_object(thread)
40082dcc:	f68891        	l32r	a9, 400807ec <_iram_text_start+0x29c>
40082dcf:	1a1a97        	beq	a10, a9, 40082ded <z_time_slice+0x49>
		&& !z_is_thread_timeout_active(thread);
40082dd2:	6a98      	l32i.n	a9, a10, 24
40082dd4:	015956        	bnez	a9, 40082ded <z_time_slice+0x49>
		if (ticks >= _current_cpu->slice_ticks) {
40082dd7:	4898      	l32i.n	a9, a8, 16
40082dd9:	082297        	blt	a2, a9, 40082de5 <z_time_slice+0x41>
			z_move_thread_to_end_of_prio_q(_current);
40082ddc:	fff4a5        	call8	40082d28 <z_move_thread_to_end_of_prio_q>
			z_reset_time_slice();
40082ddf:	ffc8a5        	call8	40082a68 <z_reset_time_slice>
40082de2:	0002c6        	j	40082df1 <z_time_slice+0x4d>
			_current_cpu->slice_ticks -= ticks;
40082de5:	c09920        	sub	a9, a9, a2
40082de8:	4899      	s32i.n	a9, a8, 16
40082dea:	0000c6        	j	40082df1 <z_time_slice+0x4d>
		_current_cpu->slice_ticks = 0;
40082ded:	020c      	movi.n	a2, 0
40082def:	4829      	s32i.n	a2, a8, 16
}
40082df1:	f01d      	retw.n
	...

40082df4 <z_impl_k_thread_suspend>:
{
40082df4:	004136        	entry	a1, 32
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
40082df7:	18c2a2        	addi	a10, a2, 24
40082dfa:	007865        	call8	40083580 <z_abort_timeout>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082dfd:	006330        	rsil	a3, 3
		if (z_is_thread_queued(thread)) {
40082e00:	0d0242        	l8ui	a4, a2, 13
40082e03:	0d6477        	bbci	a4, 7, 40082e14 <z_impl_k_thread_suspend+0x20>
	sys_dlist_remove(&thread->base.qnode_dlist);
40082e06:	02ad      	mov.n	a10, a2
40082e08:	00bfe5        	call8	40083a08 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
40082e0b:	0d0282        	l8ui	a8, a2, 13
40082e0e:	648080        	extui	a8, a8, 0, 7
40082e11:	0d4282        	s8i	a8, a2, 13
	thread->base.thread_state |= _THREAD_SUSPENDED;
40082e14:	0d0282        	l8ui	a8, a2, 13
40082e17:	041c      	movi.n	a4, 16
40082e19:	208840        	or	a8, a8, a4
		update_cache(thread == _current);
40082e1c:	f5d541        	l32r	a4, 40080570 <_iram_text_start+0x20>
40082e1f:	0d4282        	s8i	a8, a2, 13
40082e22:	24a8      	l32i.n	a10, a4, 8
40082e24:	190c      	movi.n	a9, 1
40082e26:	c0aa20        	sub	a10, a10, a2
40082e29:	080c      	movi.n	a8, 0
40082e2b:	8389a0        	moveqz	a8, a9, a10
40082e2e:	08ad      	mov.n	a10, a8
40082e30:	ffd7e5        	call8	40082bb0 <update_cache>
	XTOS_RESTORE_INTLEVEL(key);
40082e33:	13e630        	wsr.ps	a3
40082e36:	002010        	rsync
	if (thread == _current) {
40082e39:	2438      	l32i.n	a3, a4, 8
40082e3b:	029327        	bne	a3, a2, 40082e41 <z_impl_k_thread_suspend+0x4d>
		z_reschedule_unlocked();
40082e3e:	ffd2e5        	call8	40082b6c <z_reschedule_unlocked>
}
40082e41:	f01d      	retw.n
	...

40082e44 <z_thread_single_abort>:
{
40082e44:	004136        	entry	a1, 32
	if (thread->fn_abort != NULL) {
40082e47:	112232        	l32i	a3, a2, 68
40082e4a:	002316        	beqz	a3, 40082e50 <z_thread_single_abort+0xc>
		thread->fn_abort();
40082e4d:	0003e0        	callx8	a3
40082e50:	18c2a2        	addi	a10, a2, 24
40082e53:	0072e5        	call8	40083580 <z_abort_timeout>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082e56:	006340        	rsil	a4, 3
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
40082e59:	0d0232        	l8ui	a3, a2, 13
40082e5c:	445030        	extui	a5, a3, 0, 5
40082e5f:	032556        	bnez	a5, 40082e95 <z_thread_single_abort+0x51>
		if (z_is_thread_ready(thread)) {
40082e62:	062252        	l32i	a5, a2, 24
40082e65:	c5ec      	bnez.n	a5, 40082e95 <z_thread_single_abort+0x51>
			if (z_is_thread_queued(thread)) {
40082e67:	233300        	sext	a3, a3, 7
40082e6a:	00e3d6        	bgez	a3, 40082e7c <z_thread_single_abort+0x38>
	sys_dlist_remove(&thread->base.qnode_dlist);
40082e6d:	20a220        	or	a10, a2, a2
40082e70:	00b965        	call8	40083a08 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
40082e73:	0d0232        	l8ui	a3, a2, 13
40082e76:	643030        	extui	a3, a3, 0, 7
40082e79:	0d4232        	s8i	a3, a2, 13
			update_cache(thread == _current);
40082e7c:	f5bd31        	l32r	a3, 40080570 <_iram_text_start+0x20>
40082e7f:	150c      	movi.n	a5, 1
40082e81:	23a8      	l32i.n	a10, a3, 8
40082e83:	030c      	movi.n	a3, 0
40082e85:	c0aa20        	sub	a10, a10, a2
40082e88:	8335a0        	moveqz	a3, a5, a10
40082e8b:	03ad      	mov.n	a10, a3
40082e8d:	ffd225        	call8	40082bb0 <update_cache>
40082e90:	000606        	j	40082eac <z_thread_single_abort+0x68>
40082e93:	170000        	lsi	f0, a0, 92
			if (z_is_thread_pending(thread)) {
40082e96:	ad1363        	lsi	f6, a3, 0x2b4
	sys_dlist_remove(&thread->base.qnode_dlist);
40082e99:	b6e502        	s32c1i	a0, a5, 0x2d8
40082e9c:	023200        	andb	b3, b2, b0
	thread->base.thread_state &= ~_THREAD_PENDING;
40082e9f:	7c0d      	lsi	f0, a12, 48
40082ea1:	3350d5        	call4	400b63b0 <_iram_text_end+0x32476>
40082ea4:	423210        	xorb	b3, b2, b1
40082ea7:	0c0d      	mov.n	a0, a12
				thread->base.pended_on = NULL;
40082ea9:	223903        	lsi	f0, a9, 136
		thread->base.thread_state |= mask;
40082eac:	0d0232        	l8ui	a3, a2, 13
40082eaf:	850c      	movi.n	a5, 8
40082eb1:	203350        	or	a3, a3, a5
40082eb4:	0d4232        	s8i	a3, a2, 13
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
40082eb7:	000886        	j	40082edd <z_thread_single_abort+0x99>
40082eba:	a20000        	muluh	a0, a0, a0
40082ebd:	2518c3        	lsi	f12, a8, 148
40082ec0:	006c      	movi.n	a0, -32
	sys_dlist_remove(&thread->base.qnode_dlist);
40082ec2:	20a330        	or	a10, a3, a3
40082ec5:	00b425        	call8	40083a08 <sys_dlist_remove>
40082ec8:	0d0382        	l8ui	a8, a3, 13
40082ecb:	d97c      	movi.n	a9, -3
40082ecd:	108890        	and	a8, a8, a9
40082ed0:	0d4382        	s8i	a8, a3, 13
			waiter->base.pended_on = NULL;
40082ed3:	2359      	s32i.n	a5, a3, 8
40082ed5:	136352        	s32i	a5, a3, 76
			ready_thread(waiter);
40082ed8:	03ad      	mov.n	a10, a3
40082eda:	ffd4a5        	call8	40082c24 <ready_thread>
	return list->head == list;
40082edd:	0c2232        	l32i	a3, a2, 48
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
40082ee0:	00a052        	movi	a5, 0
40082ee3:	051357        	beq	a3, a5, 40082eec <z_thread_single_abort+0xa8>
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
40082ee6:	30c282        	addi	a8, a2, 48
40082ee9:	cf9387        	bne	a3, a8, 40082ebc <z_thread_single_abort+0x78>
	XTOS_RESTORE_INTLEVEL(key);
40082eec:	13e640        	wsr.ps	a4
40082eef:	002010        	rsync
}
40082ef2:	f01d      	retw.n

40082ef4 <unready_thread>:
{
40082ef4:	004136        	entry	a1, 32
	if (z_is_thread_queued(thread)) {
40082ef7:	0d0282        	l8ui	a8, a2, 13
40082efa:	0e6877        	bbci	a8, 7, 40082f0c <unready_thread+0x18>
	sys_dlist_remove(&thread->base.qnode_dlist);
40082efd:	20a220        	or	a10, a2, a2
40082f00:	00b065        	call8	40083a08 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
40082f03:	0d0282        	l8ui	a8, a2, 13
40082f06:	648080        	extui	a8, a8, 0, 7
40082f09:	0d4282        	s8i	a8, a2, 13
	update_cache(thread == _current);
40082f0c:	f59981        	l32r	a8, 40080570 <_iram_text_start+0x20>
40082f0f:	0228a2        	l32i	a10, a8, 8
40082f12:	180c      	movi.n	a8, 1
40082f14:	c0aa20        	sub	a10, a10, a2
40082f17:	020c      	movi.n	a2, 0
40082f19:	8328a0        	moveqz	a2, a8, a10
40082f1c:	02ad      	mov.n	a10, a2
40082f1e:	ffc925        	call8	40082bb0 <update_cache>
}
40082f21:	f01d      	retw.n
	...

40082f24 <z_remove_thread_from_ready_q>:
{
40082f24:	004136        	entry	a1, 32
40082f27:	02ad      	mov.n	a10, a2
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082f29:	006330        	rsil	a3, 3
		unready_thread(thread);
40082f2c:	fffc65        	call8	40082ef4 <unready_thread>
	XTOS_RESTORE_INTLEVEL(key);
40082f2f:	13e630        	wsr.ps	a3
40082f32:	002010        	rsync
}
40082f35:	f01d      	retw.n
	...

40082f38 <z_tick_sleep$part$23>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(int32_t ticks)
40082f38:	004136        	entry	a1, 32
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
40082f3b:	007965        	call8	400836d0 <z_tick_get_32>
40082f3e:	8032a0        	add	a3, a2, a10
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40082f41:	006350        	rsil	a5, 3
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	z_remove_thread_from_ready_q(_current);
40082f44:	f58b41        	l32r	a4, 40080570 <_iram_text_start+0x20>
40082f47:	0224a2        	l32i	a10, a4, 8
40082f4a:	fffda5        	call8	40082f24 <z_remove_thread_from_ready_q>
	z_add_thread_timeout(_current, timeout);
40082f4d:	0224a2        	l32i	a10, a4, 8
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
40082f50:	f632b1        	l32r	a11, 40080818 <_iram_text_start+0x2c8>
40082f53:	02cd      	mov.n	a12, a2
40082f55:	31df20        	srai	a13, a2, 31
40082f58:	18caa2        	addi	a10, a10, 24
40082f5b:	004e25        	call8	4008343c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
40082f5e:	2428      	l32i.n	a2, a4, 8
	thread->base.thread_state |= _THREAD_SUSPENDED;
40082f60:	041c      	movi.n	a4, 16
40082f62:	0d0282        	l8ui	a8, a2, 13

	(void)z_swap(&local_lock, key);
40082f65:	05ad      	mov.n	a10, a5
40082f67:	208840        	or	a8, a8, a4
40082f6a:	0d4282        	s8i	a8, a2, 13
40082f6d:	ffb4e5        	call8	40082abc <z_swap$isra$14>

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
40082f70:	0075e5        	call8	400836d0 <z_tick_get_32>
40082f73:	c0a3a0        	sub	a10, a3, a10
		return ticks;
	}
#endif

	return 0;
}
40082f76:	020c      	movi.n	a2, 0
40082f78:	532a20        	max	a2, a10, a2
40082f7b:	f01d      	retw.n
40082f7d:	000000        	ill

40082f80 <add_to_waitq_locked>:
{
40082f80:	004136        	entry	a1, 32
	unready_thread(thread);
40082f83:	02ad      	mov.n	a10, a2
40082f85:	fff6e5        	call8	40082ef4 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
40082f88:	0d0282        	l8ui	a8, a2, 13
40082f8b:	290c      	movi.n	a9, 2
40082f8d:	208890        	or	a8, a8, a9
40082f90:	0d4282        	s8i	a8, a2, 13
	if (wait_q != NULL) {
40082f93:	93bc      	beqz.n	a3, 40082fd0 <add_to_waitq_locked+0x50>
40082f95:	0388      	l32i.n	a8, a3, 0
		thread->base.pended_on = wait_q;
40082f97:	2239      	s32i.n	a3, a2, 8
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40082f99:	78ac      	beqz.n	a8, 40082fc4 <add_to_waitq_locked+0x44>
40082f9b:	251387        	beq	a3, a8, 40082fc4 <add_to_waitq_locked+0x44>
	if (thread_1->base.prio < thread_2->base.prio) {
40082f9e:	0e0292        	l8ui	a9, a2, 14
40082fa1:	239900        	sext	a9, a9, 7
40082fa4:	0e08a2        	l8ui	a10, a8, 14
40082fa7:	23aa00        	sext	a10, a10, 7
40082faa:	0ca9a7        	bge	a9, a10, 40082fba <add_to_waitq_locked+0x3a>
	node->prev = successor->prev;
40082fad:	1838      	l32i.n	a3, a8, 4
	node->next = successor;
40082faf:	0289      	s32i.n	a8, a2, 0
	node->prev = successor->prev;
40082fb1:	1239      	s32i.n	a3, a2, 4
	successor->prev->next = node;
40082fb3:	0329      	s32i.n	a2, a3, 0
	successor->prev = node;
40082fb5:	1829      	s32i.n	a2, a8, 4
40082fb7:	000546        	j	40082fd0 <add_to_waitq_locked+0x50>
	return (node == list->tail) ? NULL : node->next;
40082fba:	13a8      	l32i.n	a10, a3, 4
40082fbc:	0418a7        	beq	a8, a10, 40082fc4 <add_to_waitq_locked+0x44>
40082fbf:	0888      	l32i.n	a8, a8, 0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40082fc1:	fdf856        	bnez	a8, 40082fa4 <add_to_waitq_locked+0x24>
	node->prev = list->tail;
40082fc4:	1388      	l32i.n	a8, a3, 4
	node->next = list;
40082fc6:	0239      	s32i.n	a3, a2, 0
	node->prev = list->tail;
40082fc8:	1289      	s32i.n	a8, a2, 4
	list->tail->next = node;
40082fca:	1388      	l32i.n	a8, a3, 4
40082fcc:	0829      	s32i.n	a2, a8, 0
	list->tail = node;
40082fce:	1329      	s32i.n	a2, a3, 4
}
40082fd0:	f01d      	retw.n
	...

40082fd4 <pend>:
{
40082fd4:	004136        	entry	a1, 32
40082fd7:	20b330        	or	a11, a3, a3
40082fda:	006360        	rsil	a6, 3
		add_to_waitq_locked(thread, wait_q);
40082fdd:	20a220        	or	a10, a2, a2
40082fe0:	fff9e5        	call8	40082f80 <add_to_waitq_locked>
	XTOS_RESTORE_INTLEVEL(key);
40082fe3:	13e660        	wsr.ps	a6
40082fe6:	002010        	rsync
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40082fe9:	020466        	bnei	a4, -1, 40082fef <pend+0x1b>
40082fec:	0c0526        	beqi	a5, -1, 40082ffc <pend+0x28>
40082fef:	f60ab1        	l32r	a11, 40080818 <_iram_text_start+0x2c8>
40082ff2:	04cd      	mov.n	a12, a4
40082ff4:	05dd      	mov.n	a13, a5
40082ff6:	18c2a2        	addi	a10, a2, 24
40082ff9:	004425        	call8	4008343c <z_add_timeout>
}
40082ffc:	f01d      	retw.n
	...

40083000 <z_pend_curr>:
{
40083000:	004136        	entry	a1, 32
	pend(_current, wait_q, timeout);
40083003:	f55b81        	l32r	a8, 40080570 <_iram_text_start+0x20>
{
40083006:	20d770        	or	a13, a7, a7
	pend(_current, wait_q, timeout);
40083009:	0228a2        	l32i	a10, a8, 8
4008300c:	06cd      	mov.n	a12, a6
4008300e:	04bd      	mov.n	a11, a4
40083010:	fffc25        	call8	40082fd4 <pend>
	return z_swap(lock, key);
40083013:	03ad      	mov.n	a10, a3
40083015:	ffaa65        	call8	40082abc <z_swap$isra$14>
}
40083018:	0a2d      	mov.n	a2, a10
4008301a:	f01d      	retw.n

4008301c <z_set_prio>:
{
4008301c:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4008301f:	006340        	rsil	a4, 3
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
40083022:	0d0252        	l8ui	a5, a2, 13
40083025:	743030        	extui	a3, a3, 0, 8
40083028:	445050        	extui	a5, a5, 0, 5
4008302b:	06e556        	bnez	a5, 4008309d <z_set_prio+0x81>
		if (need_sched) {
4008302e:	6258      	l32i.n	a5, a2, 24
40083030:	069556        	bnez	a5, 4008309d <z_set_prio+0x81>
	sys_dlist_remove(&thread->base.qnode_dlist);
40083033:	02ad      	mov.n	a10, a2
40083035:	009d25        	call8	40083a08 <sys_dlist_remove>
	return list->head == list;
40083038:	f54e91        	l32r	a9, 40080570 <_iram_text_start+0x20>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
4008303b:	1d0c      	movi.n	a13, 1
4008303d:	f988      	l32i.n	a8, a9, 60
4008303f:	05bd      	mov.n	a11, a5
40083041:	93bd80        	movnez	a11, a13, a8
				thread->base.prio = prio;
40083044:	0e4232        	s8i	a3, a2, 14
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40083047:	74b0b0        	extui	a11, a11, 0, 8
4008304a:	f5f1c1        	l32r	a12, 40080810 <_iram_text_start+0x2c0>
4008304d:	1bbc      	beqz.n	a11, 40083082 <z_set_prio+0x66>
	return sys_dlist_is_empty(list) ? NULL : list->head;
4008304f:	c0a8c0        	sub	a10, a8, a12
40083052:	935da0        	movnez	a5, a13, a10
40083055:	74a050        	extui	a10, a5, 0, 8
40083058:	6aac      	beqz.n	a10, 40083082 <z_set_prio+0x66>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
4008305a:	102952        	l32i	a5, a9, 64
	if (thread_1->base.prio < thread_2->base.prio) {
4008305d:	233300        	sext	a3, a3, 7
40083060:	0e08a2        	l8ui	a10, a8, 14
40083063:	23aa00        	sext	a10, a10, 7
40083066:	0fa3a7        	bge	a3, a10, 40083079 <z_set_prio+0x5d>
	node->prev = successor->prev;
40083069:	1838      	l32i.n	a3, a8, 4
	node->next = successor;
4008306b:	0289      	s32i.n	a8, a2, 0
	node->prev = successor->prev;
4008306d:	1239      	s32i.n	a3, a2, 4
	successor->prev->next = node;
4008306f:	0329      	s32i.n	a2, a3, 0
	successor->prev = node;
40083071:	1829      	s32i.n	a2, a8, 4
40083073:	000706        	j	40083093 <z_set_prio+0x77>
40083076:	000000        	ill
	return (node == list->tail) ? NULL : node->next;
40083079:	051587        	beq	a5, a8, 40083082 <z_set_prio+0x66>
4008307c:	002882        	l32i	a8, a8, 0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
4008307f:	fdd856        	bnez	a8, 40083060 <z_set_prio+0x44>
	node->prev = list->tail;
40083082:	102932        	l32i	a3, a9, 64
	node->next = list;
40083085:	0062c2        	s32i	a12, a2, 0
	node->prev = list->tail;
40083088:	016232        	s32i	a3, a2, 4
	list->tail->next = node;
4008308b:	102932        	l32i	a3, a9, 64
4008308e:	0329      	s32i.n	a2, a3, 0
	list->tail = node;
40083090:	106922        	s32i	a2, a9, 64
			update_cache(1);
40083093:	1a0c      	movi.n	a10, 1
40083095:	ffb1a5        	call8	40082bb0 <update_cache>
40083098:	120c      	movi.n	a2, 1
4008309a:	000106        	j	400830a2 <z_set_prio+0x86>
			thread->base.prio = prio;
4008309d:	0e4232        	s8i	a3, a2, 14
400830a0:	020c      	movi.n	a2, 0
	XTOS_RESTORE_INTLEVEL(key);
400830a2:	13e640        	wsr.ps	a4
400830a5:	002010        	rsync
}
400830a8:	f01d      	retw.n
	...

400830ac <z_unpend_first_thread>:
{
400830ac:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400830af:	006330        	rsil	a3, 3
		ret = _priq_wait_best(&wait_q->waitq);
400830b2:	20a220        	or	a10, a2, a2
400830b5:	009665        	call8	40083a1c <z_priq_dumb_best>
400830b8:	0a2d      	mov.n	a2, a10
	XTOS_RESTORE_INTLEVEL(key);
400830ba:	13e630        	wsr.ps	a3
400830bd:	002010        	rsync

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
400830c0:	0aac      	beqz.n	a10, 400830e4 <z_unpend_first_thread+0x38>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400830c2:	006330        	rsil	a3, 3
	sys_dlist_remove(&thread->base.qnode_dlist);
400830c5:	009425        	call8	40083a08 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
400830c8:	0d0282        	l8ui	a8, a2, 13
400830cb:	d97c      	movi.n	a9, -3
400830cd:	108890        	and	a8, a8, a9
400830d0:	0d4282        	s8i	a8, a2, 13
		thread->base.pended_on = NULL;
400830d3:	080c      	movi.n	a8, 0
400830d5:	026282        	s32i	a8, a2, 8
	XTOS_RESTORE_INTLEVEL(key);
400830d8:	13e630        	wsr.ps	a3
400830db:	002010        	rsync
	return z_abort_timeout(&thread->base.timeout);
400830de:	18c2a2        	addi	a10, a2, 24
400830e1:	0049e5        	call8	40083580 <z_abort_timeout>
}
400830e4:	f01d      	retw.n
	...

400830e8 <z_sched_init>:
{
400830e8:	004136        	entry	a1, 32
	list->head = (sys_dnode_t *)list;
400830eb:	f52181        	l32r	a8, 40080570 <_iram_text_start+0x20>
400830ee:	f5c891        	l32r	a9, 40080810 <_iram_text_start+0x2c0>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
400830f1:	00a0b2        	movi	a11, 0
400830f4:	0f6892        	s32i	a9, a8, 60
	list->tail = (sys_dnode_t *)list;
400830f7:	106892        	s32i	a9, a8, 64
400830fa:	20abb0        	or	a10, a11, a11
400830fd:	ff9ee5        	call8	40082aec <k_sched_time_slice_set>
}
40083100:	f01d      	retw.n
	...

40083104 <z_impl_k_yield>:
{
40083104:	004136        	entry	a1, 32
	if (!z_is_idle_thread_object(_current)) {
40083107:	f51a21        	l32r	a2, 40080570 <_iram_text_start+0x20>
4008310a:	f5b831        	l32r	a3, 400807ec <_iram_text_start+0x29c>
4008310d:	2288      	l32i.n	a8, a2, 8
4008310f:	671837        	beq	a8, a3, 4008317a <z_impl_k_yield+0x76>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40083112:	006330        	rsil	a3, 3
	sys_dlist_remove(&thread->base.qnode_dlist);
40083115:	22a8      	l32i.n	a10, a2, 8
40083117:	008f25        	call8	40083a08 <sys_dlist_remove>
	return list->head == list;
4008311a:	f298      	l32i.n	a9, a2, 60
			_priq_run_add(&_kernel.ready_q.runq, _current);
4008311c:	022282        	l32i	a8, a2, 8
4008311f:	f5bcc1        	l32r	a12, 40080810 <_iram_text_start+0x2c0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40083122:	c9ac      	beqz.n	a9, 40083152 <z_impl_k_yield+0x4e>
40083124:	2a19c7        	beq	a9, a12, 40083152 <z_impl_k_yield+0x4e>
	if (thread_1->base.prio < thread_2->base.prio) {
40083127:	0e08a2        	l8ui	a10, a8, 14
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
4008312a:	1022d2        	l32i	a13, a2, 64
4008312d:	23aa00        	sext	a10, a10, 7
40083130:	0e09b2        	l8ui	a11, a9, 14
40083133:	23bb00        	sext	a11, a11, 7
40083136:	0faab7        	bge	a10, a11, 40083149 <z_impl_k_yield+0x45>
	node->prev = successor->prev;
40083139:	1928      	l32i.n	a2, a9, 4
	node->next = successor;
4008313b:	0899      	s32i.n	a9, a8, 0
	node->prev = successor->prev;
4008313d:	1829      	s32i.n	a2, a8, 4
	successor->prev->next = node;
4008313f:	0289      	s32i.n	a8, a2, 0
	successor->prev = node;
40083141:	1989      	s32i.n	a8, a9, 4
40083143:	0006c6        	j	40083162 <z_impl_k_yield+0x5e>
40083146:	000000        	ill
	return (node == list->tail) ? NULL : node->next;
40083149:	0519d7        	beq	a9, a13, 40083152 <z_impl_k_yield+0x4e>
4008314c:	002992        	l32i	a9, a9, 0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
4008314f:	fdd956        	bnez	a9, 40083130 <z_impl_k_yield+0x2c>
	node->prev = list->tail;
40083152:	102292        	l32i	a9, a2, 64
	node->next = list;
40083155:	0068c2        	s32i	a12, a8, 0
	node->prev = list->tail;
40083158:	1899      	s32i.n	a9, a8, 4
	list->tail->next = node;
4008315a:	102292        	l32i	a9, a2, 64
4008315d:	0989      	s32i.n	a8, a9, 0
	list->tail = node;
4008315f:	106282        	s32i	a8, a2, 64
	thread->base.thread_state |= states;
40083162:	0d0822        	l8ui	a2, a8, 13
40083165:	80af92        	movi	a9, -128
40083168:	202290        	or	a2, a2, a9
4008316b:	0d4822        	s8i	a2, a8, 13
			update_cache(1);
4008316e:	01a0a2        	movi	a10, 1
40083171:	ffa3e5        	call8	40082bb0 <update_cache>
	XTOS_RESTORE_INTLEVEL(key);
40083174:	13e630        	wsr.ps	a3
40083177:	002010        	rsync
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4008317a:	0063a0        	rsil	a10, 3
	(void) z_swap(&lock, key);
4008317d:	ff93e5        	call8	40082abc <z_swap$isra$14>
}
40083180:	f01d      	retw.n
	...

40083184 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
40083184:	004136        	entry	a1, 32
40083187:	20a220        	or	a10, a2, a2
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
4008318a:	140266        	bnei	a2, -1, 400831a2 <z_impl_k_sleep+0x1e>
4008318d:	110366        	bnei	a3, -1, 400831a2 <z_impl_k_sleep+0x1e>
		k_thread_suspend(_current);
40083190:	f4f881        	l32r	a8, 40080570 <_iram_text_start+0x20>
40083193:	0228a2        	l32i	a10, a8, 8
	z_impl_k_thread_suspend(thread);
40083196:	ffc5e5        	call8	40082df4 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
40083199:	20a330        	or	a10, a3, a3
4008319c:	000846        	j	400831c1 <z_impl_k_sleep+0x3d>
4008319f:	000000        	ill
	ticks = k_ms_to_ticks_ceil32(timeout);
#else
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
400831a2:	0a3d      	mov.n	a3, a10
	if (ticks == 0) {
400831a4:	4acc      	bnez.n	a10, 400831ac <z_impl_k_sleep+0x28>
	z_impl_k_yield();
400831a6:	fff5e5        	call8	40083104 <z_impl_k_yield>
400831a9:	000146        	j	400831b2 <z_impl_k_sleep+0x2e>
400831ac:	ffd8a5        	call8	40082f38 <z_tick_sleep$part$23>
400831af:	203aa0        	or	a3, a10, a10
			return t / (from_hz / to_hz);
400831b2:	f59ac1        	l32r	a12, 4008081c <_iram_text_start+0x2cc>
400831b5:	f4f0d1        	l32r	a13, 40080578 <_iram_text_start+0x28>
400831b8:	20a330        	or	a10, a3, a3
400831bb:	31bf30        	srai	a11, a3, 31
400831be:	0089a5        	call8	40083a58 <__udivdi3>
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
}
400831c1:	0a2d      	mov.n	a2, a10
400831c3:	f01d      	retw.n
400831c5:	000000        	ill

400831c8 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
400831c8:	004136        	entry	a1, 32

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
400831cb:	f4e981        	l32r	a8, 40080570 <_iram_text_start+0x20>
400831ce:	2828      	l32i.n	a2, a8, 8
400831d0:	f01d      	retw.n
	...

400831d4 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
400831d4:	004136        	entry	a1, 32
400831d7:	006330        	rsil	a3, 3
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
400831da:	20a220        	or	a10, a2, a2
400831dd:	ffece5        	call8	400830ac <z_unpend_first_thread>

	if (thread != NULL) {
400831e0:	00da16        	beqz	a10, 400831f1 <z_impl_k_sem_give+0x1d>
400831e3:	00a022        	movi	a2, 0
400831e6:	136a22        	s32i	a2, a10, 76
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
400831e9:	ffab65        	call8	40082ca0 <z_ready_thread>
400831ec:	000506        	j	40083204 <z_impl_k_sem_give+0x30>
400831ef:	920000        	lsi	f0, a0, 0x248
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
400831f2:	820222        	l8ui	a2, a2, 130
400831f5:	b20322        	l8ui	a2, a3, 178
400831f8:	9001a0        	addx2	a0, a1, a10
400831fb:	c088      	l32i.n	a8, a0, 48
400831fd:	93ab80        	movnez	a10, a11, a8
40083200:	8a9a      	add.n	a8, a10, a9
40083202:	2289      	s32i.n	a8, a2, 8
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
40083204:	f587a1        	l32r	a10, 40080820 <_iram_text_start+0x2d0>
40083207:	03bd      	mov.n	a11, a3
40083209:	ff9125        	call8	40082b1c <z_reschedule>
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
4008320c:	f01d      	retw.n
	...

40083210 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
40083210:	004136        	entry	a1, 32
40083213:	02cd      	mov.n	a12, a2
40083215:	04ed      	mov.n	a14, a4
40083217:	05fd      	mov.n	a15, a5
40083219:	0063b0        	rsil	a11, 3
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
4008321c:	2288      	l32i.n	a8, a2, 8
4008321e:	e88c      	beqz.n	a8, 40083230 <z_impl_k_sem_take+0x20>
		sem->count--;
40083220:	880b      	addi.n	a8, a8, -1
40083222:	2289      	s32i.n	a8, a2, 8
	XTOS_RESTORE_INTLEVEL(key);
40083224:	13e6b0        	wsr.ps	a11
40083227:	002010        	rsync
		k_spin_unlock(&lock, key);
		ret = 0;
4008322a:	0a0c      	movi.n	a10, 0
		goto out;
4008322c:	000586        	j	40083246 <z_impl_k_sem_take+0x36>
4008322f:	845000        	extui	a5, a0, 0, 9
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40083232:	98cc20        	lsi	f2, a12, 0x260
40083235:	13e6b0        	wsr.ps	a11
40083238:	002010        	rsync
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
4008323b:	0a7c      	movi.n	a10, -16
		goto out;
4008323d:	000146        	j	40083246 <z_impl_k_sem_take+0x36>
	}

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
40083240:	f578a1        	l32r	a10, 40080820 <_iram_text_start+0x2d0>
40083243:	ffdbe5        	call8	40083000 <z_pend_curr>

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
40083246:	0a2d      	mov.n	a2, a10
40083248:	f01d      	retw.n
	...

4008324c <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
4008324c:	004136        	entry	a1, 32
	z_sched_start(thread);
4008324f:	02ad      	mov.n	a10, a2
40083251:	ffaa25        	call8	40082cf4 <z_sched_start>
}
40083254:	f01d      	retw.n
	...

40083258 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
40083258:	006136        	entry	a1, 48
4008325b:	07fd      	mov.n	a15, a7
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
4008325d:	e178      	l32i.n	a7, a1, 56
	sys_dlist_init(&w->waitq);
4008325f:	30c282        	addi	a8, a2, 48
40083262:	0c4272        	s8i	a7, a2, 12
	thread_base->thread_state = (uint8_t)initial_state;
40083265:	470c      	movi.n	a7, 4
40083267:	0d4272        	s8i	a7, a2, 13

	thread_base->prio = priority;
4008326a:	d178      	l32i.n	a7, a1, 52
	list->head = (sys_dnode_t *)list;
4008326c:	c289      	s32i.n	a8, a2, 48
	list->tail = (sys_dnode_t *)list;
4008326e:	d289      	s32i.n	a8, a2, 52
40083270:	0e4272        	s8i	a7, a2, 14
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
40083273:	087c      	movi.n	a8, -16

	thread_base->sched_locked = 0U;
40083275:	070c      	movi.n	a7, 0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
40083277:	44fb      	addi.n	a4, a4, 15
	thread_base->sched_locked = 0U;
40083279:	0f4272        	s8i	a7, a2, 15
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
4008327c:	104480        	and	a4, a4, a8
	node->next = NULL;
4008327f:	070c      	movi.n	a7, 0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
40083281:	c188      	l32i.n	a8, a1, 48
40083283:	6279      	s32i.n	a7, a2, 24
	node->prev = NULL;
40083285:	7279      	s32i.n	a7, a2, 28
	stack_ptr = (char *)stack + stack_obj_size;
40083287:	434a      	add.n	a4, a3, a4
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
40083289:	02ad      	mov.n	a10, a2
{
4008328b:	03bd      	mov.n	a11, a3
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
4008328d:	0189      	s32i.n	a8, a1, 0
4008328f:	06ed      	mov.n	a14, a6
40083291:	05dd      	mov.n	a13, a5
40083293:	04cd      	mov.n	a12, a4
40083295:	fe70a5        	call8	400819a0 <arch_new_thread>
	new_thread->init_data = NULL;
40083298:	106272        	s32i	a7, a2, 64
	new_thread->fn_abort = NULL;
4008329b:	116272        	s32i	a7, a2, 68
	new_thread->resource_pool = _current->resource_pool;
4008329e:	f4b471        	l32r	a7, 40080570 <_iram_text_start+0x20>
400832a1:	2778      	l32i.n	a7, a7, 8
400832a3:	152772        	l32i	a7, a7, 84
400832a6:	156272        	s32i	a7, a2, 84
}
400832a9:	042d      	mov.n	a2, a4
400832ab:	f01d      	retw.n
400832ad:	000000        	ill

400832b0 <z_impl_k_thread_create>:
{
400832b0:	008136        	entry	a1, 64
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
400832b3:	00a092        	movi	a9, 0
400832b6:	036192        	s32i	a9, a1, 12
400832b9:	122192        	l32i	a9, a1, 72
{
400832bc:	142182        	l32i	a8, a1, 80
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
400832bf:	2199      	s32i.n	a9, a1, 8
400832c1:	112192        	l32i	a9, a1, 68
{
400832c4:	07fd      	mov.n	a15, a7
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
400832c6:	1199      	s32i.n	a9, a1, 4
400832c8:	102192        	l32i	a9, a1, 64
400832cb:	06ed      	mov.n	a14, a6
400832cd:	0199      	s32i.n	a9, a1, 0
400832cf:	05dd      	mov.n	a13, a5
400832d1:	04cd      	mov.n	a12, a4
400832d3:	03bd      	mov.n	a11, a3
400832d5:	02ad      	mov.n	a10, a2
400832d7:	4189      	s32i.n	a8, a1, 16
{
400832d9:	152172        	l32i	a7, a1, 84
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
400832dc:	fff7a5        	call8	40083258 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
400832df:	4188      	l32i.n	a8, a1, 16
400832e1:	020866        	bnei	a8, -1, 400832e7 <z_impl_k_thread_create+0x37>
400832e4:	1b0726        	beqi	a7, -1, 40083303 <z_impl_k_thread_create+0x53>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
400832e7:	209780        	or	a9, a7, a8
400832ea:	69cc      	bnez.n	a9, 400832f4 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
400832ec:	02ad      	mov.n	a10, a2
400832ee:	ffa065        	call8	40082cf4 <z_sched_start>
400832f1:	000386        	j	40083303 <z_impl_k_thread_create+0x53>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
400832f4:	f549b1        	l32r	a11, 40080818 <_iram_text_start+0x2c8>
400832f7:	20c880        	or	a12, a8, a8
400832fa:	20d770        	or	a13, a7, a7
400832fd:	18c2a2        	addi	a10, a2, 24
40083300:	0013a5        	call8	4008343c <z_add_timeout>
}
40083303:	000090        	retw
	...

40083308 <z_init_static_threads>:
{
40083308:	006136        	entry	a1, 48
	_FOREACH_STATIC_THREAD(thread_data) {
4008330b:	f54621        	l32r	a2, 40080824 <_iram_text_start+0x2d4>
4008330e:	f54531        	l32r	a3, 40080824 <_iram_text_start+0x2d4>
40083311:	024d      	mov.n	a4, a2
40083313:	000a46        	j	40083340 <z_init_static_threads+0x38>
		z_setup_new_thread(
40083316:	0b2282        	l32i	a8, a2, 44
40083319:	036182        	s32i	a8, a1, 12
4008331c:	8288      	l32i.n	a8, a2, 32
4008331e:	2189      	s32i.n	a8, a1, 8
40083320:	7288      	l32i.n	a8, a2, 28
40083322:	1189      	s32i.n	a8, a1, 4
40083324:	6288      	l32i.n	a8, a2, 24
40083326:	0189      	s32i.n	a8, a1, 0
40083328:	52f8      	l32i.n	a15, a2, 20
4008332a:	42e8      	l32i.n	a14, a2, 16
4008332c:	32d8      	l32i.n	a13, a2, 12
4008332e:	22c8      	l32i.n	a12, a2, 8
40083330:	12b8      	l32i.n	a11, a2, 4
40083332:	0022a2        	l32i	a10, a2, 0
40083335:	fff225        	call8	40083258 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
40083338:	0288      	l32i.n	a8, a2, 0
4008333a:	106822        	s32i	a2, a8, 64
	_FOREACH_STATIC_THREAD(thread_data) {
4008333d:	30c222        	addi	a2, a2, 48
40083340:	d23237        	bltu	a2, a3, 40083316 <z_init_static_threads+0xe>
	_FOREACH_STATIC_THREAD(thread_data) {
40083343:	042d      	mov.n	a2, a4
	k_sched_lock();
40083345:	ff8325        	call8	40082b78 <k_sched_lock>
					    K_MSEC(thread_data->init_delay));
40083348:	040c      	movi.n	a4, 0
	_FOREACH_STATIC_THREAD(thread_data) {
4008334a:	000a86        	j	40083378 <z_init_static_threads+0x70>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
4008334d:	92d8      	l32i.n	a13, a2, 36
4008334f:	220d26        	beqi	a13, -1, 40083375 <z_init_static_threads+0x6d>
		} else {
			return t * (to_hz / from_hz);
40083352:	a80c      	movi.n	a8, 10
					    K_MSEC(thread_data->init_delay));
40083354:	53dd40        	max	a13, a13, a4
40083357:	82cd80        	mull	a12, a13, a8
4008335a:	b2dd80        	mulsh	a13, a13, a8
			schedule_new_thread(thread_data->init_thread,
4008335d:	02a8      	l32i.n	a10, a2, 0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
4008335f:	208cd0        	or	a8, a12, a13
40083362:	006856        	bnez	a8, 4008336c <z_init_static_threads+0x64>
	z_sched_start(thread);
40083365:	ff98e5        	call8	40082cf4 <z_sched_start>
40083368:	000246        	j	40083375 <z_init_static_threads+0x6d>
4008336b:	2bb100        	oeq.s	b11, f1, f0
4008336e:	caa2f5        	call12	4004dd9c <esp32_rom_gpio_matrix_out+0x43e90>
40083371:	a518      	l32i.n	a1, a5, 40
40083373:	000c      	movi.n	a0, 0
	_FOREACH_STATIC_THREAD(thread_data) {
40083375:	30c222        	addi	a2, a2, 48
40083378:	d13237        	bltu	a2, a3, 4008334d <z_init_static_threads+0x45>
	k_sched_unlock();
4008337b:	ff8825        	call8	40082bfc <k_sched_unlock>
}
4008337e:	f01d      	retw.n

40083380 <z_impl_k_thread_abort>:
#include <sys/__assert.h>
#include <syscall_handler.h>

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
40083380:	004136        	entry	a1, 32
	z_thread_single_abort(thread);
40083383:	02ad      	mov.n	a10, a2
40083385:	ffabe5        	call8	40082e44 <z_thread_single_abort>
40083388:	03f430        	rsr.misc0	a3

	/* If we're in an interrupt handler, we reschedule on the way out
	 * anyway, nothing needs to be done here.
	 */
	if (!arch_is_in_isr()) {
4008338b:	0338      	l32i.n	a3, a3, 0
4008338d:	23fc      	bnez.n	a3, 400833c3 <z_impl_k_thread_abort+0x43>
		if (thread == _current) {
4008338f:	f47831        	l32r	a3, 40080570 <_iram_text_start+0x20>
40083392:	2348      	l32i.n	a4, a3, 8
40083394:	259427        	bne	a4, a2, 400833bd <z_impl_k_thread_abort+0x3d>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40083397:	006350        	rsil	a5, 3
	old_thread = _current;
4008339a:	2348      	l32i.n	a4, a3, 8
	return _kernel.ready_q.cache;
4008339c:	e328      	l32i.n	a2, a3, 56
	if (new_thread != old_thread) {
4008339e:	121427        	beq	a4, a2, 400833b4 <z_impl_k_thread_abort+0x34>
		z_reset_time_slice();
400833a1:	ff6c65        	call8	40082a68 <z_reset_time_slice>
		old_thread->swap_retval = -EAGAIN;
400833a4:	587c      	movi.n	a8, -11
400833a6:	1422a2        	l32i	a10, a2, 80
400833a9:	136482        	s32i	a8, a4, 76
		_current_cpu->current = new_thread;
400833ac:	2329      	s32i.n	a2, a3, 8
400833ae:	50c4b2        	addi	a11, a4, 80
400833b1:	fe47e5        	call8	40081830 <xtensa_switch>
	XTOS_RESTORE_INTLEVEL(key);
400833b4:	13e650        	wsr.ps	a5
400833b7:	002010        	rsync
	return _current->swap_retval;
400833ba:	000146        	j	400833c3 <z_impl_k_thread_abort+0x43>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400833bd:	0063a0        	rsil	a10, 3
	(void) z_reschedule_irqlock(arch_irq_lock());
400833c0:	ff7865        	call8	40082b48 <z_reschedule_irqlock>
			z_swap_unlocked();
		} else {
			z_reschedule_unlocked();
		}
	}
}
400833c3:	f01d      	retw.n
400833c5:	000000        	ill

400833c8 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
400833c8:	004136        	entry	a1, 32
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
400833cb:	f51781        	l32r	a8, 40080828 <_iram_text_start+0x2d8>
400833ce:	0a0c      	movi.n	a10, 0
400833d0:	0888      	l32i.n	a8, a8, 0
400833d2:	0298a7        	bne	a8, a10, 400833d8 <elapsed+0x10>
400833d5:	fe34a5        	call8	40081720 <z_clock_elapsed>
}
400833d8:	0a2d      	mov.n	a2, a10
400833da:	f01d      	retw.n

400833dc <remove_timeout>:
{
400833dc:	004136        	entry	a1, 32
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
400833df:	0288      	l32i.n	a8, a2, 0
400833e1:	12ac      	beqz.n	a2, 40083406 <remove_timeout+0x2a>
400833e3:	f51291        	l32r	a9, 4008082c <_iram_text_start+0x2dc>
	return (node == list->tail) ? NULL : node->next;
400833e6:	1998      	l32i.n	a9, a9, 4
400833e8:	1a1297        	beq	a2, a9, 40083406 <remove_timeout+0x2a>
	if (next(t) != NULL) {
400833eb:	789c      	beqz.n	a8, 40083406 <remove_timeout+0x2a>
		next(t)->dticks += t->dticks;
400833ed:	48c8      	l32i.n	a12, a8, 16
400833ef:	42a8      	l32i.n	a10, a2, 16
400833f1:	58b8      	l32i.n	a11, a8, 20
400833f3:	acaa      	add.n	a10, a12, a10
400833f5:	52d8      	l32i.n	a13, a2, 20
400833f7:	190c      	movi.n	a9, 1
400833f9:	013ac7        	bltu	a10, a12, 400833fe <remove_timeout+0x22>
400833fc:	090c      	movi.n	a9, 0
400833fe:	bbda      	add.n	a11, a11, a13
40083400:	99ba      	add.n	a9, a9, a11
40083402:	48a9      	s32i.n	a10, a8, 16
40083404:	5899      	s32i.n	a9, a8, 20
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
40083406:	1298      	l32i.n	a9, a2, 4
40083408:	0989      	s32i.n	a8, a9, 0
	node->next->prev = node->prev;
4008340a:	1899      	s32i.n	a9, a8, 4
	node->next = NULL;
4008340c:	080c      	movi.n	a8, 0
4008340e:	0289      	s32i.n	a8, a2, 0
	node->prev = NULL;
40083410:	1289      	s32i.n	a8, a2, 4
}
40083412:	f01d      	retw.n

40083414 <next_timeout>:

static int32_t next_timeout(void)
{
40083414:	004136        	entry	a1, 32
	return list->head == list;
40083417:	f50581        	l32r	a8, 4008082c <_iram_text_start+0x2dc>
4008341a:	0828      	l32i.n	a2, a8, 0
	return sys_dlist_is_empty(list) ? NULL : list->head;
4008341c:	019287        	bne	a2, a8, 40083421 <next_timeout+0xd>
4008341f:	020c      	movi.n	a2, 0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
40083421:	fffa65        	call8	400833c8 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
40083424:	f50381        	l32r	a8, 40080830 <_iram_text_start+0x2e0>
40083427:	328c      	beqz.n	a2, 4008342e <next_timeout+0x1a>
40083429:	4288      	l32i.n	a8, a2, 16
4008342b:	c088a0        	sub	a8, a8, a10

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
4008342e:	f45021        	l32r	a2, 40080570 <_iram_text_start+0x20>
40083431:	4228      	l32i.n	a2, a2, 16
40083433:	128c      	beqz.n	a2, 40083438 <next_timeout+0x24>
40083435:	012287        	blt	a2, a8, 4008343a <next_timeout+0x26>
40083438:	082d      	mov.n	a2, a8
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
4008343a:	f01d      	retw.n

4008343c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
4008343c:	006136        	entry	a1, 48
4008343f:	046d      	mov.n	a6, a4
40083441:	207550        	or	a7, a5, a5
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40083444:	050466        	bnei	a4, -1, 4008344d <z_add_timeout+0x11>
40083447:	020566        	bnei	a5, -1, 4008344d <z_add_timeout+0x11>
4008344a:	004b86        	j	4008357c <z_add_timeout+0x140>
	}

#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;
4008344d:	441b      	addi.n	a4, a4, 1
4008344f:	180c      	movi.n	a8, 1
40083451:	013467        	bltu	a4, a6, 40083456 <z_add_timeout+0x1a>
40083454:	080c      	movi.n	a8, 0
40083456:	885a      	add.n	a8, a8, a5

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
40083458:	e57c      	movi.n	a5, -2
4008345a:	c0a540        	sub	a10, a5, a4
	k_ticks_t ticks = timeout.ticks + 1;
4008345d:	047d      	mov.n	a7, a4
4008345f:	086d      	mov.n	a6, a8
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
40083461:	190c      	movi.n	a9, 1
40083463:	0235a7        	bltu	a5, a10, 40083469 <z_add_timeout+0x2d>
40083466:	00a092        	movi	a9, 0
40083469:	f57c      	movi.n	a5, -1
4008346b:	c05580        	sub	a5, a5, a8
4008346e:	c05590        	sub	a5, a5, a9
40083471:	045596        	bltz	a5, 400834ba <z_add_timeout+0x7e>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
40083474:	0189      	s32i.n	a8, a1, 0
40083476:	fff525        	call8	400833c8 <elapsed>
40083479:	f4ee51        	l32r	a5, 40080834 <_iram_text_start+0x2e4>
4008347c:	e97c      	movi.n	a9, -2
4008347e:	0568      	l32i.n	a6, a5, 0
40083480:	15b8      	l32i.n	a11, a5, 4
40083482:	c06960        	sub	a6, a9, a6
40083485:	170c      	movi.n	a7, 1
40083487:	0188      	l32i.n	a8, a1, 0
40083489:	013967        	bltu	a9, a6, 4008348e <z_add_timeout+0x52>
4008348c:	070c      	movi.n	a7, 0
4008348e:	f57c      	movi.n	a5, -1
40083490:	c055b0        	sub	a5, a5, a11
40083493:	c04640        	sub	a4, a6, a4
40083496:	c05570        	sub	a5, a5, a7
40083499:	170c      	movi.n	a7, 1
4008349b:	023647        	bltu	a6, a4, 400834a1 <z_add_timeout+0x65>
4008349e:	00a072        	movi	a7, 0
400834a1:	c05580        	sub	a5, a5, a8
400834a4:	c05570        	sub	a5, a5, a7
400834a7:	c074a0        	sub	a7, a4, a10
400834aa:	318fa0        	srai	a8, a10, 31
400834ad:	160c      	movi.n	a6, 1
400834af:	013477        	bltu	a4, a7, 400834b4 <z_add_timeout+0x78>
400834b2:	060c      	movi.n	a6, 0
400834b4:	c05580        	sub	a5, a5, a8
400834b7:	c06560        	sub	a6, a5, a6
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
400834ba:	026232        	s32i	a3, a2, 8
400834bd:	006330        	rsil	a3, 3
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
400834c0:	fff065        	call8	400833c8 <elapsed>
	ticks = MAX(1, ticks);
400834c3:	205770        	or	a5, a7, a7
400834c6:	204660        	or	a4, a6, a6
400834c9:	0716e6        	bgei	a6, 1, 400834d4 <z_add_timeout+0x98>
400834cc:	06cc      	bnez.n	a6, 400834d0 <z_add_timeout+0x94>
400834ce:	27cc      	bnez.n	a7, 400834d4 <z_add_timeout+0x98>
400834d0:	150c      	movi.n	a5, 1
400834d2:	040c      	movi.n	a4, 0
		to->dticks = ticks + elapsed();
400834d4:	317fa0        	srai	a7, a10, 31
400834d7:	a5aa      	add.n	a10, a5, a10
400834d9:	160c      	movi.n	a6, 1
400834db:	013a57        	bltu	a10, a5, 400834e0 <z_add_timeout+0xa4>
400834de:	060c      	movi.n	a6, 0
400834e0:	447a      	add.n	a4, a4, a7
400834e2:	464a      	add.n	a4, a6, a4
400834e4:	5249      	s32i.n	a4, a2, 20
	return list->head == list;
400834e6:	f4d141        	l32r	a4, 4008082c <_iram_text_start+0x2dc>
400834e9:	42a9      	s32i.n	a10, a2, 16
400834eb:	0458      	l32i.n	a5, a4, 0
	return sys_dlist_is_empty(list) ? NULL : list->head;
400834ed:	029547        	bne	a5, a4, 400834f3 <z_add_timeout+0xb7>
400834f0:	001e46        	j	4008356d <z_add_timeout+0x131>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
400834f3:	14a8      	l32i.n	a10, a4, 4
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
400834f5:	1b0c      	movi.n	a11, 1
400834f7:	0c0c      	movi.n	a12, 0
400834f9:	001386        	j	4008354b <z_add_timeout+0x10f>
			if (t->dticks > to->dticks) {
400834fc:	5588      	l32i.n	a8, a5, 20
400834fe:	5268      	l32i.n	a6, a2, 20
40083500:	4578      	l32i.n	a7, a5, 16
40083502:	4298      	l32i.n	a9, a2, 16
40083504:	053687        	bltu	a6, a8, 4008350d <z_add_timeout+0xd1>
40083507:	259867        	bne	a8, a6, 40083530 <z_add_timeout+0xf4>
4008350a:	22b977        	bgeu	a9, a7, 40083530 <z_add_timeout+0xf4>
				t->dticks -= to->dticks;
4008350d:	c09790        	sub	a9, a7, a9
40083510:	1a0c      	movi.n	a10, 1
40083512:	023797        	bltu	a7, a9, 40083518 <z_add_timeout+0xdc>
40083515:	00a0a2        	movi	a10, 0
40083518:	c06860        	sub	a6, a8, a6
4008351b:	c066a0        	sub	a6, a6, a10
4008351e:	5569      	s32i.n	a6, a5, 20
	node->prev = successor->prev;
40083520:	1568      	l32i.n	a6, a5, 4
40083522:	4599      	s32i.n	a9, a5, 16
40083524:	1269      	s32i.n	a6, a2, 4
	node->next = successor;
40083526:	0259      	s32i.n	a5, a2, 0
	successor->prev->next = node;
40083528:	0629      	s32i.n	a2, a6, 0
	successor->prev = node;
4008352a:	1529      	s32i.n	a2, a5, 4
		}

		if (t == NULL) {
4008352c:	000886        	j	40083552 <z_add_timeout+0x116>
4008352f:	797000        	lsi	f0, a0, 0x1e4
			to->dticks -= t->dticks;
40083532:	dbb0c0        	movt.s	f11, f0, b12
40083535:	397720        	lsi	f2, a7, 228
40083538:	dcc002        	addi	a0, a0, -36
4008353b:	668020        	lsi	f2, a0, 0x198
4008353e:	66d0c0        	lsi	f12, a0, 0x198
40083541:	4279c0        	xorb	b7, b9, b12
40083544:	5269      	s32i.n	a6, a2, 20
	return (node == list->tail) ? NULL : node->next;
40083546:	2315a7        	beq	a5, a10, 4008356d <z_add_timeout+0x131>
40083549:	0558      	l32i.n	a5, a5, 0
		for (t = first(); t != NULL; t = next(t)) {
4008354b:	fad556        	bnez	a5, 400834fc <z_add_timeout+0xc0>
4008354e:	0006c6        	j	4008356d <z_add_timeout+0x131>
40083551:	245200        	extui	a5, a0, 2, 3
	return list->head == list;
40083554:	925700        	lsi	f0, a7, 0x248
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
40083557:	470b      	addi.n	a4, a7, -1
40083559:	a50815        	call4	400285dc <esp32_rom_gpio_matrix_out+0x1e6d0>
			z_clock_set_timeout(next_timeout(), false);
4008355c:	ffeb      	addi.n	a15, a15, 14
4008355e:	00a0b2        	movi	a11, 0
40083561:	fe15e5        	call8	400816c0 <z_clock_set_timeout>
	XTOS_RESTORE_INTLEVEL(key);
40083564:	13e630        	wsr.ps	a3
40083567:	002010        	rsync
	LOCKED(&timeout_lock) {
4008356a:	000386        	j	4008357c <z_add_timeout+0x140>
	node->prev = list->tail;
4008356d:	1458      	l32i.n	a5, a4, 4
	node->next = list;
4008356f:	0249      	s32i.n	a4, a2, 0
	node->prev = list->tail;
40083571:	1259      	s32i.n	a5, a2, 4
	list->tail->next = node;
40083573:	1458      	l32i.n	a5, a4, 4
40083575:	0529      	s32i.n	a2, a5, 0
	list->tail = node;
40083577:	1429      	s32i.n	a2, a4, 4
40083579:	fff546        	j	40083552 <z_add_timeout+0x116>
		}
	}
}
4008357c:	f01d      	retw.n
	...

40083580 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
40083580:	004136        	entry	a1, 32
40083583:	02ad      	mov.n	a10, a2
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40083585:	006320        	rsil	a2, 3
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
40083588:	0a98      	l32i.n	a9, a10, 0
	int ret = -EINVAL;
4008358a:	a86c      	movi.n	a8, -22
		if (sys_dnode_is_linked(&to->node)) {
4008358c:	004916        	beqz	a9, 40083594 <z_abort_timeout+0x14>
			remove_timeout(to);
4008358f:	ffe4e5        	call8	400833dc <remove_timeout>
			ret = 0;
40083592:	080c      	movi.n	a8, 0
	XTOS_RESTORE_INTLEVEL(key);
40083594:	13e620        	wsr.ps	a2
40083597:	002010        	rsync
		}
	}

	return ret;
}
4008359a:	082d      	mov.n	a2, a8
4008359c:	f01d      	retw.n
	...

400835a0 <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
400835a0:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400835a3:	006320        	rsil	a2, 3
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
400835a6:	ffe6e5        	call8	40083414 <next_timeout>
	XTOS_RESTORE_INTLEVEL(key);
400835a9:	13e620        	wsr.ps	a2
400835ac:	002010        	rsync
	}
	return ret;
}
400835af:	0a2d      	mov.n	a2, a10
400835b1:	f01d      	retw.n
	...

400835b4 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
400835b4:	004136        	entry	a1, 32
400835b7:	743030        	extui	a3, a3, 0, 8
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400835ba:	006340        	rsil	a4, 3
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
400835bd:	ffe565        	call8	40083414 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
400835c0:	00a0c2        	movi	a12, 0
400835c3:	01ca92        	addi	a9, a10, 1
400835c6:	01a082        	movi	a8, 1
400835c9:	0c5d      	mov.n	a5, a12
400835cb:	835890        	moveqz	a5, a8, a9
400835ce:	059d      	mov.n	a9, a5
			      || (ticks < next_to);
400835d0:	0122a7        	blt	a2, a10, 400835d5 <z_set_timeout_expiry+0x21>
400835d3:	0c8d      	mov.n	a8, a12
400835d5:	208980        	or	a8, a9, a8
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
400835d8:	0b6807        	bbci	a8, 0, 400835e7 <z_set_timeout_expiry+0x33>
400835db:	082aa6        	blti	a10, 2, 400835e7 <z_set_timeout_expiry+0x33>
			z_clock_set_timeout(ticks, is_idle);
400835de:	20b330        	or	a11, a3, a3
400835e1:	20a220        	or	a10, a2, a2
400835e4:	fe0da5        	call8	400816c0 <z_clock_set_timeout>
	XTOS_RESTORE_INTLEVEL(key);
400835e7:	13e640        	wsr.ps	a4
400835ea:	002010        	rsync
		}
	}
}
400835ed:	000090        	retw

400835f0 <z_clock_announce>:

void z_clock_announce(int32_t ticks)
{
400835f0:	004136        	entry	a1, 32
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
400835f3:	02ad      	mov.n	a10, a2
400835f5:	ff7ae5        	call8	40082da4 <z_time_slice>
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400835f8:	006330        	rsil	a3, 3
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
400835fb:	f48b61        	l32r	a6, 40080828 <_iram_text_start+0x2d8>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
400835fe:	f3de41        	l32r	a4, 40080578 <_iram_text_start+0x28>
	announce_remaining = ticks;
40083601:	0629      	s32i.n	a2, a6, 0
		t->dticks = 0;
40083603:	f3dd51        	l32r	a5, 40080578 <_iram_text_start+0x28>
	while (first() != NULL && first()->dticks <= announce_remaining) {
40083606:	000c86        	j	4008363c <z_clock_announce+0x4c>
		curr_tick += dt;
40083609:	989a      	add.n	a9, a8, a9
4008360b:	31bf80        	srai	a11, a8, 31
4008360e:	1a0c      	movi.n	a10, 1
40083610:	013987        	bltu	a9, a8, 40083615 <z_clock_announce+0x25>
40083613:	0a0c      	movi.n	a10, 0
40083615:	ebea      	add.n	a14, a11, a14
40083617:	aaea      	add.n	a10, a10, a14
40083619:	1da9      	s32i.n	a10, a13, 4
		announce_remaining -= dt;
4008361b:	c08c80        	sub	a8, a12, a8
		t->dticks = 0;
4008361e:	4249      	s32i.n	a4, a2, 16
40083620:	5259      	s32i.n	a5, a2, 20
		remove_timeout(t);
40083622:	02ad      	mov.n	a10, a2
		curr_tick += dt;
40083624:	0d99      	s32i.n	a9, a13, 0
		announce_remaining -= dt;
40083626:	006682        	s32i	a8, a6, 0
		remove_timeout(t);
40083629:	ffdb25        	call8	400833dc <remove_timeout>
	XTOS_RESTORE_INTLEVEL(key);
4008362c:	13e630        	wsr.ps	a3
4008362f:	002010        	rsync

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
40083632:	2238      	l32i.n	a3, a2, 8
40083634:	02ad      	mov.n	a10, a2
40083636:	0003e0        	callx8	a3
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40083639:	006330        	rsil	a3, 3
	return list->head == list;
4008363c:	f47c81        	l32r	a8, 4008082c <_iram_text_start+0x2dc>
4008363f:	f47dd1        	l32r	a13, 40080834 <_iram_text_start+0x2e4>
40083642:	06c8      	l32i.n	a12, a6, 0
40083644:	0828      	l32i.n	a2, a8, 0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
40083646:	31bfc0        	srai	a11, a12, 31
40083649:	0d98      	l32i.n	a9, a13, 0
4008364b:	1de8      	l32i.n	a14, a13, 4
	while (first() != NULL && first()->dticks <= announce_remaining) {
4008364d:	129c      	beqz.n	a2, 40083662 <z_clock_announce+0x72>
4008364f:	0f1287        	beq	a2, a8, 40083662 <z_clock_announce+0x72>
40083652:	52a8      	l32i.n	a10, a2, 20
40083654:	4288      	l32i.n	a8, a2, 16
40083656:	323ba7        	bltu	a11, a10, 4008368c <z_clock_announce+0x9c>
40083659:	ac9ab7        	bne	a10, a11, 40083609 <z_clock_announce+0x19>
4008365c:	a9bc87        	bgeu	a12, a8, 40083609 <z_clock_announce+0x19>
4008365f:	000a46        	j	4008368c <z_clock_announce+0x9c>

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
	}

	curr_tick += announce_remaining;
40083662:	9c9a      	add.n	a9, a12, a9
40083664:	01a022        	movi	a2, 1
40083667:	0139c7        	bltu	a9, a12, 4008366c <z_clock_announce+0x7c>
4008366a:	020c      	movi.n	a2, 0
4008366c:	80bbe0        	add	a11, a11, a14
4008366f:	8022b0        	add	a2, a2, a11
40083672:	1d29      	s32i.n	a2, a13, 4
	announce_remaining = 0;
40083674:	020c      	movi.n	a2, 0
	curr_tick += announce_remaining;
40083676:	0d99      	s32i.n	a9, a13, 0
	announce_remaining = 0;
40083678:	0629      	s32i.n	a2, a6, 0

	z_clock_set_timeout(next_timeout(), false);
4008367a:	ffd9a5        	call8	40083414 <next_timeout>
4008367d:	02bd      	mov.n	a11, a2
4008367f:	fe0425        	call8	400816c0 <z_clock_set_timeout>
	XTOS_RESTORE_INTLEVEL(key);
40083682:	13e630        	wsr.ps	a3
40083685:	002010        	rsync

	k_spin_unlock(&timeout_lock, key);
}
40083688:	f01d      	retw.n
4008368a:	c00000        	sub	a0, a0, a0
		first()->dticks -= announce_remaining;
4008368d:	c048      	l32i.n	a4, a0, 48
4008368f:	01a052        	movi	a5, 1
40083692:	023847        	bltu	a8, a4, 40083698 <z_clock_announce+0xa8>
40083695:	00a052        	movi	a5, 0
40083698:	c0aab0        	sub	a10, a10, a11
4008369b:	c0aa50        	sub	a10, a10, a5
4008369e:	4249      	s32i.n	a4, a2, 16
400836a0:	52a9      	s32i.n	a10, a2, 20
400836a2:	ffef06        	j	40083662 <z_clock_announce+0x72>
400836a5:	000000        	ill

400836a8 <z_tick_get>:

int64_t z_tick_get(void)
{
400836a8:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400836ab:	006340        	rsil	a4, 3
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
400836ae:	fe0725        	call8	40081720 <z_clock_elapsed>
400836b1:	f46031        	l32r	a3, 40080834 <_iram_text_start+0x2e4>
400836b4:	002322        	l32i	a2, a3, 0
400836b7:	012382        	l32i	a8, a3, 4
400836ba:	802a20        	add	a2, a10, a2
400836bd:	130c      	movi.n	a3, 1
400836bf:	0132a7        	bltu	a2, a10, 400836c4 <z_tick_get+0x1c>
400836c2:	030c      	movi.n	a3, 0
400836c4:	338a      	add.n	a3, a3, a8
	XTOS_RESTORE_INTLEVEL(key);
400836c6:	13e640        	wsr.ps	a4
400836c9:	002010        	rsync
	}
	return t;
}
400836cc:	f01d      	retw.n
	...

400836d0 <z_tick_get_32>:

uint32_t z_tick_get_32(void)
{
400836d0:	004136        	entry	a1, 32
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)z_tick_get();
400836d3:	fffd65        	call8	400836a8 <z_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
400836d6:	0a2d      	mov.n	a2, a10
400836d8:	f01d      	retw.n
	...

400836dc <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
400836dc:	004136        	entry	a1, 32
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
400836df:	120c      	movi.n	a2, 1
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400836e1:	006380        	rsil	a8, 3
	int32_t ticks = z_get_next_timeout_expiry();
400836e4:	ffeba5        	call8	400835a0 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
400836e7:	013ae6        	bgei	a10, 3, 400836ec <idle+0x10>
400836ea:	02ad      	mov.n	a10, a2
400836ec:	02bd      	mov.n	a11, a2
400836ee:	ffec65        	call8	400835b4 <z_set_timeout_expiry>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
400836f1:	0008a5        	call8	4008377c <arch_cpu_idle>
400836f4:	fffa46        	j	400836e1 <idle+0x5>
	...

400836f8 <k_heap_init>:
#include <ksched.h>
#include <wait_q.h>
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
400836f8:	004136        	entry	a1, 32
400836fb:	0cc282        	addi	a8, a2, 12
400836fe:	20a220        	or	a10, a2, a2
	list->head = (sys_dnode_t *)list;
40083701:	036282        	s32i	a8, a2, 12
	list->tail = (sys_dnode_t *)list;
40083704:	4289      	s32i.n	a8, a2, 16
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
40083706:	04cd      	mov.n	a12, a4
40083708:	03bd      	mov.n	a11, a3
4008370a:	fda725        	call8	4008117c <sys_heap_init>
}
4008370d:	f01d      	retw.n
	...

40083710 <statics_init>:

static int statics_init(const struct device *unused)
{
40083710:	004136        	entry	a1, 32
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
40083713:	f44921        	l32r	a2, 40080838 <_iram_text_start+0x2e8>
40083716:	000386        	j	40083728 <statics_init+0x18>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
40083719:	0222c2        	l32i	a12, a2, 8
4008371c:	0122b2        	l32i	a11, a2, 4
4008371f:	20a220        	or	a10, a2, a2
40083722:	fffd65        	call8	400836f8 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
40083725:	14c222        	addi	a2, a2, 20
40083728:	f44531        	l32r	a3, 4008083c <_iram_text_start+0x2ec>
4008372b:	ea3237        	bltu	a2, a3, 40083719 <statics_init+0x9>
	}
	return 0;
}
4008372e:	020c      	movi.n	a2, 0
40083730:	f01d      	retw.n
	...

40083734 <i2c_read>:
 * @retval 0 If successful.
 * @retval -EIO General input / output error.
 */
static inline int i2c_read(const struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
40083734:	006136        	entry	a1, 48
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = num_bytes;
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
40083737:	380c      	movi.n	a8, 3
{
40083739:	02ad      	mov.n	a10, a2
4008373b:	05dd      	mov.n	a13, a5
	msg.buf = buf;
4008373d:	0139      	s32i.n	a3, a1, 0
	msg.len = num_bytes;
4008373f:	1149      	s32i.n	a4, a1, 4
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
40083741:	084182        	s8i	a8, a1, 8
	return api->transfer(dev, msgs, num_msgs, addr);
40083744:	2288      	l32i.n	a8, a2, 8
40083746:	1c0c      	movi.n	a12, 1
40083748:	1888      	l32i.n	a8, a8, 4
4008374a:	20b110        	or	a11, a1, a1
4008374d:	0008e0        	callx8	a8

	return i2c_transfer(dev, &msg, 1, addr);
}
40083750:	0a2d      	mov.n	a2, a10
40083752:	f01d      	retw.n

40083754 <i2c_write>:
{
40083754:	006136        	entry	a1, 48
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
40083757:	280c      	movi.n	a8, 2
{
40083759:	02ad      	mov.n	a10, a2
4008375b:	05dd      	mov.n	a13, a5
	msg.buf = (uint8_t *)buf;
4008375d:	0139      	s32i.n	a3, a1, 0
	msg.len = num_bytes;
4008375f:	1149      	s32i.n	a4, a1, 4
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
40083761:	084182        	s8i	a8, a1, 8
	return api->transfer(dev, msgs, num_msgs, addr);
40083764:	2288      	l32i.n	a8, a2, 8
40083766:	1c0c      	movi.n	a12, 1
40083768:	1888      	l32i.n	a8, a8, 4
4008376a:	20b110        	or	a11, a1, a1
4008376d:	0008e0        	callx8	a8
}
40083770:	0a2d      	mov.n	a2, a10
40083772:	f01d      	retw.n

40083774 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40083774:	004136        	entry	a1, 32
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_BOOTLOADER_SRAM_SIZE, 16);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
40083777:	f01d      	retw.n
40083779:	000000        	ill

4008377c <arch_cpu_idle>:
 */

#include <tracing/tracing.h>

void arch_cpu_idle(void)
{
4008377c:	004136        	entry	a1, 32
	sys_trace_idle();
	__asm__ volatile ("waiti 0");
4008377f:	007000        	waiti	0
}
40083782:	f01d      	retw.n

40083784 <z_xtensa_dump_stack>:
{
40083784:	004136        	entry	a1, 32
}
40083787:	f01d      	retw.n
40083789:	000000        	ill

4008378c <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
4008378c:	004136        	entry	a1, 32
	while ((*s1 == *s2) && (*s1 != '\0')) {
4008378f:	0000c6        	j	40083796 <strcmp+0xa>
		s1++;
40083792:	221b      	addi.n	a2, a2, 1
		s2++;
40083794:	331b      	addi.n	a3, a3, 1
	while ((*s1 == *s2) && (*s1 != '\0')) {
40083796:	000282        	l8ui	a8, a2, 0
40083799:	000392        	l8ui	a9, a3, 0
4008379c:	029897        	bne	a8, a9, 400837a2 <strcmp+0x16>
4008379f:	fef856        	bnez	a8, 40083792 <strcmp+0x6>
	}

	return *s1 - *s2;
}
400837a2:	c02890        	sub	a2, a8, a9
400837a5:	f01d      	retw.n
	...

400837a8 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
400837a8:	004136        	entry	a1, 32
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
400837ab:	74b030        	extui	a11, a3, 0, 8

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
400837ae:	028d      	mov.n	a8, a2
400837b0:	000286        	j	400837be <memset+0x16>
400837b3:	441600        	extui	a1, a0, 6, 5
		if (n == 0) {
400837b6:	48b204        	lsi	f0, a2, 0x120
			return buf;
		}
		*(d_byte++) = c_byte;
400837b9:	440b00        	extui	a0, a0, 11, 5
		n--;
400837bc:	881b      	addi.n	a8, a8, 1
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
400837be:	149080        	extui	a9, a8, 0, 2
400837c1:	08cd      	mov.n	a12, a8
400837c3:	fed956        	bnez	a9, 400837b4 <memset+0xc>
	};

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
400837c6:	743030        	extui	a3, a3, 0, 8

	c_word |= c_word << 8;
400837c9:	11a380        	slli	a10, a3, 8
400837cc:	203a30        	or	a3, a10, a3
	c_word |= c_word << 16;
400837cf:	11a300        	slli	a10, a3, 16
400837d2:	203a30        	or	a3, a10, a3
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
400837d5:	41a240        	srli	a10, a4, 2
400837d8:	11dae0        	slli	a13, a10, 2
400837db:	ed8a      	add.n	a14, a13, a8
400837dd:	0000c6        	j	400837e4 <memset+0x3c>
		*(d_word++) = c_word;
400837e0:	0839      	s32i.n	a3, a8, 0
		n -= sizeof(mem_word_t);
400837e2:	884b      	addi.n	a8, a8, 4
	while (n >= sizeof(mem_word_t)) {
400837e4:	f898e7        	bne	a8, a14, 400837e0 <memset+0x38>
400837e7:	11aae0        	slli	a10, a10, 2
400837ea:	c044a0        	sub	a4, a4, a10
400837ed:	000206        	j	400837f9 <memset+0x51>
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
		*(d_byte++) = c_byte;
400837f0:	39da      	add.n	a3, a9, a13
400837f2:	3c3a      	add.n	a3, a12, a3
400837f4:	0043b2        	s8i	a11, a3, 0
		n--;
400837f7:	991b      	addi.n	a9, a9, 1
	while (n > 0) {
400837f9:	f39497        	bne	a4, a9, 400837f0 <memset+0x48>
	}

	return buf;
}
400837fc:	f01d      	retw.n
	...

40083800 <_stdout_hook_default>:
{
40083800:	004136        	entry	a1, 32
}
40083803:	f27c      	movi.n	a2, -1
40083805:	f01d      	retw.n
	...

40083808 <gpio_esp32_port_get_raw>:
{
40083808:	004136        	entry	a1, 32
	*value = *data->port.input_reg;
4008380b:	3288      	l32i.n	a8, a2, 12
}
4008380d:	020c      	movi.n	a2, 0
	*value = *data->port.input_reg;
4008380f:	4888      	l32i.n	a8, a8, 16
40083811:	0020c0        	memw
40083814:	0888      	l32i.n	a8, a8, 0
40083816:	0389      	s32i.n	a8, a3, 0
}
40083818:	f01d      	retw.n
	...

4008381c <gpio_esp32_port_set_masked_raw>:
{
4008381c:	004136        	entry	a1, 32
	struct gpio_esp32_data *data = port->data;
4008381f:	3288      	l32i.n	a8, a2, 12
40083821:	0063a0        	rsil	a10, 3
	*data->port.output_reg = (*data->port.output_reg & ~mask)
40083824:	5888      	l32i.n	a8, a8, 20
40083826:	0020c0        	memw
40083829:	0898      	l32i.n	a9, a8, 0
				 | (mask & value);
4008382b:	304940        	xor	a4, a9, a4
4008382e:	104430        	and	a4, a4, a3
40083831:	304490        	xor	a4, a4, a9
	*data->port.output_reg = (*data->port.output_reg & ~mask)
40083834:	0020c0        	memw
40083837:	0849      	s32i.n	a4, a8, 0
	XTOS_RESTORE_INTLEVEL(key);
40083839:	13e6a0        	wsr.ps	a10
4008383c:	002010        	rsync
}
4008383f:	020c      	movi.n	a2, 0
40083841:	f01d      	retw.n
	...

40083844 <gpio_esp32_port_set_bits_raw>:
{
40083844:	004136        	entry	a1, 32
	*data->port.set_reg = pins;
40083847:	3288      	l32i.n	a8, a2, 12
}
40083849:	020c      	movi.n	a2, 0
	*data->port.set_reg = pins;
4008384b:	2888      	l32i.n	a8, a8, 8
4008384d:	0020c0        	memw
40083850:	0839      	s32i.n	a3, a8, 0
}
40083852:	f01d      	retw.n

40083854 <gpio_esp32_port_clear_bits_raw>:
{
40083854:	004136        	entry	a1, 32
	*data->port.clear_reg = pins;
40083857:	3288      	l32i.n	a8, a2, 12
}
40083859:	020c      	movi.n	a2, 0
	*data->port.clear_reg = pins;
4008385b:	3888      	l32i.n	a8, a8, 12
4008385d:	0020c0        	memw
40083860:	0839      	s32i.n	a3, a8, 0
}
40083862:	f01d      	retw.n

40083864 <gpio_esp32_port_toggle_bits>:
{
40083864:	004136        	entry	a1, 32
	struct gpio_esp32_data *data = port->data;
40083867:	3288      	l32i.n	a8, a2, 12
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
40083869:	0063a0        	rsil	a10, 3
	*data->port.output_reg = (*data->port.output_reg ^ pins);
4008386c:	5898      	l32i.n	a9, a8, 20
4008386e:	0020c0        	memw
40083871:	0988      	l32i.n	a8, a9, 0
40083873:	308830        	xor	a8, a8, a3
40083876:	0020c0        	memw
40083879:	0989      	s32i.n	a8, a9, 0
	XTOS_RESTORE_INTLEVEL(key);
4008387b:	13e6a0        	wsr.ps	a10
4008387e:	002010        	rsync
}
40083881:	020c      	movi.n	a2, 0
40083883:	f01d      	retw.n
40083885:	000000        	ill

40083888 <gpio_esp32_manage_callback>:
{
40083888:	004136        	entry	a1, 32
	struct gpio_esp32_data *data = dev->data;
4008388b:	3288      	l32i.n	a8, a2, 12
{
4008388d:	744040        	extui	a4, a4, 0, 8
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_slist_is_empty(sys_slist_t *list);

Z_GENLIST_IS_EMPTY(slist)
40083890:	9828      	l32i.n	a2, a8, 36
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40083892:	090c      	movi.n	a9, 0
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
40083894:	42cc      	bnez.n	a2, 4008389c <gpio_esp32_manage_callback+0x14>
40083896:	000fc6        	j	400838d9 <gpio_esp32_manage_callback+0x51>
40083899:	0a2d00        	add.s	f2, f13, f0
4008389c:	209327        	bne	a3, a2, 400838c0 <gpio_esp32_manage_callback+0x38>
Z_GENLIST_REMOVE(slist, snode)
4008389f:	0328      	l32i.n	a2, a3, 0
400838a1:	b9cc      	bnez.n	a9, 400838b0 <gpio_esp32_manage_callback+0x28>
400838a3:	a898      	l32i.n	a9, a8, 40
	list->head = node;
400838a5:	9829      	s32i.n	a2, a8, 36
Z_GENLIST_REMOVE(slist, snode)
400838a7:	0e9397        	bne	a3, a9, 400838b9 <gpio_esp32_manage_callback+0x31>
	list->tail = node;
400838aa:	a829      	s32i.n	a2, a8, 40
400838ac:	000246        	j	400838b9 <gpio_esp32_manage_callback+0x31>
400838af:	092900        	l32e	a0, a9, -56
Z_GENLIST_REMOVE(slist, snode)
400838b2:	a828      	l32i.n	a2, a8, 40
400838b4:	019327        	bne	a3, a2, 400838b9 <gpio_esp32_manage_callback+0x31>
	list->tail = node;
400838b7:	a899      	s32i.n	a9, a8, 40
	parent->next = child;
400838b9:	020c      	movi.n	a2, 0
400838bb:	0329      	s32i.n	a2, a3, 0
400838bd:	000606        	j	400838d9 <gpio_esp32_manage_callback+0x51>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
400838c0:	02a8      	l32i.n	a10, a2, 0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
400838c2:	029d      	mov.n	a9, a2
400838c4:	fd2a56        	bnez	a10, 4008389a <gpio_esp32_manage_callback+0x12>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
			if (!set) {
				return -EINVAL;
400838c7:	a26c      	movi.n	a2, -22
			if (!set) {
400838c9:	017416        	beqz	a4, 400838e4 <gpio_esp32_manage_callback+0x5c>
Z_GENLIST_PREPEND(slist, snode)
400838cc:	9828      	l32i.n	a2, a8, 36
	parent->next = child;
400838ce:	0329      	s32i.n	a2, a3, 0
Z_GENLIST_PREPEND(slist, snode)
400838d0:	a828      	l32i.n	a2, a8, 40
	list->head = node;
400838d2:	9839      	s32i.n	a3, a8, 36
Z_GENLIST_PREPEND(slist, snode)
400838d4:	42cc      	bnez.n	a2, 400838dc <gpio_esp32_manage_callback+0x54>
400838d6:	000206        	j	400838e2 <gpio_esp32_manage_callback+0x5a>
			}
		}
	}

	if (set) {
400838d9:	fef456        	bnez	a4, 400838cc <gpio_esp32_manage_callback+0x44>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
400838dc:	020c      	movi.n	a2, 0
400838de:	000086        	j	400838e4 <gpio_esp32_manage_callback+0x5c>
400838e1:	a83900        	lsi	f0, a9, 0x2a0
}
400838e4:	f01d      	retw.n
	...

400838e8 <gpio_esp32_fire_callbacks>:
{
400838e8:	004136        	entry	a1, 32
	struct gpio_esp32_data *data = device->data;
400838eb:	3238      	l32i.n	a3, a2, 12
	uint32_t irq_status = *data->port.irq_status_reg;
400838ed:	6348      	l32i.n	a4, a3, 24
	*data->port.irq_ack_reg = irq_status;
400838ef:	7388      	l32i.n	a8, a3, 28
	uint32_t irq_status = *data->port.irq_status_reg;
400838f1:	0020c0        	memw
400838f4:	0448      	l32i.n	a4, a4, 0
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
400838f6:	93b8      	l32i.n	a11, a3, 36
	*data->port.irq_ack_reg = irq_status;
400838f8:	0020c0        	memw
400838fb:	0849      	s32i.n	a4, a8, 0
400838fd:	8b9c      	beqz.n	a11, 40083919 <gpio_esp32_fire_callbacks+0x31>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
400838ff:	0b38      	l32i.n	a3, a11, 0
		if (cb->pin_mask & pins) {
40083901:	2bc8      	l32i.n	a12, a11, 8
40083903:	10c4c0        	and	a12, a4, a12
40083906:	6c8c      	beqz.n	a12, 40083910 <gpio_esp32_fire_callbacks+0x28>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
40083908:	1b88      	l32i.n	a8, a11, 4
4008390a:	20a220        	or	a10, a2, a2
4008390d:	0008e0        	callx8	a8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
40083910:	538c      	beqz.n	a3, 40083919 <gpio_esp32_fire_callbacks+0x31>
40083912:	03bd      	mov.n	a11, a3
40083914:	0338      	l32i.n	a3, a3, 0
40083916:	fff9c6        	j	40083901 <gpio_esp32_fire_callbacks+0x19>
}
40083919:	f01d      	retw.n
	...

4008391c <i2c_esp32_connect_irq_0>:
{
4008391c:	004136        	entry	a1, 32
}
4008391f:	f01d      	retw.n
40083921:	000000        	ill

40083924 <i2c_esp32_connect_irq_1>:
40083924:	004136        	entry	a1, 32
40083927:	f01d      	retw.n
40083929:	000000        	ill

4008392c <uart_esp32_poll_in>:
{
4008392c:	004136        	entry	a1, 32
	if (UART_RXFIFO_COUNT(DEV_BASE(dev)->status) == 0) {
4008392f:	1228      	l32i.n	a2, a2, 4
40083931:	0298      	l32i.n	a9, a2, 0
		return -1;
40083933:	f27c      	movi.n	a2, -1
	if (UART_RXFIFO_COUNT(DEV_BASE(dev)->status) == 0) {
40083935:	0020c0        	memw
40083938:	7988      	l32i.n	a8, a9, 28
4008393a:	748080        	extui	a8, a8, 0, 8
4008393d:	888c      	beqz.n	a8, 40083949 <uart_esp32_poll_in+0x1d>
	*p_char = DEV_BASE(dev)->fifo;
4008393f:	0020c0        	memw
40083942:	0928      	l32i.n	a2, a9, 0
40083944:	004322        	s8i	a2, a3, 0
	return 0;
40083947:	020c      	movi.n	a2, 0
}
40083949:	f01d      	retw.n
	...

4008394c <uart_esp32_poll_out>:
{
4008394c:	004136        	entry	a1, 32
	while (UART_TXFIFO_COUNT(DEV_BASE(dev)->status) >= UART_FIFO_LIMIT) {
4008394f:	1288      	l32i.n	a8, a2, 4
{
40083951:	743030        	extui	a3, a3, 0, 8
	while (UART_TXFIFO_COUNT(DEV_BASE(dev)->status) >= UART_FIFO_LIMIT) {
40083954:	0898      	l32i.n	a9, a8, 0
40083956:	7ea0a2        	movi	a10, 126
40083959:	0020c0        	memw
4008395c:	7988      	l32i.n	a8, a9, 28
4008395e:	758080        	extui	a8, a8, 16, 8
40083961:	f43a87        	bltu	a10, a8, 40083959 <uart_esp32_poll_out+0xd>
	DEV_BASE(dev)->fifo = (uint32_t)c;
40083964:	0020c0        	memw
40083967:	0939      	s32i.n	a3, a9, 0
}
40083969:	f01d      	retw.n
	...

4008396c <uart_esp32_err_check>:
{
4008396c:	004136        	entry	a1, 32
	uint32_t err = UART_GET_PARITY_ERR(DEV_BASE(dev)->int_st)
4008396f:	1228      	l32i.n	a2, a2, 4
40083971:	0288      	l32i.n	a8, a2, 0
40083973:	0020c0        	memw
40083976:	2828      	l32i.n	a2, a8, 8
		    | UART_GET_FRAME_ERR(DEV_BASE(dev)->int_st);
40083978:	0020c0        	memw
4008397b:	2888      	l32i.n	a8, a8, 8
	uint32_t err = UART_GET_PARITY_ERR(DEV_BASE(dev)->int_st)
4008397d:	412220        	srli	a2, a2, 2
		    | UART_GET_FRAME_ERR(DEV_BASE(dev)->int_st);
40083980:	418380        	srli	a8, a8, 3
40083983:	202280        	or	a2, a2, a8
}
40083986:	042020        	extui	a2, a2, 0, 1
40083989:	f01d      	retw.n
	...

4008398c <uart_esp32_config_get>:
{
4008398c:	004136        	entry	a1, 32
	cfg->baudrate = data->uart_config.baudrate;
4008398f:	3288      	l32i.n	a8, a2, 12
	if (UART_GET_PARITY_EN(DEV_BASE(dev)->conf0)) {
40083991:	1228      	l32i.n	a2, a2, 4
	cfg->baudrate = data->uart_config.baudrate;
40083993:	0888      	l32i.n	a8, a8, 0
		cfg->parity = UART_CFG_PARITY_NONE;
40083995:	090c      	movi.n	a9, 0
	cfg->baudrate = data->uart_config.baudrate;
40083997:	0389      	s32i.n	a8, a3, 0
	if (UART_GET_PARITY_EN(DEV_BASE(dev)->conf0)) {
40083999:	0288      	l32i.n	a8, a2, 0
4008399b:	0020c0        	memw
4008399e:	082822        	l32i	a2, a8, 32
400839a1:	076217        	bbci	a2, 1, 400839ac <uart_esp32_config_get+0x20>
		cfg->parity = UART_GET_PARITY(DEV_BASE(dev)->conf0);
400839a4:	0020c0        	memw
400839a7:	8898      	l32i.n	a9, a8, 32
400839a9:	049090        	extui	a9, a9, 0, 1
400839ac:	044392        	s8i	a9, a3, 4
	cfg->stop_bits = UART_GET_STOP_BITS(DEV_BASE(dev)->conf0);
400839af:	0020c0        	memw
400839b2:	8898      	l32i.n	a9, a8, 32
400839b4:	149490        	extui	a9, a9, 4, 2
400839b7:	054392        	s8i	a9, a3, 5
	cfg->data_bits = UART_GET_DATA_BITS(DEV_BASE(dev)->conf0);
400839ba:	0020c0        	memw
400839bd:	082892        	l32i	a9, a8, 32
400839c0:	149290        	extui	a9, a9, 2, 2
400839c3:	064392        	s8i	a9, a3, 6
	if (UART_GET_TX_FLOW(DEV_BASE(dev)->conf0)) {
400839c6:	0020c0        	memw
400839c9:	8828      	l32i.n	a2, a8, 32
400839cb:	0562f7        	bbci	a2, 15, 400839d4 <uart_esp32_config_get+0x48>
		cfg->flow_ctrl = UART_CFG_FLOW_CTRL_RTS_CTS;
400839ce:	01a022        	movi	a2, 1
400839d1:	074322        	s8i	a2, a3, 7
	if (UART_GET_RX_FLOW(DEV_BASE(dev)->conf1)) {
400839d4:	0020c0        	memw
400839d7:	9828      	l32i.n	a2, a8, 36
400839d9:	047277        	bbci	a2, 23, 400839e1 <uart_esp32_config_get+0x55>
		cfg->flow_ctrl = UART_CFG_FLOW_CTRL_DTR_DSR;
400839dc:	220c      	movi.n	a2, 2
400839de:	074322        	s8i	a2, a3, 7
}
400839e1:	020c      	movi.n	a2, 0
400839e3:	f01d      	retw.n
400839e5:	000000        	ill

400839e8 <arch_system_halt>:
{
400839e8:	004136        	entry	a1, 32
	unsigned int key = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
400839eb:	006380        	rsil	a8, 3
	for (;;) {
400839ee:	ffff06        	j	400839ee <arch_system_halt+0x6>
400839f1:	000000        	ill

400839f4 <z_impl_k_mutex_init>:
{
400839f4:	004136        	entry	a1, 32
400839f7:	028d      	mov.n	a8, a2
	mutex->owner = NULL;
400839f9:	020c      	movi.n	a2, 0
400839fb:	2829      	s32i.n	a2, a8, 8
	mutex->lock_count = 0U;
400839fd:	3829      	s32i.n	a2, a8, 12
	list->head = (sys_dnode_t *)list;
400839ff:	0889      	s32i.n	a8, a8, 0
	list->tail = (sys_dnode_t *)list;
40083a01:	1889      	s32i.n	a8, a8, 4
}
40083a03:	f01d      	retw.n
40083a05:	000000        	ill

40083a08 <sys_dlist_remove>:
{
40083a08:	004136        	entry	a1, 32
	node->prev->next = node->next;
40083a0b:	0288      	l32i.n	a8, a2, 0
40083a0d:	1298      	l32i.n	a9, a2, 4
40083a0f:	0989      	s32i.n	a8, a9, 0
	node->next->prev = node->prev;
40083a11:	1899      	s32i.n	a9, a8, 4
	node->next = NULL;
40083a13:	080c      	movi.n	a8, 0
40083a15:	0289      	s32i.n	a8, a2, 0
	node->prev = NULL;
40083a17:	1289      	s32i.n	a8, a2, 4
	sys_dnode_init(node);
}
40083a19:	f01d      	retw.n
	...

40083a1c <z_priq_dumb_best>:
{
40083a1c:	004136        	entry	a1, 32
	return list->head == list;
40083a1f:	0288      	l32i.n	a8, a2, 0
	if (n != NULL) {
40083a21:	188c      	beqz.n	a8, 40083a26 <z_priq_dumb_best+0xa>
40083a23:	019287        	bne	a2, a8, 40083a28 <z_priq_dumb_best+0xc>
	struct k_thread *thread = NULL;
40083a26:	080c      	movi.n	a8, 0
}
40083a28:	082d      	mov.n	a2, a8
40083a2a:	f01d      	retw.n

40083a2c <z_impl_k_sem_init>:
{
40083a2c:	004136        	entry	a1, 32
	CHECKIF(limit == 0U || initial_count > limit) {
40083a2f:	180c      	movi.n	a8, 1
40083a31:	090c      	movi.n	a9, 0
40083a33:	938940        	movnez	a8, a9, a4
40083a36:	748080        	extui	a8, a8, 0, 8
40083a39:	0f9897        	bne	a8, a9, 40083a4c <z_impl_k_sem_init+0x20>
40083a3c:	0c3437        	bltu	a4, a3, 40083a4c <z_impl_k_sem_init+0x20>
	sem->count = initial_count;
40083a3f:	2239      	s32i.n	a3, a2, 8
	sem->limit = limit;
40083a41:	3249      	s32i.n	a4, a2, 12
	list->head = (sys_dnode_t *)list;
40083a43:	0229      	s32i.n	a2, a2, 0
	list->tail = (sys_dnode_t *)list;
40083a45:	1229      	s32i.n	a2, a2, 4
	return 0;
40083a47:	082d      	mov.n	a2, a8
40083a49:	000046        	j	40083a4e <z_impl_k_sem_init+0x22>
		return -EINVAL;
40083a4c:	a26c      	movi.n	a2, -22
}
40083a4e:	f01d      	retw.n

40083a50 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
40083a50:	004136        	entry	a1, 32
/* size of the struct k_thread structure without save area for coproc regs */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 sizeof(struct k_thread) - sizeof(tCoopCoprocReg) -
			 sizeof(tPreempCoprocReg) + XT_CP_DESCR_SIZE);

GEN_ABS_SYM_END
40083a53:	f01d      	retw.n
40083a55:	000000        	ill

40083a58 <__udivdi3>:
40083a58:	004136        	entry	a1, 32
40083a5b:	03dd      	mov.n	a13, a3
40083a5d:	04ad      	mov.n	a10, a4
40083a5f:	053d      	mov.n	a3, a5
40083a61:	02cd      	mov.n	a12, a2
40083a63:	0d9d      	mov.n	a9, a13
40083a65:	184556        	bnez	a5, 40083bed <__udivdi3+0x195>
40083a68:	023d47        	bltu	a13, a4, 40083a6e <__udivdi3+0x16>
40083a6b:	002086        	j	40083af1 <__udivdi3+0x99>
40083a6e:	40f420        	nsau	a2, a4
40083a71:	c29c      	beqz.n	a2, 40083a91 <__udivdi3+0x39>
40083a73:	608020        	neg	a8, a2
40083a76:	400800        	ssr	a8
40083a79:	9180c0        	srl	a8, a12
40083a7c:	401200        	ssl	a2
40083a7f:	a19d00        	sll	a9, a13
40083a82:	401200        	ssl	a2
40083a85:	a1a400        	sll	a10, a4
40083a88:	209890        	or	a9, a8, a9
40083a8b:	401200        	ssl	a2
40083a8e:	a1cc00        	sll	a12, a12
40083a91:	f580a0        	extui	a8, a10, 16, 16
40083a94:	e2d980        	remu	a13, a9, a8
40083a97:	f440a0        	extui	a4, a10, 0, 16
40083a9a:	c29980        	quou	a9, a9, a8
40083a9d:	11dd00        	slli	a13, a13, 16
40083aa0:	f5b0c0        	extui	a11, a12, 16, 16
40083aa3:	822490        	mull	a2, a4, a9
40083aa6:	20bdb0        	or	a11, a13, a11
40083aa9:	13bb27        	bgeu	a11, a2, 40083ac0 <__udivdi3+0x68>
40083aac:	bbaa      	add.n	a11, a11, a10
40083aae:	590b      	addi.n	a5, a9, -1
40083ab0:	0a3ba7        	bltu	a11, a10, 40083abe <__udivdi3+0x66>
40083ab3:	07bb27        	bgeu	a11, a2, 40083abe <__udivdi3+0x66>
40083ab6:	fec992        	addi	a9, a9, -2
40083ab9:	bbaa      	add.n	a11, a11, a10
40083abb:	000046        	j	40083ac0 <__udivdi3+0x68>
40083abe:	059d      	mov.n	a9, a5
40083ac0:	c0bb20        	sub	a11, a11, a2
40083ac3:	e22b80        	remu	a2, a11, a8
40083ac6:	c2bb80        	quou	a11, a11, a8
40083ac9:	112200        	slli	a2, a2, 16
40083acc:	f4c0c0        	extui	a12, a12, 0, 16
40083acf:	8244b0        	mull	a4, a4, a11
40083ad2:	20c2c0        	or	a12, a2, a12
40083ad5:	0fbc47        	bgeu	a12, a4, 40083ae8 <__udivdi3+0x90>
40083ad8:	caca      	add.n	a12, a10, a12
40083ada:	ffcb22        	addi	a2, a11, -1
40083add:	05bc47        	bgeu	a12, a4, 40083ae6 <__udivdi3+0x8e>
40083ae0:	fecbb2        	addi	a11, a11, -2
40083ae3:	01bca7        	bgeu	a12, a10, 40083ae8 <__udivdi3+0x90>
40083ae6:	02bd      	mov.n	a11, a2
40083ae8:	118900        	slli	a8, a9, 16
40083aeb:	2088b0        	or	a8, a8, a11
40083aee:	007406        	j	40083cc2 <__udivdi3+0x26a>
40083af1:	34cc      	bnez.n	a4, 40083af8 <__udivdi3+0xa0>
40083af3:	130c      	movi.n	a3, 1
40083af5:	c2a340        	quou	a10, a3, a4
40083af8:	40fa50        	nsau	a5, a10
40083afb:	c08da0        	sub	a8, a13, a10
40083afe:	130c      	movi.n	a3, 1
40083b00:	089516        	beqz	a5, 40083b8d <__udivdi3+0x135>
40083b03:	042c      	movi.n	a4, 32
40083b05:	c04450        	sub	a4, a4, a5
40083b08:	401500        	ssl	a5
40083b0b:	a1aa00        	sll	a10, a10
40083b0e:	400400        	ssr	a4
40083b11:	9130d0        	srl	a3, a13
40083b14:	401500        	ssl	a5
40083b17:	a18d00        	sll	a8, a13
40083b1a:	400400        	ssr	a4
40083b1d:	914020        	srl	a4, a2
40083b20:	401500        	ssl	a5
40083b23:	a1c200        	sll	a12, a2
40083b26:	f520a0        	extui	a2, a10, 16, 16
40083b29:	204480        	or	a4, a4, a8
40083b2c:	e2b320        	remu	a11, a3, a2
40083b2f:	f480a0        	extui	a8, a10, 0, 16
40083b32:	c23320        	quou	a3, a3, a2
40083b35:	11bb00        	slli	a11, a11, 16
40083b38:	f59040        	extui	a9, a4, 16, 16
40083b3b:	825830        	mull	a5, a8, a3
40083b3e:	209b90        	or	a9, a11, a9
40083b41:	13b957        	bgeu	a9, a5, 40083b58 <__udivdi3+0x100>
40083b44:	99aa      	add.n	a9, a9, a10
40083b46:	b30b      	addi.n	a11, a3, -1
40083b48:	0a39a7        	bltu	a9, a10, 40083b56 <__udivdi3+0xfe>
40083b4b:	07b957        	bgeu	a9, a5, 40083b56 <__udivdi3+0xfe>
40083b4e:	fec332        	addi	a3, a3, -2
40083b51:	99aa      	add.n	a9, a9, a10
40083b53:	000046        	j	40083b58 <__udivdi3+0x100>
40083b56:	0b3d      	mov.n	a3, a11
40083b58:	c09950        	sub	a9, a9, a5
40083b5b:	e2b920        	remu	a11, a9, a2
40083b5e:	c29920        	quou	a9, a9, a2
40083b61:	822890        	mull	a2, a8, a9
40083b64:	11bb00        	slli	a11, a11, 16
40083b67:	f48040        	extui	a8, a4, 0, 16
40083b6a:	208b80        	or	a8, a11, a8
40083b6d:	13b827        	bgeu	a8, a2, 40083b84 <__udivdi3+0x12c>
40083b70:	88aa      	add.n	a8, a8, a10
40083b72:	490b      	addi.n	a4, a9, -1
40083b74:	0a38a7        	bltu	a8, a10, 40083b82 <__udivdi3+0x12a>
40083b77:	07b827        	bgeu	a8, a2, 40083b82 <__udivdi3+0x12a>
40083b7a:	fec992        	addi	a9, a9, -2
40083b7d:	88aa      	add.n	a8, a8, a10
40083b7f:	000046        	j	40083b84 <__udivdi3+0x12c>
40083b82:	049d      	mov.n	a9, a4
40083b84:	113300        	slli	a3, a3, 16
40083b87:	c08820        	sub	a8, a8, a2
40083b8a:	203390        	or	a3, a3, a9
40083b8d:	f550a0        	extui	a5, a10, 16, 16
40083b90:	e2b850        	remu	a11, a8, a5
40083b93:	f440a0        	extui	a4, a10, 0, 16
40083b96:	c28850        	quou	a8, a8, a5
40083b99:	11bb00        	slli	a11, a11, 16
40083b9c:	f590c0        	extui	a9, a12, 16, 16
40083b9f:	822480        	mull	a2, a4, a8
40083ba2:	209b90        	or	a9, a11, a9
40083ba5:	13b927        	bgeu	a9, a2, 40083bbc <__udivdi3+0x164>
40083ba8:	99aa      	add.n	a9, a9, a10
40083baa:	b80b      	addi.n	a11, a8, -1
40083bac:	0a39a7        	bltu	a9, a10, 40083bba <__udivdi3+0x162>
40083baf:	07b927        	bgeu	a9, a2, 40083bba <__udivdi3+0x162>
40083bb2:	fec882        	addi	a8, a8, -2
40083bb5:	99aa      	add.n	a9, a9, a10
40083bb7:	000046        	j	40083bbc <__udivdi3+0x164>
40083bba:	0b8d      	mov.n	a8, a11
40083bbc:	c09920        	sub	a9, a9, a2
40083bbf:	e22950        	remu	a2, a9, a5
40083bc2:	c29950        	quou	a9, a9, a5
40083bc5:	112200        	slli	a2, a2, 16
40083bc8:	f4c0c0        	extui	a12, a12, 0, 16
40083bcb:	824490        	mull	a4, a4, a9
40083bce:	20c2c0        	or	a12, a2, a12
40083bd1:	0fbc47        	bgeu	a12, a4, 40083be4 <__udivdi3+0x18c>
40083bd4:	caca      	add.n	a12, a10, a12
40083bd6:	ffc922        	addi	a2, a9, -1
40083bd9:	053ca7        	bltu	a12, a10, 40083be2 <__udivdi3+0x18a>
40083bdc:	fec992        	addi	a9, a9, -2
40083bdf:	013c47        	bltu	a12, a4, 40083be4 <__udivdi3+0x18c>
40083be2:	029d      	mov.n	a9, a2
40083be4:	118800        	slli	a8, a8, 16
40083be7:	208890        	or	a8, a8, a9
40083bea:	003506        	j	40083cc2 <__udivdi3+0x26a>
40083bed:	030c      	movi.n	a3, 0
40083bef:	038d      	mov.n	a8, a3
40083bf1:	02bd57        	bgeu	a13, a5, 40083bf7 <__udivdi3+0x19f>
40083bf4:	003286        	j	40083cc2 <__udivdi3+0x26a>
40083bf7:	40f5b0        	nsau	a11, a5
40083bfa:	179b37        	bne	a11, a3, 40083c15 <__udivdi3+0x1bd>
40083bfd:	180c      	movi.n	a8, 1
40083bff:	0235d7        	bltu	a5, a13, 40083c05 <__udivdi3+0x1ad>
40083c02:	208bb0        	or	a8, a11, a11
40083c05:	130c      	movi.n	a3, 1
40083c07:	01b247        	bgeu	a2, a4, 40083c0c <__udivdi3+0x1b4>
40083c0a:	030c      	movi.n	a3, 0
40083c0c:	208830        	or	a8, a8, a3
40083c0f:	748080        	extui	a8, a8, 0, 8
40083c12:	002a86        	j	40083cc0 <__udivdi3+0x268>
40083c15:	092c      	movi.n	a9, 32
40083c17:	c099b0        	sub	a9, a9, a11
40083c1a:	400900        	ssr	a9
40083c1d:	913040        	srl	a3, a4
40083c20:	401b00        	ssl	a11
40083c23:	a15500        	sll	a5, a5
40083c26:	205350        	or	a5, a3, a5
40083c29:	400900        	ssr	a9
40083c2c:	9180d0        	srl	a8, a13
40083c2f:	401b00        	ssl	a11
40083c32:	a13d00        	sll	a3, a13
40083c35:	400900        	ssr	a9
40083c38:	919020        	srl	a9, a2
40083c3b:	f5d050        	extui	a13, a5, 16, 16
40083c3e:	203930        	or	a3, a9, a3
40083c41:	f4c050        	extui	a12, a5, 0, 16
40083c44:	e298d0        	remu	a9, a8, a13
40083c47:	c288d0        	quou	a8, a8, a13
40083c4a:	119900        	slli	a9, a9, 16
40083c4d:	f5e030        	extui	a14, a3, 16, 16
40083c50:	82ac80        	mull	a10, a12, a8
40083c53:	2099e0        	or	a9, a9, a14
40083c56:	401b00        	ssl	a11
40083c59:	a14400        	sll	a4, a4
40083c5c:	14b9a7        	bgeu	a9, a10, 40083c74 <__udivdi3+0x21c>
40083c5f:	995a      	add.n	a9, a9, a5
40083c61:	e80b      	addi.n	a14, a8, -1
40083c63:	0bb9a7        	bgeu	a9, a10, 40083c72 <__udivdi3+0x21a>
40083c66:	083957        	bltu	a9, a5, 40083c72 <__udivdi3+0x21a>
40083c69:	fec882        	addi	a8, a8, -2
40083c6c:	995a      	add.n	a9, a9, a5
40083c6e:	000086        	j	40083c74 <__udivdi3+0x21c>
40083c71:	0e8d00        	lsi	f0, a13, 56
40083c74:	c0a9a0        	sub	a10, a9, a10
40083c77:	e29ad0        	remu	a9, a10, a13
40083c7a:	c2aad0        	quou	a10, a10, a13
40083c7d:	119900        	slli	a9, a9, 16
40083c80:	f43030        	extui	a3, a3, 0, 16
40083c83:	82cca0        	mull	a12, a12, a10
40083c86:	203930        	or	a3, a9, a3
40083c89:	13b3c7        	bgeu	a3, a12, 40083ca0 <__udivdi3+0x248>
40083c8c:	335a      	add.n	a3, a3, a5
40083c8e:	9a0b      	addi.n	a9, a10, -1
40083c90:	0a3357        	bltu	a3, a5, 40083c9e <__udivdi3+0x246>
40083c93:	07b3c7        	bgeu	a3, a12, 40083c9e <__udivdi3+0x246>
40083c96:	fecaa2        	addi	a10, a10, -2
40083c99:	335a      	add.n	a3, a3, a5
40083c9b:	000046        	j	40083ca0 <__udivdi3+0x248>
40083c9e:	09ad      	mov.n	a10, a9
40083ca0:	118800        	slli	a8, a8, 16
40083ca3:	2088a0        	or	a8, a8, a10
40083ca6:	825840        	mull	a5, a8, a4
40083ca9:	a24840        	muluh	a4, a8, a4
40083cac:	c033c0        	sub	a3, a3, a12
40083caf:	0b3347        	bltu	a3, a4, 40083cbe <__udivdi3+0x266>
40083cb2:	401b00        	ssl	a11
40083cb5:	a12200        	sll	a2, a2
40083cb8:	04b257        	bgeu	a2, a5, 40083cc0 <__udivdi3+0x268>
40083cbb:	019347        	bne	a3, a4, 40083cc0 <__udivdi3+0x268>
40083cbe:	880b      	addi.n	a8, a8, -1
40083cc0:	030c      	movi.n	a3, 0
40083cc2:	082d      	mov.n	a2, a8
40083cc4:	f01d      	retw.n
	...

40083cc8 <__umoddi3>:
40083cc8:	004136        	entry	a1, 32
40083ccb:	04bd      	mov.n	a11, a4
40083ccd:	208220        	or	a8, a2, a2
40083cd0:	039d      	mov.n	a9, a3
40083cd2:	152556        	bnez	a5, 40083e28 <__umoddi3+0x160>
40083cd5:	71b347        	bgeu	a3, a4, 40083d4a <__umoddi3+0x82>
40083cd8:	40f4a0        	nsau	a10, a4
40083cdb:	01da16        	beqz	a10, 40083cfc <__umoddi3+0x34>
40083cde:	401a00        	ssl	a10
40083ce1:	a19300        	sll	a9, a3
40083ce4:	6030a0        	neg	a3, a10
40083ce7:	400300        	ssr	a3
40083cea:	913020        	srl	a3, a2
40083ced:	401a00        	ssl	a10
40083cf0:	a1b400        	sll	a11, a4
40083cf3:	209390        	or	a9, a3, a9
40083cf6:	401a00        	ssl	a10
40083cf9:	a18200        	sll	a8, a2
40083cfc:	f540b0        	extui	a4, a11, 16, 16
40083cff:	e23940        	remu	a3, a9, a4
40083d02:	f420b0        	extui	a2, a11, 0, 16
40083d05:	c29940        	quou	a9, a9, a4
40083d08:	113300        	slli	a3, a3, 16
40083d0b:	f55080        	extui	a5, a8, 16, 16
40083d0e:	829290        	mull	a9, a2, a9
40083d11:	203350        	or	a3, a3, a5
40083d14:	09b397        	bgeu	a3, a9, 40083d21 <__umoddi3+0x59>
40083d17:	33ba      	add.n	a3, a3, a11
40083d19:	0433b7        	bltu	a3, a11, 40083d21 <__umoddi3+0x59>
40083d1c:	01b397        	bgeu	a3, a9, 40083d21 <__umoddi3+0x59>
40083d1f:	33ba      	add.n	a3, a3, a11
40083d21:	c09390        	sub	a9, a3, a9
40083d24:	e23940        	remu	a3, a9, a4
40083d27:	c29940        	quou	a9, a9, a4
40083d2a:	829290        	mull	a9, a2, a9
40083d2d:	f48080        	extui	a8, a8, 0, 16
40083d30:	112300        	slli	a2, a3, 16
40083d33:	208280        	or	a8, a2, a8
40083d36:	0ab897        	bgeu	a8, a9, 40083d44 <__umoddi3+0x7c>
40083d39:	88ba      	add.n	a8, a8, a11
40083d3b:	05b897        	bgeu	a8, a9, 40083d44 <__umoddi3+0x7c>
40083d3e:	0238b7        	bltu	a8, a11, 40083d44 <__umoddi3+0x7c>
40083d41:	8088b0        	add	a8, a8, a11
40083d44:	c08890        	sub	a8, a8, a9
40083d47:	003406        	j	40083e1b <__umoddi3+0x153>
40083d4a:	34cc      	bnez.n	a4, 40083d51 <__umoddi3+0x89>
40083d4c:	140c      	movi.n	a4, 1
40083d4e:	c2b4b0        	quou	a11, a4, a11
40083d51:	40fba0        	nsau	a10, a11
40083d54:	5acc      	bnez.n	a10, 40083d5d <__umoddi3+0x95>
40083d56:	c033b0        	sub	a3, a3, a11
40083d59:	001c86        	j	40083dcf <__umoddi3+0x107>
40083d5c:	042c00        	extui	a2, a0, 12, 1
40083d5f:	c044a0        	sub	a4, a4, a10
40083d62:	401a00        	ssl	a10
40083d65:	a1bb00        	sll	a11, a11
40083d68:	400400        	ssr	a4
40083d6b:	915030        	srl	a5, a3
40083d6e:	f5c0b0        	extui	a12, a11, 16, 16
40083d71:	401a00        	ssl	a10
40083d74:	a13300        	sll	a3, a3
40083d77:	400400        	ssr	a4
40083d7a:	914020        	srl	a4, a2
40083d7d:	204430        	or	a4, a4, a3
40083d80:	401a00        	ssl	a10
40083d83:	a18200        	sll	a8, a2
40083d86:	f430b0        	extui	a3, a11, 0, 16
40083d89:	e225c0        	remu	a2, a5, a12
40083d8c:	c255c0        	quou	a5, a5, a12
40083d8f:	112200        	slli	a2, a2, 16
40083d92:	f59040        	extui	a9, a4, 16, 16
40083d95:	825350        	mull	a5, a3, a5
40083d98:	202290        	or	a2, a2, a9
40083d9b:	09b257        	bgeu	a2, a5, 40083da8 <__umoddi3+0xe0>
40083d9e:	22ba      	add.n	a2, a2, a11
40083da0:	0432b7        	bltu	a2, a11, 40083da8 <__umoddi3+0xe0>
40083da3:	01b257        	bgeu	a2, a5, 40083da8 <__umoddi3+0xe0>
40083da6:	22ba      	add.n	a2, a2, a11
40083da8:	c09250        	sub	a9, a2, a5
40083dab:	e229c0        	remu	a2, a9, a12
40083dae:	c299c0        	quou	a9, a9, a12
40083db1:	829390        	mull	a9, a3, a9
40083db4:	112200        	slli	a2, a2, 16
40083db7:	f43040        	extui	a3, a4, 0, 16
40083dba:	203230        	or	a3, a2, a3
40083dbd:	0bb397        	bgeu	a3, a9, 40083dcc <__umoddi3+0x104>
40083dc0:	8033b0        	add	a3, a3, a11
40083dc3:	05b397        	bgeu	a3, a9, 40083dcc <__umoddi3+0x104>
40083dc6:	0233b7        	bltu	a3, a11, 40083dcc <__umoddi3+0x104>
40083dc9:	8033b0        	add	a3, a3, a11
40083dcc:	c03390        	sub	a3, a3, a9
40083dcf:	f540b0        	extui	a4, a11, 16, 16
40083dd2:	e29340        	remu	a9, a3, a4
40083dd5:	f420b0        	extui	a2, a11, 0, 16
40083dd8:	c23340        	quou	a3, a3, a4
40083ddb:	119900        	slli	a9, a9, 16
40083dde:	f55080        	extui	a5, a8, 16, 16
40083de1:	823230        	mull	a3, a2, a3
40083de4:	209950        	or	a9, a9, a5
40083de7:	09b937        	bgeu	a9, a3, 40083df4 <__umoddi3+0x12c>
40083dea:	99ba      	add.n	a9, a9, a11
40083dec:	0439b7        	bltu	a9, a11, 40083df4 <__umoddi3+0x12c>
40083def:	01b937        	bgeu	a9, a3, 40083df4 <__umoddi3+0x12c>
40083df2:	99ba      	add.n	a9, a9, a11
40083df4:	c03930        	sub	a3, a9, a3
40083df7:	e25340        	remu	a5, a3, a4
40083dfa:	c23340        	quou	a3, a3, a4
40083dfd:	823230        	mull	a3, a2, a3
40083e00:	f48080        	extui	a8, a8, 0, 16
40083e03:	112500        	slli	a2, a5, 16
40083e06:	208280        	or	a8, a2, a8
40083e09:	0bb837        	bgeu	a8, a3, 40083e18 <__umoddi3+0x150>
40083e0c:	8088b0        	add	a8, a8, a11
40083e0f:	05b837        	bgeu	a8, a3, 40083e18 <__umoddi3+0x150>
40083e12:	0238b7        	bltu	a8, a11, 40083e18 <__umoddi3+0x150>
40083e15:	8088b0        	add	a8, a8, a11
40083e18:	c08830        	sub	a8, a8, a3
40083e1b:	400a00        	ssr	a10
40083e1e:	912080        	srl	a2, a8
40083e21:	030c      	movi.n	a3, 0
40083e23:	004446        	j	40083f38 <__umoddi3+0x270>
40083e26:	570000        	lsi	f0, a0, 0x15c
40083e29:	4602b3        	lsi	f11, a2, 0x118
40083e2c:	c00042        	l8ui	a4, a0, 192
40083e2f:	dc40f5        	call12	4006023c <esp32_rom_gpio_matrix_out+0x56330>
40083e32:	37dc      	bnez.n	a7, 40083e49 <__umoddi3+0x181>
40083e34:	470235        	call12	400cae58 <_iram_text_end+0x46f1e>
40083e37:	401132        	l16ui	a3, a1, 128
40083e3a:	50c082        	addi	a8, a0, 80
40083e3d:	92c033        	ssip	f3, a0, 0x248
40083e40:	8701a0        	lsi	f10, a1, 0x21c
40083e43:	920232        	l8ui	a3, a2, 146
40083e46:	9000a0        	addx2	a0, a0, a10
40083e49:	2dc093        	ssip	f9, a0, 180
40083e4c:	3d08      	l32i.n	a0, a13, 12
40083e4e:	4609      	s32i.n	a0, a6, 16
40083e50:	0039      	s32i.n	a3, a0, 0
40083e52:	092c      	movi.n	a9, 32
40083e54:	c099c0        	sub	a9, a9, a12
40083e57:	400900        	ssr	a9
40083e5a:	91a040        	srl	a10, a4
40083e5d:	401c00        	ssl	a12
40083e60:	a15500        	sll	a5, a5
40083e63:	205a50        	or	a5, a10, a5
40083e66:	400900        	ssr	a9
40083e69:	91d020        	srl	a13, a2
40083e6c:	400900        	ssr	a9
40083e6f:	91a030        	srl	a10, a3
40083e72:	f5e050        	extui	a14, a5, 16, 16
40083e75:	401c00        	ssl	a12
40083e78:	a13300        	sll	a3, a3
40083e7b:	20dd30        	or	a13, a13, a3
40083e7e:	e2bae0        	remu	a11, a10, a14
40083e81:	f43050        	extui	a3, a5, 0, 16
40083e84:	c2aae0        	quou	a10, a10, a14
40083e87:	11bb00        	slli	a11, a11, 16
40083e8a:	f5f0d0        	extui	a15, a13, 16, 16
40083e8d:	8283a0        	mull	a8, a3, a10
40083e90:	20bbf0        	or	a11, a11, a15
40083e93:	401c00        	ssl	a12
40083e96:	a14400        	sll	a4, a4
40083e99:	401c00        	ssl	a12
40083e9c:	a12200        	sll	a2, a2
40083e9f:	15bb87        	bgeu	a11, a8, 40083eb8 <__umoddi3+0x1f0>
40083ea2:	bb5a      	add.n	a11, a11, a5
40083ea4:	fa0b      	addi.n	a15, a10, -1
40083ea6:	0c3b57        	bltu	a11, a5, 40083eb6 <__umoddi3+0x1ee>
40083ea9:	09bb87        	bgeu	a11, a8, 40083eb6 <__umoddi3+0x1ee>
40083eac:	fecaa2        	addi	a10, a10, -2
40083eaf:	bb5a      	add.n	a11, a11, a5
40083eb1:	0000c6        	j	40083eb8 <__umoddi3+0x1f0>
40083eb4:	ad0000        	lsi	f0, a0, 0x2b4
40083eb7:	0f          	.byte 0xf
40083eb8:	c0bb80        	sub	a11, a11, a8
40083ebb:	e28be0        	remu	a8, a11, a14
40083ebe:	c2bbe0        	quou	a11, a11, a14
40083ec1:	82e3b0        	mull	a14, a3, a11
40083ec4:	118800        	slli	a8, a8, 16
40083ec7:	f430d0        	extui	a3, a13, 0, 16
40083eca:	203830        	or	a3, a8, a3
40083ecd:	13b3e7        	bgeu	a3, a14, 40083ee4 <__umoddi3+0x21c>
40083ed0:	335a      	add.n	a3, a3, a5
40083ed2:	8b0b      	addi.n	a8, a11, -1
40083ed4:	0ab3e7        	bgeu	a3, a14, 40083ee2 <__umoddi3+0x21a>
40083ed7:	073357        	bltu	a3, a5, 40083ee2 <__umoddi3+0x21a>
40083eda:	fecbb2        	addi	a11, a11, -2
40083edd:	335a      	add.n	a3, a3, a5
40083edf:	000046        	j	40083ee4 <__umoddi3+0x21c>
40083ee2:	08bd      	mov.n	a11, a8
40083ee4:	11aa00        	slli	a10, a10, 16
40083ee7:	20aab0        	or	a10, a10, a11
40083eea:	82da40        	mull	a13, a10, a4
40083eed:	a2aa40        	muluh	a10, a10, a4
40083ef0:	c033e0        	sub	a3, a3, a14
40083ef3:	0abd      	mov.n	a11, a10
40083ef5:	0d8d      	mov.n	a8, a13
40083ef7:	0533a7        	bltu	a3, a10, 40083f00 <__umoddi3+0x238>
40083efa:	1493a7        	bne	a3, a10, 40083f12 <__umoddi3+0x24a>
40083efd:	11b2d7        	bgeu	a2, a13, 40083f12 <__umoddi3+0x24a>
40083f00:	c04d40        	sub	a4, a13, a4
40083f03:	c0aa50        	sub	a10, a10, a5
40083f06:	1b0c      	movi.n	a11, 1
40083f08:	013d47        	bltu	a13, a4, 40083f0d <__umoddi3+0x245>
40083f0b:	0b0c      	movi.n	a11, 0
40083f0d:	c0bab0        	sub	a11, a10, a11
40083f10:	048d      	mov.n	a8, a4
40083f12:	c04280        	sub	a4, a2, a8
40083f15:	c033b0        	sub	a3, a3, a11
40083f18:	150c      	movi.n	a5, 1
40083f1a:	023247        	bltu	a2, a4, 40083f20 <__umoddi3+0x258>
40083f1d:	00a052        	movi	a5, 0
40083f20:	c03350        	sub	a3, a3, a5
40083f23:	401900        	ssl	a9
40083f26:	a18300        	sll	a8, a3
40083f29:	400c00        	ssr	a12
40083f2c:	912040        	srl	a2, a4
40083f2f:	202820        	or	a2, a8, a2
40083f32:	400c00        	ssr	a12
40083f35:	913030        	srl	a3, a3
40083f38:	f01d      	retw.n
